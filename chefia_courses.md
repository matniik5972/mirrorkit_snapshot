# Snapshot – chefia_courses – 2025-09-15T23:19:23
**Snapshot-Of:** `6482085b719a5dd2e6e053ebcd5c4b3ae03bd177`
**Generated:** 2025-09-15T23:19:23
**Files:** 50

## Index
- `chefia_courses/pubspec.yaml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/pubspec.yaml)
- `chefia_courses/android/app/src/debug/AndroidManifest.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/android/app/src/debug/AndroidManifest.xml)
- `chefia_courses/android/app/src/main/AndroidManifest.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/android/app/src/main/AndroidManifest.xml)
- `chefia_courses/android/app/src/main/kotlin/com/example/chefia_courses/MainActivity.kt` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/android/app/src/main/kotlin/com/example/chefia_courses/MainActivity.kt)
- `chefia_courses/android/app/src/main/kotlin/com/example/chefia_courses/pantry/PantryImportReceiver.kt` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/android/app/src/main/kotlin/com/example/chefia_courses/pantry/PantryImportReceiver.kt)
- `chefia_courses/android/app/src/main/kotlin/com/example/chefia_courses/pantry/PantryImportWorker.kt` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/android/app/src/main/kotlin/com/example/chefia_courses/pantry/PantryImportWorker.kt)
- `chefia_courses/android/app/src/main/res/drawable/launch_background.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/android/app/src/main/res/drawable/launch_background.xml)
- `chefia_courses/android/app/src/main/res/drawable-v21/launch_background.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/android/app/src/main/res/drawable-v21/launch_background.xml)
- `chefia_courses/android/app/src/main/res/values/styles.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/android/app/src/main/res/values/styles.xml)
- `chefia_courses/android/app/src/main/res/values-night/styles.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/android/app/src/main/res/values-night/styles.xml)
- `chefia_courses/android/app/src/profile/AndroidManifest.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/android/app/src/profile/AndroidManifest.xml)
- `chefia_courses/lib/data/storage/hive_storage.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/data/storage/hive_storage.dart)
- `chefia_courses/lib/data/storage/storage_repository.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/data/storage/storage_repository.dart)
- `chefia_courses/lib/domain/models/pantry_item.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/domain/models/pantry_item.dart)
- `chefia_courses/lib/domain/models/product.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/domain/models/product.dart)
- `chefia_courses/lib/domain/models/shopping_item.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/domain/models/shopping_item.dart)
- `chefia_courses/lib/features/examples/storage_examples.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/examples/storage_examples.dart)
- `chefia_courses/lib/features/lists/data/shopping_repository.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/lists/data/shopping_repository.dart)
- `chefia_courses/lib/features/lists/domain/shopping_list.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/lists/domain/shopping_list.dart)
- `chefia_courses/lib/features/lists/ui/home_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/lists/ui/home_screen.dart)
- `chefia_courses/lib/features/lists/ui/list_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/lists/ui/list_screen.dart)
- `chefia_courses/lib/features/personalization/user_lexicon.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/personalization/user_lexicon.dart)
- `chefia_courses/lib/features/products/ui/product_check_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/products/ui/product_check_screen.dart)
- `chefia_courses/lib/features/shopping/barcode_scan_sheet.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/shopping/barcode_scan_sheet.dart)
- `chefia_courses/lib/features/shopping/catalog.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/shopping/catalog.dart)
- `chefia_courses/lib/features/shopping/models.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/shopping/models.dart)
- `chefia_courses/lib/features/shopping/providers.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/shopping/providers.dart)
- `chefia_courses/lib/features/shopping/voice_input.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/shopping/voice_input.dart)
- `chefia_courses/lib/features/shopping/voice_nlu_cloud.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/shopping/voice_nlu_cloud.dart)
- `chefia_courses/lib/features/shopping/voice_parser.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/shopping/voice_parser.dart)
- `chefia_courses/lib/features/tickets/ui/receipt_review_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/features/tickets/ui/receipt_review_screen.dart)
- `chefia_courses/lib/models/mappers/shopping_item_mapper.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/models/mappers/shopping_item_mapper.dart)
- `chefia_courses/lib/services/ai_orchestrator.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/services/ai_orchestrator.dart)
- `chefia_courses/lib/services/ai_provider.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/services/ai_provider.dart)
- `chefia_courses/lib/services/chefia_cuisine_service.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/services/chefia_cuisine_service.dart)
- `chefia_courses/lib/services/connectivity_service.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/services/connectivity_service.dart)
- `chefia_courses/lib/services/label_parser.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/services/label_parser.dart)
- `chefia_courses/lib/services/ocr_service.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/services/ocr_service.dart)
- `chefia_courses/lib/services/quality_estimator.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/services/quality_estimator.dart)
- `chefia_courses/lib/services/receipt_parser.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/services/receipt_parser.dart)
- `chefia_courses/lib/services/storage.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/services/storage.dart)
- `chefia_courses/lib/testing/assert_smart.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/testing/assert_smart.dart)
- `chefia_courses/lib/testing/fake_clock.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/testing/fake_clock.dart)
- `chefia_courses/lib/testing/selectors.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/testing/selectors.dart)
- `chefia_courses/lib/testing/tap_smart.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/testing/tap_smart.dart)
- `chefia_courses/lib/testing/test_reset.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/testing/test_reset.dart)
- `chefia_courses/lib/ui/screens/compare_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/ui/screens/compare_screen.dart)
- `chefia_courses/lib/ui/screens/lists_overview_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/ui/screens/lists_overview_screen.dart)
- `chefia_courses/lib/ui/screens/settings_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/ui/screens/settings_screen.dart)
- `chefia_courses/lib/ui/screens/shopping_split_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chefia_courses/lib/ui/screens/shopping_split_screen.dart)

---
## Fichiers

### chefia_courses/pubspec.yaml
```yaml
name: chefia_courses
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.8.1

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  hive: ^2.2.3
  hive_flutter: ^1.1.0
  path_provider: ^2.1.4
  flutter_riverpod: ^2.6.1
  shared_models:
    path: ../packages/shared_models
  go_router: ^16.2.0
  equatable: ^2.0.7
  intl: ^0.20.2
  connectivity_plus: ^6.1.5
  mobile_scanner: ^3.5.0
  url_launcher: ^6.3.1
  shared_preferences: ^2.3.2
  android_intent_plus: ^5.0.2
  speech_to_text: ^7.3.0
  http: ^1.1.0

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^6.0.0



# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package

```

### chefia_courses/android/app/src/debug/AndroidManifest.xml
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### chefia_courses/android/app/src/main/AndroidManifest.xml
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <application
        android:label="chefia_courses"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
        
        <!-- Receiver pour l'import du garde-manger depuis ChefIA Cuisine -->
        <receiver
            android:name=".pantry.PantryImportReceiver"
            android:exported="false">
            <intent-filter>
                <action android:name="com.chefia.courses.IMPORT_PANTRY" />
            </intent-filter>
        </receiver>
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

```

### chefia_courses/android/app/src/main/kotlin/com/example/chefia_courses/MainActivity.kt
```text
package com.example.chefia_courses

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()

```

### chefia_courses/android/app/src/main/kotlin/com/example/chefia_courses/pantry/PantryImportReceiver.kt
```text
package com.example.chefia_courses.pantry

import android.content.*
import android.util.Base64
import androidx.work.*
import java.util.concurrent.TimeUnit

class PantryImportReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        // On accepte soit "payload" (JSON plain) soit "payload_b64"
        val rawJson = intent.getStringExtra("payload")
            ?: intent.getStringExtra("payload_b64")?.let {
                String(Base64.decode(it, Base64.DEFAULT))
            }

        if (rawJson.isNullOrBlank()) return

        // On enfile le traitement dans WorkManager (robuste même si l'app est tuée)
        val data = Data.Builder().putString("payload", rawJson).build()
        val req = OneTimeWorkRequestBuilder<PantryImportWorker>()
            .setInputData(data)
            .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 10, TimeUnit.SECONDS)
            .build()
        WorkManager.getInstance(context).enqueue(req)
    }
}

```

### chefia_courses/android/app/src/main/kotlin/com/example/chefia_courses/pantry/PantryImportWorker.kt
```text
package com.example.chefia_courses.pantry

import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import org.json.JSONObject

class PantryImportWorker(appContext: Context, params: WorkerParameters) :
    CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result {
        val prefs = applicationContext.getSharedPreferences("chefia_courses", Context.MODE_PRIVATE)
        val payload = inputData.getString("payload") ?: return Result.failure()

        // Vérif JSON minimum (doit contenir "items":[])
        try {
            val obj = JSONObject(payload)
            if (!obj.has("items")) return Result.failure()
        } catch (e: Exception) {
            return Result.failure()
        }

        // On empile le payload dans une INBOX que Dart lira et consommera
        // Clé partagée avec Dart
        val key = "inbox_payloads_v1"
        val existing = prefs.getStringSet(key, mutableSetOf())?.toMutableSet() ?: mutableSetOf()
        existing.add(payload) // set -> évite doublons exacts
        prefs.edit().putStringSet(key, existing).apply()

        // Optionnel: on pourrait aussi afficher une notif locale ici

        return Result.success()
    }
}

```

### chefia_courses/android/app/src/main/res/drawable/launch_background.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### chefia_courses/android/app/src/main/res/drawable-v21/launch_background.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### chefia_courses/android/app/src/main/res/values/styles.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### chefia_courses/android/app/src/main/res/values-night/styles.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### chefia_courses/android/app/src/profile/AndroidManifest.xml
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### chefia_courses/lib/data/storage/hive_storage.dart
```dart
import 'package:hive_flutter/hive_flutter.dart';
import 'package:shared_models/shared_models.dart';
import '../../domain/models/pantry_item.dart';
import '../../domain/models/shopping_item.dart';
import 'storage_repository.dart';

class HiveStorage implements StorageRepository {
  static const _kPantry = 'pantry_box_v1';
  static const _kShopping = 'shopping_box_v1';

  @override
  Future<void> init() async {
    await Hive.initFlutter();
    // Pas d'adapters custom: on sérialise en Map<String,dynamic>
  }

  @override
  Future<List<PantryItem>> loadPantry() async {
    final box = await Hive.openBox(_kPantry);
    final list = (box.get('items') as List?) ?? [];
    return list.map((e) => _fromMapPantry(Map<String, dynamic>.from(e))).toList();
  }

  @override
  Future<void> savePantry(List<PantryItem> items) async {
    final box = await Hive.openBox(_kPantry);
    await box.put('items', items.map(_toMapPantry).toList());
  }

  @override
  Future<List<ShoppingItem>> loadShopping() async {
    final box = await Hive.openBox(_kShopping);
    final list = (box.get('items') as List?) ?? [];
    return list.map((e) => _fromMapShopping(Map<String, dynamic>.from(e))).toList();
  }

  @override
  Future<void> saveShopping(List<ShoppingItem> items) async {
    final box = await Hive.openBox(_kShopping);
    await box.put('items', items.map(_toMapShopping).toList());
  }

  // -- mapping --
  Map<String, dynamic> _toMapProduct(Product p) => {
    'id': p.id, 'name': p.name, 'brand': p.brand,
    'quantity': p.quantity, 'unit': p.unit, 'tags': p.tags,
  };
  Product _fromMapProduct(Map<String, dynamic> m) => Product(
    id: m['id'], name: m['name'], brand: m['brand'],
    quantity: (m['quantity'] as num?)?.toDouble(), unit: m['unit'], tags: List<String>.from(m['tags'] ?? []),
  );

  Map<String, dynamic> _toMapPantry(PantryItem i) => {
    'product': _toMapProduct(i.product),
    'expiry': i.expiry?.toIso8601String(),
    'allergens': i.allergens,
    'ingredients': i.ingredients,
    'stock': i.stock,
  };
  PantryItem _fromMapPantry(Map<String, dynamic> m) => PantryItem(
    product: _fromMapProduct(Map<String, dynamic>.from(m['product'])),
    expiry: m['expiry'] != null ? DateTime.parse(m['expiry']) : null,
    allergens: List<String>.from(m['allergens'] ?? []),
    ingredients: List<String>.from(m['ingredients'] ?? []),
    stock: m['stock'] ?? 1,
  );

  Map<String, dynamic> _toMapShopping(ShoppingItem i) => {
    'product': _toMapProduct(i.product),
    'quantity': i.quantity,
    'price': i.price,
    'checked': i.checked,
  };
  ShoppingItem _fromMapShopping(Map<String, dynamic> m) => ShoppingItem(
    product: _fromMapProduct(Map<String, dynamic>.from(m['product'])),
    quantity: m['quantity'] ?? 1,
    price: (m['price'] as num?)?.toDouble(),
    checked: m['checked'] ?? false,
  );
}













```

### chefia_courses/lib/data/storage/storage_repository.dart
```dart
import '../../domain/models/pantry_item.dart';
import '../../domain/models/shopping_item.dart';

abstract class StorageRepository {
  Future<void> init();
  Future<List<PantryItem>> loadPantry();
  Future<void> savePantry(List<PantryItem> items);

  Future<List<ShoppingItem>> loadShopping();
  Future<void> saveShopping(List<ShoppingItem> items);
}














```

### chefia_courses/lib/domain/models/pantry_item.dart
```dart
import 'package:shared_models/shared_models.dart';

class PantryItem {
  final Product product;
  final DateTime? expiry;
  final List<String> allergens;   // la version "Chef Cuisine"
  final List<String> ingredients; // si disponible
  final int stock;                // quantité en stock

  const PantryItem({
    required this.product,
    this.expiry,
    this.allergens = const [],
    this.ingredients = const [],
    this.stock = 1,
  });
}


```

### chefia_courses/lib/domain/models/product.dart
```dart
class Product {
  final String id;           // code-barres ou UUID
  final String name;
  final String? brand;
  final double? quantity;    // ex. 1.0
  final String? unit;        // ex. "L", "g", "pcs"
  final List<String> tags;   // catégories, labels (bio, sans gluten...)

  const Product({
    required this.id,
    required this.name,
    this.brand,
    this.quantity,
    this.unit,
    this.tags = const [],
  });
}


```

### chefia_courses/lib/domain/models/shopping_item.dart
```dart
import 'package:shared_models/shared_models.dart';

class ShoppingItem {
  final Product product;
  final int quantity;         // quantité à acheter
  final double? price;        // dernier prix observé
  final bool checked;         // coché dans la liste ?

  const ShoppingItem({
    required this.product,
    this.quantity = 1,
    this.price,
    this.checked = false,
  });

  ShoppingItem copyWith({int? quantity, double? price, bool? checked}) {
    return ShoppingItem(
      product: product,
      quantity: quantity ?? this.quantity,
      price: price ?? this.price,
      checked: checked ?? this.checked,
    );
  }
}


```

### chefia_courses/lib/features/examples/storage_examples.dart
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:chefia_courses/providers.dart';
import 'package:chefia_courses/data/storage/storage_repository.dart';
import 'package:chefia_courses/domain/models/shopping_item.dart';
import 'package:shared_models/shared_models.dart';
import 'package:chefia_courses/domain/models/pantry_item.dart';

// Provider pour charger la liste de courses (identique dans les deux apps)
final shoppingProvider = FutureProvider<StorageRepository>((ref) async {
  final storage = ref.read(storageProvider);
  return storage;
});

// Exemple d'usage : cocher un item
Future<void> toggleItem(WidgetRef ref, ShoppingItem item) async {
  final storage = ref.read(storageProvider);
  final list = await storage.loadShopping();
  final idx = list.indexWhere((i) => i.product.id == item.product.id);
  final updated = [...list];
  updated[idx] = item.copyWith(checked: !item.checked);
  await storage.saveShopping(updated);
}

// Exemple d'usage : ajouter un produit au garde-manger
Future<void> addToPantry(WidgetRef ref, Product product) async {
  final storage = ref.read(storageProvider);
  final pantry = await storage.loadPantry();
  final newItem = PantryItem(product: product, stock: 1);
  pantry.add(newItem);
  await storage.savePantry(pantry);
}

```

### chefia_courses/lib/features/lists/data/shopping_repository.dart
```dart
import 'package:chefia_courses/services/storage.dart';
import '../domain/shopping_list.dart';

class ShoppingRepository {
  static const String _listsKey = 'shopping_lists';

  /// Récupère toutes les listes de courses
  static List<ShoppingList> getAllLists() {
    final listsData = Storage.cart.get(_listsKey, defaultValue: <Map<String, dynamic>>[]) as List;
    return listsData
        .whereType<Map<String, dynamic>>()
        .map((data) => ShoppingList.fromMap(data))
        .toList();
  }

  /// Crée une nouvelle liste de courses
  static Future<void> createList(ShoppingList list) async {
    final lists = getAllLists();
    lists.add(list);
    
    final listsData = lists.map((l) => l.toMap()).toList();
    await Storage.cart.put(_listsKey, listsData);
  }

  /// Met à jour une liste existante
  static Future<void> updateList(ShoppingList list) async {
    final lists = getAllLists();
    final index = lists.indexWhere((l) => l.id == list.id);
    
    if (index != -1) {
      lists[index] = list;
      final listsData = lists.map((l) => l.toMap()).toList();
      await Storage.cart.put(_listsKey, listsData);
    }
  }

  /// Supprime une liste
  static Future<void> deleteList(String listId) async {
    final lists = getAllLists();
    lists.removeWhere((l) => l.id == listId);
    
    final listsData = lists.map((l) => l.toMap()).toList();
    await Storage.cart.put(_listsKey, listsData);
  }

  /// Récupère une liste par son ID
  static ShoppingList? getListById(String listId) {
    final lists = getAllLists();
    try {
      return lists.firstWhere((l) => l.id == listId);
    } catch (e) {
      return null;
    }
  }

  /// Ajoute un item à une liste
  static Future<void> addItemToList(String listId, ShoppingItem item) async {
    final list = getListById(listId);
    if (list != null) {
      final updatedItems = List<ShoppingItem>.from(list.items)..add(item);
      final updatedList = ShoppingList(
        id: list.id,
        name: list.name,
        store: list.store,
        createdAt: list.createdAt,
        items: updatedItems,
      );
      await updateList(updatedList);
    }
  }

  /// Met à jour le statut d'un item
  static Future<void> toggleItemStatus(String listId, String itemId) async {
    final list = getListById(listId);
    if (list != null) {
      final updatedItems = list.items.map((item) {
        if (item.id == itemId) {
          return ShoppingItem(
            id: item.id,
            name: item.name,
            quantity: item.quantity,
            unit: item.unit,
            isCompleted: !item.isCompleted,
            category: item.category,
          );
        }
        return item;
      }).toList();

      final updatedList = ShoppingList(
        id: list.id,
        name: list.name,
        store: list.store,
        createdAt: list.createdAt,
        items: updatedItems,
      );
      await updateList(updatedList);
    }
  }
}


```

### chefia_courses/lib/features/lists/domain/shopping_list.dart
```dart
class ShoppingList {
  final String id;
  final String name;
  final String store;
  final DateTime createdAt;
  final List<ShoppingItem> items;

  ShoppingList({
    required this.id,
    required this.name,
    required this.store,
    required this.createdAt,
    required this.items,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'store': store,
      'createdAt': createdAt.toIso8601String(),
      'items': items.map((item) => item.toMap()).toList(),
    };
  }

  factory ShoppingList.fromMap(Map<String, dynamic> map) {
    return ShoppingList(
      id: map['id'] as String,
      name: map['name'] as String,
      store: map['store'] as String,
      createdAt: DateTime.parse(map['createdAt'] as String),
      items: (map['items'] as List)
          .map((item) => ShoppingItem.fromMap(item as Map<String, dynamic>))
          .toList(),
    );
  }
}

class ShoppingItem {
  final String id;
  final String name;
  final int quantity;
  final String? unit;
  final bool isCompleted;
  final String? category;

  ShoppingItem({
    required this.id,
    required this.name,
    required this.quantity,
    this.unit,
    this.isCompleted = false,
    this.category,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'quantity': quantity,
      'unit': unit,
      'isCompleted': isCompleted,
      'category': category,
    };
  }

  factory ShoppingItem.fromMap(Map<String, dynamic> map) {
    return ShoppingItem(
      id: map['id'] as String,
      name: map['name'] as String,
      quantity: map['quantity'] as int,
      unit: map['unit'] as String?,
      isCompleted: map['isCompleted'] as bool? ?? false,
      category: map['category'] as String?,
    );
  }
}


```

### chefia_courses/lib/features/lists/ui/home_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:chefia_courses/features/lists/data/shopping_repository.dart';
import 'package:chefia_courses/features/lists/domain/shopping_list.dart';
// import '../../sync/ui/connectivity_status_widget.dart'; // Supprimé car dossier sync supprimé

final listsProvider = FutureProvider<List<ShoppingList>>((ref) async {
  return ShoppingRepository.getAllLists();
});

class HomeScreen extends ConsumerWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final asyncLists = ref.watch(listsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('ChefIA Courses'),
        actions: const [
          // Padding(
          //   padding: EdgeInsets.only(right: 16),
          //   child: ConnectivityStatusWidget(), // Supprimé car dossier sync supprimé
          // ),
        ],
      ),
      body: Column(
        children: [
          Expanded(
            child: asyncLists.when(
              data: (lists) {
                if (lists.isEmpty) {
                  return Center(
                    child: FilledButton(
                      onPressed: () async {
                        // Créer une nouvelle liste
                        final newList = ShoppingList(
                          id: DateTime.now().millisecondsSinceEpoch.toString(),
                          name: 'Nouvelle liste',
                          store: 'Magasin',
                          createdAt: DateTime.now(),
                          items: [],
                        );
                        await ShoppingRepository.createList(newList);
                        ref.invalidate(listsProvider);
                      },
                      child: const Text('Créer une liste'),
                    ),
                  );
                }
                return ListView.separated(
                  itemCount: lists.length,
                  separatorBuilder: (_, __) => const Divider(height: 1),
                  itemBuilder: (context, i) {
                    final l = lists[i];
                    return ListTile(
                      title: Text(l.name),
                      subtitle: Text(l.store),
                      trailing: const Icon(Icons.chevron_right),
                      onTap: () => context.push('/list/${l.id}'),
                    );
                  },
                );
              },
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (e, _) => Center(child: Text('Erreur: $e')),
            ),
          ),
          // Boutons rapides (dev)
          Padding(
            padding: const EdgeInsets.all(12),
            child: Wrap(
              spacing: 8,
              children: [
                OutlinedButton.icon(
                  onPressed: () => context.push('/receipt/1'),
                  icon: const Icon(Icons.receipt_long),
                  label: const Text('Revoir un ticket'),
                ),
                OutlinedButton.icon(
                  onPressed: () => context.push('/product/1'),
                  icon: const Icon(Icons.fact_check),
                  label: const Text('Vérifier un produit'),
                ),
                OutlinedButton.icon(
                  onPressed: () => context.push('/courses'),
                  icon: const Icon(Icons.shopping_cart_checkout_rounded),
                  label: const Text('Courses'),
                ),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () async {
          // Créer une nouvelle liste
          final newList = ShoppingList(
            id: DateTime.now().millisecondsSinceEpoch.toString(),
            name: 'Nouvelle liste',
            store: 'Magasin',
            createdAt: DateTime.now(),
            items: [],
          );
          await ShoppingRepository.createList(newList);
          ref.invalidate(listsProvider);
        },
        label: const Text('Nouvelle liste'),
        icon: const Icon(Icons.add),
      ),
    );
  }
}

```

### chefia_courses/lib/features/lists/ui/list_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:chefia_courses/features/lists/domain/shopping_list.dart';
import 'package:chefia_courses/features/lists/data/shopping_repository.dart';
import 'package:chefia_courses/services/chefia_cuisine_service.dart';

final listItemsProvider = FutureProvider.family<ShoppingList?, String>((ref, listId) {
  return Future.value(ShoppingRepository.getListById(listId));
});

class ListScreen extends ConsumerStatefulWidget {
  const ListScreen({super.key, required this.listId});
  final String listId;

  @override
  ConsumerState<ListScreen> createState() => _ListScreenState();
}

class _ListScreenState extends ConsumerState<ListScreen> {
  final _ctrl = TextEditingController();

  @override
  Widget build(BuildContext context) {
    final asyncList = ref.watch(listItemsProvider(widget.listId));

    return Scaffold(
      appBar: AppBar(
        title: const Text('Liste'),
        actions: [
          // Bouton pour envoyer vers ChefIA Cuisine
          IconButton(
            onPressed: () async {
              final list = await ShoppingRepository.getListById(widget.listId);
              if (list != null) {
                try {
                  await ChefiaCuisineService.sendToChefiaCuisine(list);
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('✅ ${list.items.length} articles envoyés vers ChefIA Cuisine'),
                        action: SnackBarAction(
                          label: 'Ouvrir Cuisine',
                          onPressed: () => ChefiaCuisineService.openChefiaCuisine(),
                        ),
                      ),
                    );
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('❌ Erreur: $e'),
                        backgroundColor: Colors.red,
                      ),
                    );
                  }
                }
              }
            },
            icon: const Icon(Icons.send_to_mobile),
            tooltip: 'Envoyer vers Garde-manger',
          ),
          // Bouton pour envoyer seulement les articles cochés
          IconButton(
            onPressed: () async {
              final list = await ShoppingRepository.getListById(widget.listId);
              if (list != null) {
                try {
                  await ChefiaCuisineService.sendCompletedItemsToChefiaCuisine(list);
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('✅ Articles cochés envoyés vers ChefIA Cuisine'),
                        action: SnackBarAction(
                          label: 'Ouvrir Cuisine',
                          onPressed: () => ChefiaCuisineService.openChefiaCuisine(),
                        ),
                      ),
                    );
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('❌ Erreur: $e'),
                        backgroundColor: Colors.red,
                      ),
                    );
                  }
                }
              }
            },
            icon: const Icon(Icons.check_circle_outline),
            tooltip: 'Envoyer articles cochés',
          ),
        ],
      ),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
            child: Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: _ctrl,
                    decoration: const InputDecoration(
                      hintText: 'Ajouter un article (ex: 2 L lait)',
                      border: OutlineInputBorder(),
                      isDense: true,
                    ),
                    onSubmitted: (v) async {
                      if (v.trim().isEmpty) return;
                      final item = ShoppingItem(
                        id: DateTime.now().millisecondsSinceEpoch.toString(),
                        name: v.trim(),
                        quantity: 1,
                      );
                      await ShoppingRepository.addItemToList(widget.listId, item);
                      _ctrl.clear();
                      ref.invalidate(listItemsProvider(widget.listId));
                    },
                  ),
                ),
                const SizedBox(width: 8),
                FilledButton.icon(
                  onPressed: () async {
                    final v = _ctrl.text.trim();
                    if (v.isEmpty) return;
                    final item = ShoppingItem(
                      id: DateTime.now().millisecondsSinceEpoch.toString(),
                      name: v,
                      quantity: 1,
                    );
                    await ShoppingRepository.addItemToList(widget.listId, item);
                    _ctrl.clear();
                    ref.invalidate(listItemsProvider(widget.listId));
                  },
                  icon: const Icon(Icons.add),
                  label: const Text('Ajouter'),
                )
              ],
            ),
          ),
          const Divider(height: 1),
          Expanded(
            child: asyncList.when(
              data: (list) {
                if (list == null) {
                  return const Center(child: Text('Liste non trouvée'));
                }
                return ListView.separated(
                  itemCount: list.items.length,
                  separatorBuilder: (_, __) => const Divider(height: 1),
                  itemBuilder: (context, i) {
                    final item = list.items[i];
                    return ListTile(
                      leading: Checkbox(
                        value: item.isCompleted,
                        onChanged: (_) async {
                          await ShoppingRepository.toggleItemStatus(list.id, item.id);
                          ref.invalidate(listItemsProvider(widget.listId));
                        },
                      ),
                      title: Text(item.name),
                      subtitle: Text('${item.quantity} ${item.unit ?? 'unité'} • ${item.category ?? 'Général'}'),
                    );
                  },
                );
              },
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (e, _) => Center(child: Text('Erreur: $e')),
            ),
          ),
        ],
      ),
      // Bouton flottant pour envoyer vers ChefIA Cuisine
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () async {
          final list = await ShoppingRepository.getListById(widget.listId);
          if (list != null) {
            try {
              await ChefiaCuisineService.sendToChefiaCuisine(list);
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('✅ ${list.items.length} articles envoyés vers ChefIA Cuisine'),
                    action: SnackBarAction(
                      label: 'Ouvrir Cuisine',
                      onPressed: () => ChefiaCuisineService.openChefiaCuisine(),
                    ),
                  ),
                );
              }
            } catch (e) {
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('❌ Erreur: $e'),
                    backgroundColor: Colors.red,
                  ),
                );
              }
            }
          }
        },
        icon: const Icon(Icons.send_to_mobile),
        label: const Text('Vers Garde-manger'),
        backgroundColor: Colors.green,
      ),
    );
  }
}

```

### chefia_courses/lib/features/personalization/user_lexicon.dart
```dart
import 'dart:convert';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

class LexEntry {
  final String alias;       // ex. "pq"
  final String canonical;   // ex. "Papier toilette"
  final String? unit;       // ex. "x12" ou "1 L"
  final String category;    // ex. "Hygiène"
  final int defaultQty;     // ex. 1 ou 6
  final int uses;           // compteur d'usage

  const LexEntry({
    required this.alias,
    required this.canonical,
    this.unit,
    this.category = 'Divers',
    this.defaultQty = 1,
    this.uses = 0,
  });

  LexEntry copyWith({String? canonical, String? unit, String? category, int? defaultQty, int? uses}) =>
      LexEntry(
        alias: alias,
        canonical: canonical ?? this.canonical,
        unit: unit ?? this.unit,
        category: category ?? this.category,
        defaultQty: defaultQty ?? this.defaultQty,
        uses: uses ?? this.uses,
      );

  Map<String, dynamic> toJson() => {
    'alias': alias, 'canonical': canonical, 'unit': unit,
    'category': category, 'defaultQty': defaultQty, 'uses': uses,
  };
  factory LexEntry.fromJson(Map<String,dynamic> j) => LexEntry(
    alias: j['alias'], canonical: j['canonical'],
    unit: j['unit'], category: j['category'] ?? 'Divers',
    defaultQty: (j['defaultQty'] as num?)?.toInt() ?? 1,
    uses: (j['uses'] as num?)?.toInt() ?? 0,
  );
}

final userLexiconProvider = StateNotifierProvider<UserLexicon, Map<String, LexEntry>>((ref) {
  return UserLexicon({});
});

class UserLexicon extends StateNotifier<Map<String, LexEntry>> {
  UserLexicon(super.state);

  static const _kKey = 'user_lexicon_v1';

  Future<void> load() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_kKey);
    if (raw == null || raw.isEmpty) return;
    final list = (jsonDecode(raw) as List).cast<Map<String,dynamic>>();
    state = { for (final m in list) m['alias'] as String : LexEntry.fromJson(m) };
  }

  Future<void> _persist() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_kKey, jsonEncode(state.values.map((e)=>e.toJson()).toList()));
  }

  void upsert(LexEntry e) {
    final current = state[e.alias];
    final next = current == null ? e : current.copyWith(
      canonical: e.canonical, unit: e.unit, category: e.category, defaultQty: e.defaultQty,
    );
    state = {...state, e.alias: next};
    _persist();
  }

  void bumpUse(String alias) {
    final e = state[alias];
    if (e == null) return;
    state = {...state, alias: e.copyWith(uses: e.uses + 1)};
    _persist();
  }
}





```

### chefia_courses/lib/features/products/ui/product_check_screen.dart
```dart
import 'package:flutter/material.dart';
// import '../../sync/app/enrichment_service.dart'; // Supprimé car dossier sync supprimé

class ProductCheckScreen extends StatelessWidget {
  const ProductCheckScreen({super.key, required this.productId});
  final int productId;

  @override
  Widget build(BuildContext context) {
    // TODO: charger ProductProfile
    return Scaffold(
      appBar: AppBar(title: const Text('Vérifier le produit')),
      body: ListView(
        padding: const EdgeInsets.all(12),
        children: const [
          ListTile(title: Text('Nom produit'), subtitle: Text('Marque')),
          Divider(),
          ListTile(title: Text('Ingrédients'), subtitle: Text('…')),
          ListTile(title: Text('Allergènes'), subtitle: Text('gluten, lait')),
          Divider(),
          ListTile(title: Text('DLC/DDM'), subtitle: Text('01/09/2025')),
          ListTile(title: Text('Lot'), subtitle: Text('L1234')),
          Divider(),
          ListTile(title: Text('Qualité'), subtitle: Text('Sucre présent • Sirop de glucose')),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () async {
          // TODO: Implémenter l'analyse IA quand le service sera disponible
          if (context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Analyse IA - à implémenter'),
                backgroundColor: Colors.blue,
              ),
            );
          }
        },
        icon: const Icon(Icons.auto_awesome),
        label: const Text('Analyser avec IA'),
      ),
    );
  }
}

```

### chefia_courses/lib/features/shopping/barcode_scan_sheet.dart
```dart
import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'models.dart';

typedef BarcodeResult = ShoppingItem?;

Future<BarcodeResult> showBarcodeScanSheet(BuildContext context) async {
  return showModalBottomSheet<ShoppingItem>(
    context: context,
    isScrollControlled: true,
    showDragHandle: true,
    builder: (ctx) {
      return _BarcodeScannerView();
    },
  );
}

class _BarcodeScannerView extends StatefulWidget {
  @override
  State<_BarcodeScannerView> createState() => _BarcodeScannerViewState();
}

class _BarcodeScannerViewState extends State<_BarcodeScannerView> {
  bool _done = false;

  // mapping local minimal => à enrichir plus tard (JSON local / API)
  ShoppingItem? _mapBarcode(String code) {
    switch (code) {
      case '3274080005003': // EXEMPLE: sucre Saint Louis 1kg
        return const ShoppingItem(id: 'ean-3274080005003', name: 'Sucre', unit: '1 kg', category: 'Épicerie');
      case '3033491400010': // EXEMPLE: lait 1L
        return const ShoppingItem(id: 'ean-3033491400010', name: 'Lait demi-écrémé', unit: '1 L', category: 'Frais');
      default:
        return null; // inconnu → fallback manuel dans l'écran appelant
    }
  }

  @override
  Widget build(BuildContext context) {
    final overlay = Container(
      decoration: BoxDecoration(
        border: Border.all(color: Theme.of(context).colorScheme.primary, width: 2),
        borderRadius: BorderRadius.circular(12),
      ),
      width: 260, height: 160,
    );

    return SafeArea(
      child: Stack(
        alignment: Alignment.center,
        children: [
          MobileScanner(
            controller: MobileScannerController(
              detectionSpeed: DetectionSpeed.normal,
              facing: CameraFacing.back,
              formats: [BarcodeFormat.ean13, BarcodeFormat.ean8, BarcodeFormat.upcA, BarcodeFormat.upcE],
            ),
            onDetect: (capture) {
              if (_done) return;
              final raw = capture.barcodes.first.rawValue;
              if (raw == null) return;
              _done = true;
              final item = _mapBarcode(raw);
              Navigator.pop(context, item);
            },
          ),
          overlay,
          Positioned(
            top: 12,
            child: Text('Cadrez le code‑barres', style: Theme.of(context).textTheme.bodyMedium),
          ),
          Positioned(
            bottom: 16,
            child: FilledButton.icon(
              onPressed: () => Navigator.pop(context, null),
              icon: const Icon(Icons.close),
              label: const Text('Annuler'),
            ),
          ),
        ],
      ),
    );
  }
}

```

### chefia_courses/lib/features/shopping/catalog.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'models.dart';
import 'providers.dart';

final productsCatalogProvider = StateProvider<List<ShoppingItem>>((ref) {
  return const [
    ShoppingItem(id: 'milk-1l', name: 'Lait demi-écrémé', unit: '1 L', category: 'Frais'),
    ShoppingItem(id: 'butter-250g', name: 'Beurre doux', unit: '250 g', category: 'Frais'),
    ShoppingItem(id: 'eggs-12', name: 'Œufs x12', unit: '12', category: 'Frais'),
    ShoppingItem(id: 'flour-1kg', name: 'Farine T45', unit: '1 kg', category: 'Épicerie'),
    ShoppingItem(id: 'sugar-1kg', name: 'Sucre', unit: '1 kg', category: 'Épicerie'),
    ShoppingItem(id: 'pasta-500g', name: 'Pâtes', unit: '500 g', category: 'Épicerie'),
    ShoppingItem(id: 'rice-1kg', name: 'Riz', unit: '1 kg', category: 'Épicerie'),
    ShoppingItem(id: 'oil-1l', name: 'Huile de tournesol', unit: '1 L', category: 'Épicerie'),
    ShoppingItem(id: 'apple-1kg', name: 'Pommes', unit: '1 kg', category: 'Fruits & Légumes'),
  ];
});

Future<void> showProductsCatalogBottomSheet(
  BuildContext context,
  WidgetRef ref, {
  required bool targetIsBasket, // true = ajouter au panier, false = ajouter à la liste
}) async {
  final theme = Theme.of(context);
  final TextEditingController searchCtrl = TextEditingController();
  final favorites = <String>{}; // simple mem en RAM pour V1

  await showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    showDragHandle: true,
    builder: (ctx) {
      return StatefulBuilder(builder: (ctx, setState) {
        final all = ref.read(productsCatalogProvider);
        final q = searchCtrl.text.trim().toLowerCase();
        final list = q.isEmpty
            ? all
            : all.where((e) =>
                e.name.toLowerCase().contains(q) ||
                (e.category.toLowerCase().contains(q)) ||
                (e.unit?.toLowerCase().contains(q) ?? false)).toList();

        void add(ShoppingItem base) {
          // clone pour marquer la source
          final item = base.copyWith(
            isFromMain: !targetIsBasket,
            isFromRecipe: false,
          );
          if (targetIsBasket) {
            ref.read(basketProvider.notifier).add(item);
            final set = {...ref.read(checkedProvider)}..add(item.id);
            ref.read(checkedProvider.notifier).state = set;
          } else {
            // Ajouter à la liste prévue
            ref.read(plannedListProvider.notifier).add(item);
          }
          Navigator.pop(ctx);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('"${item.name}" ajouté ${targetIsBasket ? "au panier" : "à la liste"}')),
          );
        }

        return SafeArea(
          child: Padding(
            padding: EdgeInsets.only(
              bottom: MediaQuery.of(ctx).viewInsets.bottom,
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
                  child: TextField(
                    controller: searchCtrl,
                    onChanged: (_) => setState(() {}),
                    decoration: const InputDecoration(
                      prefixIcon: Icon(Icons.search),
                      hintText: 'Rechercher un produit…',
                    ),
                    autofocus: true,
                  ),
                ),
                Expanded(
                  child: ListView.separated(
                    itemCount: list.length,
                    separatorBuilder: (_, __) => const Divider(height: 1),
                    itemBuilder: (ctx, i) {
                      final p = list[i];
                      final fav = favorites.contains(p.id);
                      return ListTile(
                        title: Text(p.name),
                        subtitle: Text([p.unit, p.category].whereType<String>().join(' • ')),
                        leading: IconButton(
                          icon: Icon(fav ? Icons.favorite : Icons.favorite_border,
                              color: fav ? theme.colorScheme.primary : null),
                          onPressed: () {
                            setState(() {
                              if (fav) {
                                favorites.remove(p.id);
                              } else {
                                favorites.add(p.id);
                              }
                            });
                          },
                          tooltip: fav ? 'Retirer des favoris' : 'Ajouter aux favoris',
                        ),
                        trailing: FilledButton(
                          onPressed: () => add(p),
                          child: Text(targetIsBasket ? 'Panier' : 'Liste'),
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
        );
      });
    },
  );
}

```

### chefia_courses/lib/features/shopping/models.dart
```dart
class ShoppingItem {
  final String id;           // ex: barcode ou uuid
  final String name;
  final String? brand;
  final String? unit;        // ex: "500 g", "1 L"
  final String category;     // ex: "Frais", "Épicerie"
  final bool isFromRecipe;   // true = liste Recette
  final bool isFromMain;     // true = liste Principale
  final double? unitPrice;   // si connu via ticket historique

  const ShoppingItem({
    required this.id,
    required this.name,
    this.brand,
    this.unit,
    required this.category,
    this.isFromRecipe = false,
    this.isFromMain = true,
    this.unitPrice,
  });

  ShoppingItem copyWith({
    String? id,
    String? name,
    String? brand,
    String? unit,
    String? category,
    bool? isFromRecipe,
    bool? isFromMain,
    double? unitPrice,
  }) {
    return ShoppingItem(
      id: id ?? this.id,
      name: name ?? this.name,
      brand: brand ?? this.brand,
      unit: unit ?? this.unit,
      category: category ?? this.category,
      isFromRecipe: isFromRecipe ?? this.isFromRecipe,
      isFromMain: isFromMain ?? this.isFromMain,
      unitPrice: unitPrice ?? this.unitPrice,
    );
  }

  // --- JSON helpers ---
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'brand': brand,
    'unit': unit,
    'category': category,
    'isFromRecipe': isFromRecipe,
    'isFromMain': isFromMain,
    'unitPrice': unitPrice,
  };

  factory ShoppingItem.fromJson(Map<String, dynamic> j) => ShoppingItem(
    id: j['id'] as String,
    name: j['name'] as String,
    brand: j['brand'] as String?,
    unit: j['unit'] as String?,
    category: j['category'] as String? ?? 'Divers',
    isFromRecipe: j['isFromRecipe'] as bool? ?? false,
    isFromMain: j['isFromMain'] as bool? ?? false,
    unitPrice: (j['unitPrice'] as num?)?.toDouble(),
  );
}

class BasketLine {
  final ShoppingItem item;
  final int qty;

  const BasketLine({required this.item, this.qty = 1});

  BasketLine copyWith({ShoppingItem? item, int? qty}) =>
      BasketLine(item: item ?? this.item, qty: qty ?? this.qty);

  double? get lineTotal =>
      (item.unitPrice != null) ? (item.unitPrice! * qty) : null;

  // --- JSON helpers ---
  Map<String, dynamic> toJson() => {
    'item': item.toJson(),
    'qty': qty,
  };

  factory BasketLine.fromJson(Map<String, dynamic> j) => BasketLine(
    item: ShoppingItem.fromJson(j['item'] as Map<String, dynamic>),
    qty: (j['qty'] as num?)?.toInt() ?? 1,
  );
}

enum ListFilter { all, mainOnly, recipesOnly, specialsOnly }

```

### chefia_courses/lib/features/shopping/providers.dart
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'models.dart';

// MOCK: liste prévue (à gauche)
final plannedListProvider =
    StateNotifierProvider<PlannedListNotifier, List<ShoppingItem>>((ref) {
  return PlannedListNotifier([
    ShoppingItem(
      id: 'milk-1L',
      name: 'Lait demi-écrémé',
      category: 'Frais',
      unit: '1 L',
      isFromMain: true,
    ),
    ShoppingItem(
      id: 'apple-1kg',
      name: 'Pommes',
      category: 'Fruits & Légumes',
      unit: '1 kg',
      isFromRecipe: true,
      isFromMain: false,
    ),
    ShoppingItem(
      id: 'sugar-1kg',
      name: 'Sucre',
      category: 'Épicerie',
      unit: '1 kg',
      isFromMain: true,
    ),
  ]);
});

class PlannedListNotifier extends StateNotifier<List<ShoppingItem>> {
  PlannedListNotifier(super.state);

  Future<void> _persist() =>
      _saveList(_kPlannedKey, state.map((e) => e.toJson()).toList());

  @override
  set state(List<ShoppingItem> value) {
    super.state = value;
    _persist();
  }

  void toggleSource(String id, {bool? fromMain, bool? fromRecipe}) {
    state = state
        .map((e) => e.id == id
            ? e.copyWith(
                isFromMain: fromMain ?? e.isFromMain,
                isFromRecipe: fromRecipe ?? e.isFromRecipe,
              )
            : e)
        .toList();
  }

  void add(ShoppingItem item) {
    state = [...state, item];
  }

  // Méthode pour l'initialisation sans persistance
  void initialize(List<ShoppingItem> items) {
    super.state = items;
  }
}

// Panier réel (à droite)
final basketProvider =
    StateNotifierProvider<BasketNotifier, List<BasketLine>>((ref) {
  return BasketNotifier([]);
});

class BasketNotifier extends StateNotifier<List<BasketLine>> {
  BasketNotifier(super.state);

  Future<void> _persist() =>
      _saveList(_kBasketKey, state.map((e) => e.toJson()).toList());

  void add(ShoppingItem item) {
    final idx = state.indexWhere((b) => b.item.id == item.id);
    if (idx == -1) {
      state = [...state, BasketLine(item: item, qty: 1)];
    } else {
      final current = state[idx];
      state = [
        ...state.sublist(0, idx),
        current.copyWith(qty: current.qty + 1),
        ...state.sublist(idx + 1),
      ];
    }
    _persist();
  }

  void removeOne(String itemId) {
    final idx = state.indexWhere((b) => b.item.id == itemId);
    if (idx == -1) return;
    final current = state[idx];
    if (current.qty > 1) {
      state = [
        ...state.sublist(0, idx),
        current.copyWith(qty: current.qty - 1),
        ...state.sublist(idx + 1),
      ];
    } else {
      final newState = [...state];
      newState.removeAt(idx);
      state = newState;
    }
    _persist();
  }

  void clear() {
    state = [];
    _persist();
  }

  // Méthode pour l'initialisation sans persistance
  void initialize(List<BasketLine> items) {
    super.state = items;
  }
}

// ----- Ticket (contenu du ticket de caisse saisi/importé) -----
final ticketProvider =
    StateNotifierProvider<TicketNotifier, List<BasketLine>>((ref) {
  return TicketNotifier([]);
});

class TicketNotifier extends StateNotifier<List<BasketLine>> {
  TicketNotifier(super.state);

  Future<void> _persist() =>
      _saveList(_kTicketKey, state.map((e) => e.toJson()).toList());

  void add(ShoppingItem item, {int qty = 1, double? unitPrice}) {
    final idx = state.indexWhere((b) => b.item.id == item.id);
    final updatedItem = item.copyWith(unitPrice: unitPrice ?? item.unitPrice);
    if (idx == -1) {
      state = [...state, BasketLine(item: updatedItem, qty: qty)];
    } else {
      final current = state[idx];
      state = [
        ...state.sublist(0, idx),
        current.copyWith(
          item: updatedItem,
          qty: current.qty + qty,
        ),
        ...state.sublist(idx + 1),
      ];
    }
    _persist();
  }

  void setLines(List<BasketLine> lines) {
    state = lines;
    _persist();
  }

  void removeOne(String itemId) {
    final idx = state.indexWhere((b) => b.item.id == itemId);
    if (idx == -1) return;
    final current = state[idx];
    if (current.qty > 1) {
      state = [
        ...state.sublist(0, idx),
        current.copyWith(qty: current.qty - 1),
        ...state.sublist(idx + 1),
      ];
    } else {
      final newState = [...state];
      newState.removeAt(idx);
      state = newState;
    }
    _persist();
  }

  void clear() {
    state = [];
    _persist();
  }
}

// Filtre d'affichage (chips du haut)
final listFilterProvider = StateProvider<ListFilter>((ref) => ListFilter.all);

// Sélection produit cochée (à gauche)
final checkedProvider = StateProvider<Set<String>>((ref) => <String>{});

// Total estimé
final estimatedTotalProvider = Provider<double?>((ref) {
  final basket = ref.watch(basketProvider);
  double total = 0;
  bool hasAny = false;
  for (final line in basket) {
    if (line.lineTotal != null) {
      total += line.lineTotal!;
      hasAny = true;
    }
  }
  return hasAny ? total : null;
});

// ----- Persistance SharedPreferences -----

const _kPlannedKey = 'courses_planned_v1';
const _kBasketKey  = 'courses_basket_v1';
const _kTicketKey  = 'courses_ticket_v1';
const _kInboxKey = 'inbox_payloads_v1';

Future<void> _saveList(String key, List<Map<String, dynamic>> data) async {
  final prefs = await SharedPreferences.getInstance();
  await prefs.setString(key, jsonEncode(data));
}

Future<List<Map<String, dynamic>>> _loadList(String key) async {
  final prefs = await SharedPreferences.getInstance();
  final raw = prefs.getString(key);
  if (raw == null || raw.isEmpty) return [];
  final decoded = jsonDecode(raw);
  if (decoded is List) {
    return decoded.cast<Map<String, dynamic>>();
  }
  return [];
}

// ----- Helper d'import depuis l'INBOX Android -----

Future<int> importPantryInboxIntoBasket() async {
  final prefs = await SharedPreferences.getInstance();
  final set = prefs.getStringList(_kInboxKey) ?? [];
  if (set.isEmpty) return 0;

  // On retourne juste le nombre d'articles à importer
  // L'import réel se fera via un provider dédié
  int totalItems = 0;
  for (final raw in set) {
    try {
      final map = jsonDecode(raw) as Map<String, dynamic>;
      final items = (map['items'] as List).cast<Map<String, dynamic>>();
      for (final it in items) {
        final qty = (it['qty'] as num?)?.toInt() ?? 1;
        totalItems += qty;
      }
    } catch (_) {
      // ignore / log si besoin
    }
  }

  return totalItems;
}

// ----- Provider pour l'import depuis l'INBOX -----

// TODO: Implémenter l'import INBOX quand le système de sync sera prêt
// final pantryImportProvider = FutureProvider<int>((ref) async {
//   // Code à implémenter
//   return 0;
// });

// ----- Provider d'initialisation de la persistance -----

final persistenceInitProvider = FutureProvider<void>((ref) async {
  // planned
  final plannedRaw = await _loadList(_kPlannedKey);
  if (plannedRaw.isNotEmpty) {
    final plannedItems = plannedRaw.map((m) => ShoppingItem.fromJson(m)).toList();
    ref.read(plannedListProvider.notifier).initialize(plannedItems);
  }
  // basket
  final basketRaw = await _loadList(_kBasketKey);
  if (basketRaw.isNotEmpty) {
    final basketLines = basketRaw.map((m) => BasketLine.fromJson(m)).toList();
    ref.read(basketProvider.notifier).initialize(basketLines);
  }
  // ticket
  final ticketRaw = await _loadList(_kTicketKey);
  if (ticketRaw.isNotEmpty) {
    final ticketLines = ticketRaw.map((m) => BasketLine.fromJson(m)).toList();
    ref.read(ticketProvider.notifier).setLines(ticketLines);
  }
  
  // TODO: Consommer l'INBOX potentielle poussée par Android
  // await ref.read(pantryImportProvider.future);
});

```

### chefia_courses/lib/features/shopping/voice_input.dart
```dart
import 'package:flutter/material.dart';
import 'package:speech_to_text/speech_to_text.dart' as stt;

class VoiceInput {
  static final _speech = stt.SpeechToText();

  static Future<String?> capture(BuildContext context) async {
    final available = await _speech.initialize(
      onError: (_) {},
      onStatus: (_) {},
    );
    if (!available) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Reconnaissance vocale indisponible')),
      );
      return null;
    }

    String resultText = '';
    await _speech.listen(
      listenMode: stt.ListenMode.dictation,
      onResult: (r) => resultText = r.recognizedWords,
      localeId: null, // laisse le système choisir (FR si tel en FR)
    );

    // petit bottom sheet minimaliste pour afficher l'écoute + stop
    return await showModalBottomSheet<String>(
      context: context,
      showDragHandle: true,
      builder: (ctx) {
        return _VoiceSheet(onStop: () async {
          await _speech.stop();
          Navigator.pop(ctx, resultText.trim().isEmpty ? null : resultText.trim());
        });
      },
    );
  }
}

class _VoiceSheet extends StatelessWidget {
  final Future<void> Function() onStop;
  const _VoiceSheet({required this.onStop});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.mic, size: 36),
            const SizedBox(height: 8),
            const Text('Parlez… (tape "Arrêter" quand c\'est bon)'),
            const SizedBox(height: 12),
            FilledButton.icon(
              onPressed: onStop,
              icon: const Icon(Icons.stop_circle_outlined),
              label: const Text('Arrêter'),
            ),
            const SizedBox(height: 8),
          ],
        ),
      ),
    );
  }
}



```

### chefia_courses/lib/features/shopping/voice_nlu_cloud.dart
```dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';

class CloudNLUResultItem {
  final String name;
  final int qty;
  final String? unit;
  final String category;
  CloudNLUResultItem({required this.name, required this.qty, this.unit, required this.category});
}

class VoiceNLUCloud {
  // TODO: mets l'URL de ton backend ici
  static const String _endpoint = 'https://api.ton-backend.com/nlu/parse';
  static const String _cachePrefix = 'nlu_cache_v1_';

  /// Hash rapide (FNV‑1a 32-bit) pour éviter d'ajouter une dépendance crypto
  static String _hashKey(String s) {
    const int fnvPrime = 16777619;
    const int offset = 2166136261;
    int hash = offset;
    for (int i = 0; i < s.length; i++) {
      hash ^= s.codeUnitAt(i);
      hash = (hash * fnvPrime) & 0xFFFFFFFF;
    }
    return hash.toRadixString(16).padLeft(8, '0');
  }

  static Future<void> _cacheSave(String key, Map<String, dynamic> json) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_cachePrefix + key, jsonEncode({
      'ts': DateTime.now().millisecondsSinceEpoch,
      'data': json,
    }));
  }

  static Future<Map<String, dynamic>?> _cacheLoad(String key, {Duration maxAge = const Duration(days: 30)}) async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_cachePrefix + key);
    if (raw == null) return null;
    try {
      final obj = jsonDecode(raw) as Map<String, dynamic>;
      final ts = (obj['ts'] as num?)?.toInt() ?? 0;
      if (DateTime.now().millisecondsSinceEpoch - ts > maxAge.inMilliseconds) {
        await prefs.remove(_cachePrefix + key);
        return null;
      }
      return obj['data'] as Map<String, dynamic>;
    } catch (_) {
      return null;
    }
  }

  /// [hints] est une liste compacte d'alias connus {alias, canonical, unit, category, defaultQty}
  static Future<List<CloudNLUResultItem>?> parse({
    required String text,
    required String context, // 'list' | 'basket'
    String? sessionId,
    List<Map<String, dynamic>>? hints,
    Duration timeout = const Duration(seconds: 6),
    bool useCache = true,
  }) async {
    final key = _hashKey('$context|$text|${jsonEncode(hints ?? const [])}');

    // 1) Cache d'abord
    if (useCache) {
      final cached = await _cacheLoad(key);
      if (cached != null) {
        final list = <CloudNLUResultItem>[];
        for (final it in (cached['items'] as List)) {
          list.add(CloudNLUResultItem(
            name: it['name'],
            qty: (it['qty'] as num?)?.toInt() ?? 1,
            unit: it['unit'],
            category: it['category'] ?? 'Divers',
          ));
        }
        return list;
      }
    }

    // 2) Appel réseau
    try {
      final body = {
        "lang": "fr",
        "context": context,
        "text": text,
        "sessionId": sessionId ?? "anon",
        if (hints != null && hints.isNotEmpty) "hints": {"aliases": hints},
      };

      final res = await http
          .post(Uri.parse(_endpoint),
              headers: {"Content-Type": "application/json"},
              body: jsonEncode(body))
          .timeout(timeout);

      if (res.statusCode != 200) return null;

      final json = jsonDecode(res.body);
      if (json is! Map || json["items"] is! List) return null;

      // 3) Sauver au cache (compact)
      if (useCache) {
        await _cacheSave(key, {
          "items": (json["items"] as List).map((e) {
            final m = e as Map;
            return {
              "name": (m["name"] ?? "").toString(),
              "qty": (m["qty"] is num) ? (m["qty"] as num).toInt() : 1,
              "unit": (m["unit"] as String?),
              "category": (m["category"] as String?) ?? "Divers",
            };
          }).toList()
        });
      }

      final list = <CloudNLUResultItem>[];
      for (final it in (json["items"] as List)) {
        if (it is! Map) continue;
        final name = (it["name"] ?? "").toString().trim();
        if (name.isEmpty) continue;
        list.add(CloudNLUResultItem(
          name: name,
          qty: (it["qty"] is num) ? (it["qty"] as num).toInt() : 1,
          unit: (it["unit"] as String?)?.trim().isEmpty == true ? null : (it["unit"] as String?),
          category: (it["category"] as String?)?.trim().isEmpty == true ? "Divers" : it["category"],
        ));
      }
      return list;
    } catch (e, st) {
      if (kDebugMode) debugPrint('VoiceNLUCloud error: $e\n$st');
      return null;
    }
  }
}

```

### chefia_courses/lib/features/shopping/voice_parser.dart
```dart
class ParsedVoiceItem {
  final String name;
  final String? unit;     // ex. "2 kg", "1.5 L", "140 g"
  final String category;
  final int qty;          // pièces (nombre d'unités/paquets)
  ParsedVoiceItem(this.name, {this.unit, this.category = 'Divers', this.qty = 1});
}

List<ParsedVoiceItem> parseVoiceToItems(String raw) {
  if (raw.trim().isEmpty) return [];

  String t = raw.toLowerCase()
      .replaceAll('œ', 'oe')
      .replaceAll(RegExp(r'\s+'), ' ')
      .trim();

  // 1) retirer verbes / politesses
  const verbs = [
    'il me faut','ajoute','ajouter','mets','met','rajoute','rajouter',
    'prends','prendre','note','noter','peux tu','peux-tu','stp','svp',
    's il te plait','s\'il te plait','merci','faut','met moi','mets moi'
  ];
  for (final v in verbs) {
    t = t.replaceAll(v, ' ');
  }

  // 2) "et" => virgule pour séparer
  t = t.replaceAll(RegExp(r'\set\s'), ', ');

  // 3) dictionnaires
  const numWords = {
    'zero':0,'un':1,'une':1,'deux':2,'trois':3,'quatre':4,'cinq':5,'six':6,'sept':7,'huit':8,'neuf':9,'dix':10,
    'onze':11,'douze':12,'treize':13,'quatorze':14,'quinze':15,'seize':16,'vingt':20
  };
  int parseWordNum(String w) => numWords[w] ?? int.tryParse(w) ?? 0;

  double parseFrenchNumber(String s) {
    // "1,5" -> 1.5 ; "1.5" reste 1.5 ; "demi" -> 0.5 ; "1/2" -> 0.5
    s = s.trim();
    if (s.contains('/')) {
      final parts = s.split('/');
      final a = double.tryParse(parts[0].replaceAll(',', '.')) ?? 0;
      final b = double.tryParse(parts[1].replaceAll(',', '.')) ?? 1;
      return b == 0 ? 0 : a / b;
    }
    if (s == 'demi' || s == 'demie' || s == '1/2') return 0.5;
    return double.tryParse(s.replaceAll(',', '.')) ?? 0;
  }

  // containers/emballages
  const containers = [
    'bouteille','bouteilles','paquet','paquets','boite','boites','sachet','sachets','pack','packs','barquette','barquettes'
  ];
  String stripContainers(String s) {
    for (final c in containers) {
      s = s.replaceAll(' $c ', ' ');
      s = s.replaceAll(RegExp('^$c '), '');
      s = s.replaceAll(RegExp(' $c\$'), '');
    }
    return s;
  }

  // catégories (étendues)
  final categoryMap = <String, String>{
    'lait':'Frais','beurre':'Frais','yaourt':'Frais','fromage':'Frais','oeuf':'Frais','oeufs':'Frais',
    'jambon':'Frais','steak':'Frais','poulet':'Frais',
    'pomme':'Fruits & Légumes','pommes':'Fruits & Légumes','banane':'Fruits & Légumes','bananes':'Fruits & Légumes',
    'tomate':'Fruits & Légumes','oignon':'Fruits & Légumes','carotte':'Fruits & Légumes','salade':'Fruits & Légumes',
    'farine':'Épicerie','sucre':'Épicerie','sel':'Épicerie','pates':'Épicerie','pâte':'Épicerie','riz':'Épicerie',
    'huile':'Épicerie','cafe':'Boissons','the':'Boissons','eau':'Boissons','jus':'Boissons',
    'papier':'Hygiène','essuie tout':'Hygiène','essuie-tout':'Hygiène','savon':'Hygiène','shampoing':'Hygiène',
    'thon':'Épicerie','conserve':'Épicerie'
  };
  String guessCategory(String name) {
    for (final k in categoryMap.keys) {
      if (name.contains(k)) return categoryMap[k]!;
    }
    return 'Divers';
  }

  // 4) split par , ; .
  final chunks = t.split(RegExp(r'[;,\.]')).map((s)=>s.trim()).where((s)=>s.isNotEmpty).toList();

  // 5) regex puissantes
  // unité masse/volume avec décimales FR/EN (1,5 / 1.5)
  final regUnit = RegExp(r'(\d+(?:[.,]\d+)?)\s*(kg|kilo|kilos|g|grammes?|l|litres?|cl|ml)\b');
  // multiplicateur "x12"
  final regPackX = RegExp(r'\bx\s*(\d+)\b');
  // "pack/boîte/paquet de 6"
  final regPackDe = RegExp(r'\b(?:pack|packs|boite|boites|paquet|paquets|sachet|sachets)\s*(?:de)?\s*(\d+)\b');
  // quantité en tête "deux / 3 / une douzaine"
  final regLeadQtyWords = RegExp(r'^(un|une|deux|trois|quatre|cinq|six|sept|huit|neuf|dix|onze|douze|\d+|\w+\s+douzaine)\b');
  // "demi kilo / demi-litre"
  final regDemiUnit = RegExp(r'\bdemi[- ]?(kilo|litre|kg|l)\b');

  String cap(String s)=> s.isEmpty? s : s[0].toUpperCase()+s.substring(1);

  String normUnit(String u) {
    switch (u) {
      case 'kilo':
      case 'kilos':
        return 'kg';
      case 'gramme':
      case 'grammes':
        return 'g';
      case 'litre':
      case 'litres':
        return 'L';
      case 'l':
        return 'L';
      default:
        return u;
    }
  }

  final results = <ParsedVoiceItem>[];

  for (var c in chunks) {
    if (c.isEmpty) continue;

    int qty = 1;

    // a) "3 bouteilles / un paquet / une douzaine" en tête
    final mLead = regLeadQtyWords.firstMatch(c);
    if (mLead != null) {
      final head = mLead.group(1)!.trim();
      if (head.contains('douzaine')) {
        qty *= 12;
      } else {
        final w = head.split(' ').first;
        final n = parseWordNum(w);
        if (n > 0) qty *= n;
      }
      c = c.replaceFirst(mLead.group(0)!, '').trim();
    }

    // b) "pack/paquet/boîte de 6"
    final mPackDe = regPackDe.firstMatch(c);
    if (mPackDe != null) {
      qty *= int.tryParse(mPackDe.group(1)!) ?? 1;
      c = c.replaceFirst(mPackDe.group(0)!, '').trim();
    }

    // c) "x12"
    final mX = regPackX.firstMatch(c);
    if (mX != null) {
      qty *= int.tryParse(mX.group(1)!) ?? 1;
      c = c.replaceFirst(mX.group(0)!, '').trim();
    }

    // d) demi-kilo / demi-litre => unit numérique 0.5 kg/L
    String? unit;
    final mDemi = regDemiUnit.firstMatch(c);
    if (mDemi != null) {
      final u = mDemi.group(1)!;
      final uNorm = (u.startsWith('k')) || u == 'kg' ? 'kg' : 'L';
      unit = '0.5 $uNorm';
      c = c.replaceFirst(mDemi.group(0)!, '').trim();
    }

    // e) unités explicites "1,5 L / 500 g / 2 kg"
    final mU = regUnit.firstMatch(c);
    if (mU != null) {
      final value = parseFrenchNumber(mU.group(1)!);
      final uNorm = normUnit(mU.group(2)!);
      // format : int si entier sinon décimal
      final text = (value % 1 == 0) ? value.toInt().toString() : value.toString();
      unit = '$text $uNorm';
      c = c.replaceFirst(mU.group(0)!, '').trim();
    }

    // f) nettoyer articles & containers
    c = c
        .replaceAll(RegExp(r'\b(de|du|des|d|la|le|les)\b'), ' ')
        .replaceAll(" d'", ' ')
        .replaceAll(" l'", ' ')
        .replaceAll(" d'", ' ')
        .replaceAll(" l'", ' ')
        .trim();
    c = stripContainers(' $c ').trim();

    // g) singularisation simple
    var name = c;
    if (name.endsWith('s') && !name.endsWith('ss')) {
      name = name.substring(0, name.length - 1);
    }
    if (name == 'pate') name = 'pates';
    if (name == 'oeuf') name = 'oeufs';

    name = name.trim();
    if (name.isEmpty) continue;

    results.add(ParsedVoiceItem(
      cap(name),
      unit: unit,
      category: guessCategory(name),
      qty: qty < 1 ? 1 : qty,
    ));
  }

  return results;
}

```

### chefia_courses/lib/features/tickets/ui/receipt_review_screen.dart
```dart
import 'package:flutter/material.dart';

class ReceiptReviewScreen extends StatelessWidget {
  const ReceiptReviewScreen({super.key, required this.receiptId});
  final int receiptId;

  @override
  Widget build(BuildContext context) {
    // TODO: charger Receipt + ReceiptLines depuis Isar
    return Scaffold(
      appBar: AppBar(title: const Text('Ticket de caisse')),
      body: ListView(
        children: const [
          ListTile(title: Text('Exemple'), subtitle: Text('2 x 1,20 €'), trailing: Text('2,40 €')),
        ],
      ),
      bottomNavigationBar: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: FilledButton.icon(
            onPressed: () {
              // TODO: valider / archiver / comparer prix historiques
            },
            icon: const Icon(Icons.check),
            label: const Text('Valider le ticket'),
          ),
        ),
      ),
    );
  }
}

```

### chefia_courses/lib/models/mappers/shopping_item_mapper.dart
```dart
import 'package:shared_models/shared_models.dart';
import '../shopping_item.dart'; // adapte vers ton entity Isar réelle

extension ShoppingItemMapper on ShoppingItem {
  ShoppingItemDto toDto() => ShoppingItemDto(
    id: id,
    name: name,
    quantity: quantity,
    done: done,
    pantryLinkBarcode: pantryLinkBarcode,
  );
}

extension ShoppingItemDtoMapper on ShoppingItemDto {
  ShoppingItem toIsar() => ShoppingItem(
    id: id,
    name: name,
    quantity: quantity,
    done: done,
    pantryLinkBarcode: pantryLinkBarcode,
  );
}





```

### chefia_courses/lib/services/ai_orchestrator.dart
```dart
import 'ai_provider.dart';
import 'connectivity_service.dart';

class AiOrchestrator {
  AiOrchestrator({AiProvider? local, AiProvider? cloud})
      : _local = local ?? LocalAiProvider(),
        _cloud = cloud ?? CloudAiProvider();

  final AiProvider _local;
  final AiProvider _cloud;

  Future<T> _tryCloudThenLocal<T>({
    required Future<T> Function(AiProvider) cloudFn,
    required Future<T> Function(AiProvider) localFn,
  }) async {
    if (await ConnectivityService.instance.hasNetwork()) {
      try { return await cloudFn(_cloud); } catch (_) {}
    }
    return localFn(_local);
  }

  Future<String> normalizeProductName(String raw) => _tryCloudThenLocal(
    cloudFn: (p) => p.normalizeProductName(raw),
    localFn: (p) => p.normalizeProductName(raw),
  );

  Future<Map<String, dynamic>> extractNutritionAndAllergens(String text) => _tryCloudThenLocal(
    cloudFn: (p) => p.extractNutritionAndAllergens(text),
    localFn: (p) => p.extractNutritionAndAllergens(text),
  );
}

```

### chefia_courses/lib/services/ai_provider.dart
```dart
abstract class AiProvider {
  Future<String> normalizeProductName(String raw);
  Future<Map<String, dynamic>> extractNutritionAndAllergens(String text); // {"ingredients": "...", "allergens": "...", "score": 0-100, "tags": [...]}
}

class LocalAiProvider implements AiProvider {
  @override
  Future<String> normalizeProductName(String raw) async {
    // règles simples: trim, minuscules, enlever codes
    return raw.replaceAll(RegExp(r'[\s]+'), ' ').trim();
  }

  @override
  Future<Map<String, dynamic>> extractNutritionAndAllergens(String text) async {
    final lower = text.toLowerCase();
    final allergens = <String>[];
    for (final a in ['gluten','lait','oeuf','arachide','soja','fruits à coque']) {
      if (lower.contains(a)) allergens.add(a);
    }
    final tags = <String>[];
    if (lower.contains('sirop de glucose')) tags.add('Sirop de glucose');
    if (lower.contains('sucre')) tags.add('Sucre présent');
    return {"ingredients": text, "allergens": allergens.join(', '), "score": 50, "tags": tags};
  }
}

// Stub cloud — à brancher sur ton API plus tard
class CloudAiProvider implements AiProvider {
  @override
  Future<String> normalizeProductName(String raw) async {
    throw UnimplementedError(); // TODO: call API cloud
  }

  @override
  Future<Map<String, dynamic>> extractNutritionAndAllergens(String text) async {
    throw UnimplementedError(); // TODO: call API cloud
  }
}

```

### chefia_courses/lib/services/chefia_cuisine_service.dart
```dart
import 'dart:convert';
import 'package:android_intent_plus/android_intent.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:chefia_courses/features/lists/domain/shopping_list.dart';

class ChefiaCuisineService {
  // Constantes pour ChefIA Cuisine
  static const String _cuisinePackage = 'com.chefia.cuisine';
  static const String _pantryAction = 'com.chefia.PANTRY_ADD_ITEMS';
  static const String _deepLinkScheme = 'chefia://pantry/add';

  /// Envoie silencieusement les articles de la liste vers ChefIA Cuisine
  /// via un broadcast Android (fonctionne hors-ligne)
  static Future<void> sendToChefiaCuisine(ShoppingList shoppingList) async {
    try {
      // Convertir les articles au format attendu par Cuisine
      final items = shoppingList.items.map((item) => {
        'name': item.name,
        'qty': item.quantity,
        'unit': item.unit ?? 'unité',
        'barcode': item.id, // Utiliser l'ID comme code-barres
        'category': item.category ?? 'Général',
        'source': 'courses', // Indiquer la source
        'listName': shoppingList.name, // Nom de la liste source
      }).toList();

      final payload = jsonEncode({
        'source': 'courses',
        'listId': shoppingList.id,
        'listName': shoppingList.name,
        'timestamp': DateTime.now().toIso8601String(),
        'items': items,
      });

      final intent = AndroidIntent(
        action: _pantryAction,
        package: _cuisinePackage,
        arguments: {'payload': payload},
      );

      await intent.sendBroadcast();
      
      print('✅ Articles envoyés vers ChefIA Cuisine: ${items.length} articles');
    } catch (e) {
      print('❌ Erreur lors de l\'envoi vers ChefIA Cuisine: $e');
      rethrow;
    }
  }

  /// Envoie seulement les articles cochés (achetés) vers ChefIA Cuisine
  static Future<void> sendCompletedItemsToChefiaCuisine(ShoppingList shoppingList) async {
    try {
      final completedItems = shoppingList.items.where((item) => item.isCompleted).toList();
      
      if (completedItems.isEmpty) {
        print('ℹ️ Aucun article coché à envoyer');
        return;
      }

      // Créer une liste temporaire avec seulement les articles cochés
      final tempList = ShoppingList(
        id: '${shoppingList.id}_completed',
        name: '${shoppingList.name} - Articles achetés',
        store: shoppingList.store,
        createdAt: DateTime.now(),
        items: completedItems,
      );

      await sendToChefiaCuisine(tempList);
    } catch (e) {
      print('❌ Erreur lors de l\'envoi des articles cochés: $e');
      rethrow;
    }
  }

  /// Ouvre ChefIA Cuisine via deep-link (optionnel)
  /// Utile pour montrer à l'utilisateur que l'import a bien été effectué
  static Future<void> openChefiaCuisine() async {
    try {
      final uri = Uri.parse(_deepLinkScheme);
      if (await canLaunchUrl(uri)) {
        await launchUrl(uri, mode: LaunchMode.externalApplication);
      } else {
        // Fallback: essayer d'ouvrir l'app directement
        final intent = AndroidIntent(
          action: 'android.intent.action.MAIN',
          package: _cuisinePackage,
        );
        await intent.launch();
      }
    } catch (e) {
      print('❌ Erreur lors de l\'ouverture de ChefIA Cuisine: $e');
      rethrow;
    }
  }

  /// Vérifie si ChefIA Cuisine est installée
  static Future<bool> isChefiaCuisineInstalled() async {
    try {
      final intent = AndroidIntent(
        action: 'android.intent.action.MAIN',
        package: _cuisinePackage,
      );
      // Si on peut créer l'intent, l'app est probablement installée
      return true;
    } catch (e) {
      return false;
    }
  }
}




```

### chefia_courses/lib/services/connectivity_service.dart
```dart
import 'dart:async';
import 'package:connectivity_plus/connectivity_plus.dart';

class ConnectivityService {
  static final ConnectivityService instance = ConnectivityService._();
  ConnectivityService._();
  final _c = Connectivity();

  Future<bool> hasNetwork() async {
    final r = await _c.checkConnectivity();
    return r.contains(ConnectivityResult.mobile) || r.contains(ConnectivityResult.wifi);
  }

  Stream<bool> watch() => _c.onConnectivityChanged.map((e) =>
    e.contains(ConnectivityResult.mobile) || e.contains(ConnectivityResult.wifi));
}

```

### chefia_courses/lib/services/label_parser.dart
```dart
class LabelInfo {
  final DateTime? bestBefore;
  final String? lotNumber;
  final String? ingredients;
  final String? allergens;
  final double? qtyValue;
  final String? qtyUnit;
  LabelInfo({this.bestBefore, this.lotNumber, this.ingredients, this.allergens, this.qtyValue, this.qtyUnit});
}

class LabelParser {
  LabelInfo parse(String ocrText) {
    // TODO: repérer DLC/DDM, LOT, ingrédients, allergènes
    return LabelInfo();
  }
}

```

### chefia_courses/lib/services/ocr_service.dart
```dart
class OcrResult {
  final String rawText;
  final double confidence;
  OcrResult(this.rawText, this.confidence);
}

abstract class OcrService {
  Future<OcrResult> extractTextFromImage(String imagePath);
}

```

### chefia_courses/lib/services/quality_estimator.dart
```dart
class QualityReport {
  final int score;           // 0..100
  final List<String> tags;   // ["Sucre élevé", "Additifs : E330"]
  final String summary;      // explication courte
  QualityReport({required this.score, required this.tags, required this.summary});
}

class QualityEstimator {
  QualityReport estimate({
    required String? ingredients,
    required String? allergens,
    required double? sugarsPer100, // si on l'a plus tard
    required double? saltPer100,
  }) {
    int score = 50;
    final tags = <String>[];

    if ((ingredients ?? '').toLowerCase().contains('sucre')) {
      score -= 10; tags.add('Sucre présent');
    }
    if ((ingredients ?? '').toLowerCase().contains('sirop de glucose')) {
      score -= 10; tags.add('Sirop de glucose');
    }
    if ((allergens ?? '').isNotEmpty) {
      tags.add('Allergènes: $allergens');
    }
    final summary = tags.isEmpty ? 'Composition simple.' : tags.join(' • ');
    return QualityReport(score: score.clamp(0, 100), tags: tags, summary: summary);
  }
}

```

### chefia_courses/lib/services/receipt_parser.dart
```dart
class ParsedReceipt {
  final String store;
  final DateTime date;
  final List<ParsedReceiptLine> lines;
  final double total;
  ParsedReceipt({required this.store, required this.date, required this.lines, required this.total});
}

class ParsedReceiptLine {
  final String name;
  final double? qtyValue;
  final String? qtyUnit;
  final double? unitPrice;
  final double lineTotal;
  ParsedReceiptLine({required this.name, this.qtyValue, this.qtyUnit, this.unitPrice, required this.lineTotal});
}

class ReceiptParser {
  ParsedReceipt parse(String ocrText) {
    // TODO: regex + heuristiques FR (ignorer TOTAL/TVA)
    // Placeholder minimal pour brancher l'UI
    return ParsedReceipt(
      store: 'Magasin',
      date: DateTime.now(),
      lines: [],
      total: 0.0,
    );
  }
}

```

### chefia_courses/lib/services/storage.dart
```dart
import 'package:hive/hive.dart';

class Storage {
  static Box get pantry => Hive.box('pantry');
  static Box get cart => Hive.box('cart');
  static Box get tickets => Hive.box('tickets');

  /// ----- Garde-manger -----
  static Future<void> upsertPantryItem(String id, Map<String, dynamic> data) async {
    // id: ton identifiant (ex: code-barres)
    await pantry.put(id, data);
  }

  static Map<String, dynamic>? getPantryItem(String id) {
    final v = pantry.get(id);
    if (v is Map) return Map<String, dynamic>.from(v);
    return null;
  }

  static Future<void> deletePantryItem(String id) => pantry.delete(id);

  static List<Map<String, dynamic>> allPantryItems() {
    return pantry.values
        .whereType<Map>()
        .map((e) => Map<String, dynamic>.from(e))
        .toList();
  }

  /// ----- Liste de courses / Panier -----
  static Future<void> addToCart(Map<String, dynamic> item) async {
    // Génère une clé unique auto
    await cart.add(item);
  }

  static List<Map<String, dynamic>> allCartItems() {
    return cart.values
        .whereType<Map>()
        .map((e) => Map<String, dynamic>.from(e))
        .toList();
  }

  static Future<void> clearCart() => cart.clear();

  /// ----- Tickets -----
  static Future<void> addTicket(Map<String, dynamic> ticket) async {
    await tickets.add(ticket);
  }

  static List<Map<String, dynamic>> allTickets() {
    return tickets.values
        .whereType<Map>()
        .map((e) => Map<String, dynamic>.from(e))
        .toList();
  }
}


```

### chefia_courses/lib/testing/assert_smart.dart
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter/material.dart';

/// Assertion intelligente qui utilise les synonymes et fallbacks
/// pour trouver des éléments UI de manière robuste
void assertVisibleSmartWithDict(
  WidgetTester tester,
  String text, {
  Map<String, List<String>>? synonyms,
  Duration timeout = const Duration(seconds: 5),
}) {
  // Stratégies de recherche par ordre de priorité
  final strategies = [
    () => find.text(text),
    () => find.widgetWithText(Text, text),
    () => find.widgetWithText(TextButton, text),
    () => find.widgetWithText(ElevatedButton, text),
    () => find.widgetWithText(FilledButton, text),
    () => find.widgetWithText(OutlinedButton, text),
  ];

  // Si des synonymes sont fournis, les ajouter aux stratégies
  if (synonyms != null && synonyms.containsKey(text)) {
    for (final synonym in synonyms[text]!) {
      strategies.addAll([
        () => find.text(synonym),
        () => find.widgetWithText(Text, synonym),
        () => find.widgetWithText(TextButton, synonym),
        () => find.widgetWithText(ElevatedButton, synonym),
        () => find.widgetWithText(FilledButton, synonym),
        () => find.widgetWithText(OutlinedButton, synonym),
      ]);
    }
  }

  // Essayer chaque stratégie
  for (final strategy in strategies) {
    try {
      final finder = strategy();
      if (finder.evaluate().isNotEmpty) {
        expect(finder, findsOneWidget);
        return;
      }
    } catch (e) {
      // Continuer avec la stratégie suivante
    }
  }

  // Si aucune stratégie n'a fonctionné, échouer avec un message détaillé
  fail('Élément "$text" non trouvé avec les stratégies disponibles');
}

/// Assertion pour vérifier qu'un élément est visible avec timeout
void assertVisibleWithTimeout(
  WidgetTester tester,
  String text, {
  Duration timeout = const Duration(seconds: 5),
}) {
  final finder = find.text(text);
  expect(finder, findsOneWidget);
}

/// Assertion pour vérifier qu'un élément contient un texte
void assertContainsText(
  WidgetTester tester,
  String text, {
  Duration timeout = const Duration(seconds: 5),
}) {
  final finder = find.textContaining(text);
  expect(finder, findsOneWidget);
}

```

### chefia_courses/lib/testing/fake_clock.dart
```dart
import 'package:flutter/foundation.dart';

/// Horloge factice pour les tests
/// Permet de contrôler la date/heure pour des tests déterministes
class FakeClock {
  static DateTime? _fixedDateTime;
  static Duration? _offset;

  /// Définit une date/heure fixe pour les tests
  static void set(DateTime dateTime) {
    assert(kDebugMode, 'FakeClock.set() ne doit s\'utiliser qu\'en debug/test');
    _fixedDateTime = dateTime;
    _offset = null;
    debugPrint('[FAKE_CLOCK] Date fixée: $dateTime');
  }

  /// Définit un décalage temporel (utile pour simuler le passage du temps)
  static void setOffset(Duration offset) {
    assert(kDebugMode, 'FakeClock.setOffset() ne doit s\'utiliser qu\'en debug/test');
    _fixedDateTime = null;
    _offset = offset;
    debugPrint('[FAKE_CLOCK] Décalage fixé: $offset');
  }

  /// Désactive l'horloge factice
  static void clear() {
    _fixedDateTime = null;
    _offset = null;
    debugPrint('[FAKE_CLOCK] Horloge factice désactivée');
  }

  /// Récupère la date/heure courante (réelle ou factice)
  static DateTime now() {
    if (_fixedDateTime != null) {
      return _fixedDateTime!;
    }
    if (_offset != null) {
      return DateTime.now().add(_offset!);
    }
    return DateTime.now();
  }

  /// Avance le temps (si une date fixe est définie)
  static void advance(Duration duration) {
    if (_fixedDateTime != null) {
      _fixedDateTime = _fixedDateTime!.add(duration);
      debugPrint('[FAKE_CLOCK] Temps avancé de $duration: $_fixedDateTime');
    } else if (_offset != null) {
      _offset = _offset!.add(duration);
      debugPrint('[FAKE_CLOCK] Décalage avancé de $duration: $_offset');
    }
  }

  /// Définit une date spécifique pour les tests d'expiration
  static void setExpiryTestDate() {
    set(DateTime(2025, 8, 1, 12, 0)); // 1er août 2025 à midi
  }

  /// Définit une date pour les tests de badges
  static void setBadgeTestDate() {
    set(DateTime(2025, 8, 15, 9, 30)); // 15 août 2025 à 9h30
  }

  /// Définit une date pour les tests de performance
  static void setPerformanceTestDate() {
    set(DateTime(2025, 8, 1, 0, 0)); // 1er août 2025 à minuit
  }

  /// Vérifie si l'horloge factice est active
  static bool get isActive => _fixedDateTime != null || _offset != null;

  /// Récupère le statut de l'horloge factice
  static String get status {
    if (_fixedDateTime != null) {
      return 'Date fixe: $_fixedDateTime';
    }
    if (_offset != null) {
      return 'Décalage: $_offset';
    }
    return 'Horloge réelle';
  }
}














```

### chefia_courses/lib/testing/selectors.dart
```dart
/// Registre central des sélecteurs pour les tests
/// Utilise des constantes pour éviter les erreurs de frappe et centraliser les identifiants
class Sel {
  // Keys
  static const String pantryAddKey = 'btn_pantry_add';
  static const String pantrySaveKey = 'btn_pantry_save';
  static const String pantryDeleteKey = 'btn_pantry_delete';
  static const String pantryExportKey = 'btn_pantry_export_to_courses';
  static const String pantryNameFieldKey = 'field_pantry_name';
  static const String pantryQuantityFieldKey = 'field_pantry_quantity';
  static const String pantryExpiryFieldKey = 'field_pantry_expiry';

  // Textes (UI visibles)
  static const String txtPantry = 'Garde-manger';
  static const String txtAdd = 'Ajouter';
  static const String txtSave = 'Enregistrer';
  static const String txtDelete = 'Supprimer';
  static const String txtExport = 'Envoyer vers Courses';
  static const String txtModify = 'Modifier';
  static const String txtConfirm = 'Confirmer';
  static const String txtCancel = 'Annuler';

  // A11y / Semantics (fallback robuste)
  static const String a11yAdd = 'Ajouter au garde-manger';
  static const String a11ySave = 'Enregistrer l\'article';
  static const String a11yDelete = 'Supprimer l\'article';
  static const String a11yExport = 'Exporter vers la liste de courses';

  // Icônes (dernier recours)
  static const String iconAdd = 'add';
  static const String iconSave = 'save';
  static const String iconDelete = 'delete';
  static const String iconExport = 'send';
}














```

### chefia_courses/lib/testing/tap_smart.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

/// Utilitaire pour interaction intelligente avec l'UI
/// Utilise une stratégie multi-pistes pour localiser les éléments
class TapSmart {
  /// Tente de taper sur un élément via plusieurs stratégies
  /// Ordre: Key -> Semantics -> Texte -> Synonymes -> Icône -> Scroll+Retry
  static Future<void> tapSmart(
    WidgetTester tester, {
    Key? key,
    String? a11y,
    String? text,
    List<String> synonyms = const [],
    String? icon,
  }) async {
    // 1) Tenter par Key (priorité 1)
    if (key != null) {
      final keyFinder = find.byKey(key);
      if (keyFinder.evaluate().isNotEmpty) {
        await tester.tap(keyFinder);
        await tester.pumpAndSettle();
        return;
      }
    }

    // 2) Tenter par Semantics (priorité 2)
    if (a11y != null) {
      final a11yFinder = find.bySemanticsLabel(a11y);
      if (a11yFinder.evaluate().isNotEmpty) {
        await tester.tap(a11yFinder);
        await tester.pumpAndSettle();
        return;
      }
    }

    // 3) Tenter par Texte exact (priorité 3)
    if (text != null) {
      final textFinder = find.text(text);
      if (textFinder.evaluate().isNotEmpty) {
        await tester.tap(textFinder);
        await tester.pumpAndSettle();
        return;
      }
    }

    // 4) Tenter par Synonymes
    for (final synonym in synonyms) {
      final synonymFinder = find.text(synonym);
      if (synonymFinder.evaluate().isNotEmpty) {
        await tester.tap(synonymFinder);
        await tester.pumpAndSettle();
        return;
      }
    }

    // 5) Tenter par Icône (dernier recours)
    if (icon != null) {
      final iconFinder = find.byIcon(_getIconData(icon));
      if (iconFinder.evaluate().isNotEmpty) {
        await tester.tap(iconFinder);
        await tester.pumpAndSettle();
        return;
      }
    }

    // 6) Fallback: scroll et retenter
    await _scrollAndRetry(tester, text: text, a11y: a11y, key: key);
  }

  /// Saisit du texte dans un champ
  static Future<void> enterText(
    WidgetTester tester, {
    Key? key,
    required String value,
  }) async {
    if (key != null) {
      final fieldFinder = find.byKey(key);
      if (fieldFinder.evaluate().isNotEmpty) {
        await tester.enterText(fieldFinder, value);
        await tester.pumpAndSettle();
        return;
      }
    }

    // Fallback: premier TextFormField trouvé
    final textFieldFinder = find.byType(TextFormField).first;
    if (textFieldFinder.evaluate().isNotEmpty) {
      await tester.enterText(textFieldFinder, value);
      await tester.pumpAndSettle();
    }
  }

  /// Scroll et retente la recherche
  static Future<void> _scrollAndRetry(
    WidgetTester tester, {
    String? text,
    String? a11y,
    Key? key,
  }) async {
    // Scroll léger vers le haut
    final scrollables = find.byType(Scrollable);
    if (scrollables.evaluate().isNotEmpty) {
      await tester.fling(scrollables.first, const Offset(0, -200), 600);
      await tester.pumpAndSettle();
    }

    // Retenter après scroll
    if (key != null) {
      final keyFinder = find.byKey(key);
      if (keyFinder.evaluate().isNotEmpty) {
        await tester.tap(keyFinder);
        await tester.pumpAndSettle();
        return;
      }
    }

    if (a11y != null) {
      final a11yFinder = find.bySemanticsLabel(a11y);
      if (a11yFinder.evaluate().isNotEmpty) {
        await tester.tap(a11yFinder);
        await tester.pumpAndSettle();
        return;
      }
    }

    if (text != null) {
      final textFinder = find.text(text);
      if (textFinder.evaluate().isNotEmpty) {
        await tester.tap(textFinder);
        await tester.pumpAndSettle();
        return;
      }
    }

    throw TestFailure('tapSmart: élément introuvable après scroll (key=$key, text=$text, a11y=$a11y)');
  }

  /// Convertit un nom d'icône en IconData
  static IconData _getIconData(String iconName) {
    switch (iconName) {
      case 'add':
        return Icons.add;
      case 'save':
        return Icons.save;
      case 'delete':
        return Icons.delete;
      case 'send':
        return Icons.send;
      default:
        return Icons.help; // Icône par défaut
    }
  }
}














```

### chefia_courses/lib/testing/test_reset.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Utilitaire pour nettoyer l'état de l'application avant les tests
/// Assure un environnement propre et déterministe
class TestReset {
  /// Effectue un reset complet de l'application
  /// Purge toutes les données persistantes
  static Future<void> reset() async {
    assert(kDebugMode, 'TestReset.reset() ne doit s\'utiliser qu\'en debug/test');
    
    try {
      // 1) Purge SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      await prefs.clear();
      
      // 2) Purge Hive (si utilisé)
      // Note: Hive nécessite une initialisation préalable
      // await _clearHiveBoxes();
      
      // 3) Purge autres caches si nécessaire
      // await _clearImageCache();
      
      debugPrint('[TEST_RESET] État de l\'application purgé');
    } catch (e) {
      debugPrint('[TEST_RESET] Erreur lors du reset: $e');
      // Ne pas faire échouer le test pour un reset
    }
  }

  /// Vérifie que le reset a bien fonctionné
  static Future<bool> verifyReset() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final keys = prefs.getKeys();
      return keys.isEmpty;
    } catch (e) {
      debugPrint('[TEST_RESET] Erreur lors de la vérification: $e');
      return false;
    }
  }

  /// Reset sélectif (pour certains types de données seulement)
  static Future<void> resetSelective({
    bool clearPrefs = true,
    bool clearDatabase = true,
    bool clearCache = false,
  }) async {
    assert(kDebugMode, 'TestReset.resetSelective() ne doit s\'utiliser qu\'en debug/test');
    
    try {
      if (clearPrefs) {
        final prefs = await SharedPreferences.getInstance();
        await prefs.clear();
      }
      
      if (clearDatabase) {
        // await _clearHiveBoxes();
      }
      
      if (clearCache) {
        // await _clearImageCache();
      }
      
      debugPrint('[TEST_RESET] Reset sélectif effectué');
    } catch (e) {
      debugPrint('[TEST_RESET] Erreur lors du reset sélectif: $e');
    }
  }

  /// Reset pour un test spécifique
  static Future<void> resetForTest(String testName) async {
    debugPrint('[TEST_RESET] Reset pour le test: $testName');
    await reset();
  }

  /// Reset avec vérification
  static Future<void> resetWithVerification() async {
    await reset();
    final success = await verifyReset();
    if (!success) {
      debugPrint('[TEST_RESET] ⚠️ Reset incomplet détecté');
    }
  }
}














```

### chefia_courses/lib/ui/screens/compare_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../features/shopping/models.dart';
import '../../features/shopping/providers.dart';

class CompareScreen extends ConsumerWidget {
  const CompareScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final basket = ref.watch(basketProvider);
    final ticket  = ref.watch(ticketProvider);

    // Totaux (si prix dispo)
    double? basketTotal, ticketTotal;
    bool hasAnyPrice = false;
    for (final l in basket) {
      if (l.item.unitPrice != null) {
        hasAnyPrice = true;
        basketTotal = (basketTotal ?? 0) + l.item.unitPrice! * l.qty;
      }
    }
    for (final l in ticket) {
      if (l.item.unitPrice != null) {
        hasAnyPrice = true;
        ticketTotal = (ticketTotal ?? 0) + l.item.unitPrice! * l.qty;
      }
    }

    // Indexation simple par "clé normalisée"
    String keyOf(ShoppingItem i) {
      final s = i.name.toLowerCase().replaceAll(RegExp(r'[^a-z0-9]'), '');
      return s.isEmpty ? i.id : s;
    }

    final Map<String, BasketLine> bMap = {
      for (final l in basket) keyOf(l.item): l
    };
    final Map<String, BasketLine> tMap = {
      for (final l in ticket) keyOf(l.item): l
    };

    final allKeys = <String>{...bMap.keys, ...tMap.keys}.toList()..sort();

    final diffs = <_Diff>[];
    final onlyTicket = <BasketLine>[];
    final onlyBasket = <BasketLine>[];

    for (final k in allKeys) {
      final b = bMap[k];
      final t = tMap[k];
      if (b != null && t != null) {
        if (b.qty != t.qty || (b.item.unitPrice ?? 0) != (t.item.unitPrice ?? 0)) {
          diffs.add(_Diff(b, t));
        }
      } else if (t != null) {
        onlyTicket.add(t);
      } else if (b != null) {
        onlyBasket.add(b);
      }
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Comparer panier / ticket'),
        actions: [
          IconButton(
            tooltip: 'Vider le ticket',
            icon: const Icon(Icons.delete_sweep),
            onPressed: () => ref.read(ticketProvider.notifier).clear(),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () async {
          final data = await _promptTicketLine(context);
          if (data == null) return;
          final item = ShoppingItem(
            id: 'ticket-${DateTime.now().millisecondsSinceEpoch}',
            name: data.name,
            unit: data.unit?.isEmpty == true ? null : data.unit,
            category: data.category?.isEmpty == true ? 'Divers' : data.category!,
          );
          ref.read(ticketProvider.notifier).add(
                item,
                qty: data.qty,
                unitPrice: data.unitPrice,
              );
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('"${item.name}" ajouté au ticket')),
          );
        },
        icon: const Icon(Icons.receipt_long),
        label: const Text('Ajouter au ticket'),
      ),
      body: ListView(
        padding: const EdgeInsets.fromLTRB(12, 8, 12, 24),
        children: [
          _TotalsCard(
            basketCount: basket.fold<int>(0, (a,b)=>a+b.qty),
            ticketCount:  ticket.fold<int>(0, (a,b)=>a+b.qty),
            basketTotal:  basketTotal,
            ticketTotal:  ticketTotal,
            hasAnyPrice:  hasAnyPrice,
          ),
          const SizedBox(height: 12),
          if (diffs.isNotEmpty) ...[
            Text('Différences', style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 6),
            ...diffs.map((d) => _DiffTile(diff: d)),
            const SizedBox(height: 16),
          ],
          ExpansionTile(
            leading: const Icon(Icons.playlist_add_check_outlined),
            title: const Text('Présents uniquement dans le ticket'),
            initiallyExpanded: false,
            children: onlyTicket.isEmpty
                ? [const ListTile(title: Text('Aucun'))]
                : onlyTicket.map((l) => ListTile(
                      title: Text(l.item.name),
                      subtitle: Text([
                        if (l.item.unit != null) l.item.unit!,
                        if (l.item.unitPrice != null) '${l.item.unitPrice!.toStringAsFixed(2)} €',
                      ].join(' • ')),
                      trailing: Text('x${l.qty}'),
                    ))
                  .toList(),
          ),
          const SizedBox(height: 8),
          ExpansionTile(
            leading: const Icon(Icons.remove_shopping_cart_outlined),
            title: const Text('Présents dans le panier mais pas sur le ticket'),
            initiallyExpanded: false,
            children: onlyBasket.isEmpty
                ? [const ListTile(title: Text('Aucun'))]
                : onlyBasket.map((l) => ListTile(
                      title: Text(l.item.name),
                      subtitle: Text([
                        if (l.item.unit != null) l.item.unit!,
                        if (l.item.unitPrice != null) '${l.item.unitPrice!.toStringAsFixed(2)} €',
                      ].join(' • ')),
                      trailing: Text('x${l.qty}'),
                    ))
                  .toList(),
          ),
          const SizedBox(height: 24),
          FilledButton.icon(
            onPressed: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Import ticket (photo OCR) — à venir')),
              );
            },
            icon: const Icon(Icons.photo_camera_outlined),
            label: const Text('Importer un ticket (photo)'),
          ),
        ],
      ),
    );
  }
}

// ----- UI composants -----

class _TotalsCard extends StatelessWidget {
  final int basketCount, ticketCount;
  final double? basketTotal, ticketTotal;
  final bool hasAnyPrice;
  const _TotalsCard({
    required this.basketCount,
    required this.ticketCount,
    required this.basketTotal,
    required this.ticketTotal,
    required this.hasAnyPrice,
  });

  @override
  Widget build(BuildContext context) {
    final t = Theme.of(context).textTheme;
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('Panier'),
                  Text('$basketCount articles', style: t.titleMedium),
                  if (hasAnyPrice && basketTotal != null)
                    Text('${basketTotal!.toStringAsFixed(2)} €'),
                ],
              ),
            ),
            const VerticalDivider(width: 1),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('Ticket'),
                  Text('$ticketCount articles', style: t.titleMedium),
                  if (hasAnyPrice && ticketTotal != null)
                    Text('${ticketTotal!.toStringAsFixed(2)} €'),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _Diff {
  final BasketLine basket;
  final BasketLine ticket;
  const _Diff(this.basket, this.ticket);
}

class _DiffTile extends StatelessWidget {
  final _Diff diff;
  const _DiffTile({required this.diff});

  @override
  Widget build(BuildContext context) {
    final b = diff.basket;
    final t = diff.ticket;
    final priceB = b.item.unitPrice;
    final priceT = t.item.unitPrice;
    final hasPrice = priceB != null || priceT != null;

    String priceText() {
      if (!hasPrice) return '';
      final btxt = priceB != null ? '${priceB.toStringAsFixed(2)}€' : '—';
      final ttxt = priceT != null ? '${priceT.toStringAsFixed(2)}€' : '—';
      return '$btxt → $ttxt';
    }

    return ListTile(
      leading: const Icon(Icons.compare_arrows),
      title: Text(b.item.name),
      subtitle: Text([
        if (b.item.unit != null) b.item.unit!,
        if (hasPrice) priceText(),
      ].join(' • ')),
      trailing: Text('Panier x${b.qty}  |  Ticket x${t.qty}'),
    );
  }
}

// ----- Dialog de saisie d'une ligne ticket -----

class _TicketData {
  final String name;
  final String? unit;
  final String? category;
  final int qty;
  final double? unitPrice;
  _TicketData(this.name, this.unit, this.category, this.qty, this.unitPrice);
}

Future<_TicketData?> _promptTicketLine(BuildContext context) async {
  final nameCtrl = TextEditingController();
  final unitCtrl = TextEditingController();
  final catCtrl = TextEditingController();
  final qtyCtrl = TextEditingController(text: '1');
  final priceCtrl = TextEditingController();
  final formKey = GlobalKey<FormState>();

  return showDialog<_TicketData>(
    context: context,
    builder: (ctx) => AlertDialog(
      title: const Text('Ajouter une ligne du ticket'),
      content: Form(
        key: formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextFormField(
              controller: nameCtrl,
              decoration: const InputDecoration(labelText: 'Produit *'),
              validator: (v) => (v == null || v.trim().isEmpty) ? 'Nom requis' : null,
              autofocus: true,
            ),
            const SizedBox(height: 8),
            TextFormField(
              controller: qtyCtrl,
              decoration: const InputDecoration(labelText: 'Quantité'),
              keyboardType: TextInputType.number,
              validator: (v) {
                final n = int.tryParse(v ?? '');
                return (n == null || n <= 0) ? 'Quantité invalide' : null;
              },
            ),
            const SizedBox(height: 8),
            TextFormField(
              controller: priceCtrl,
              decoration: const InputDecoration(labelText: 'Prix unitaire (€) — optionnel'),
              keyboardType: const TextInputType.numberWithOptions(decimal: true),
            ),
            const SizedBox(height: 8),
            TextFormField(
              controller: unitCtrl,
              decoration: const InputDecoration(labelText: 'Unité (optionnel)', hintText: 'ex. 1 L, 500 g'),
            ),
            const SizedBox(height: 8),
            TextFormField(
              controller: catCtrl,
              decoration: const InputDecoration(labelText: 'Catégorie (optionnel)', hintText: 'Épicerie, Frais…'),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Annuler')),
        FilledButton(
          onPressed: () {
            if (formKey.currentState?.validate() != true) return;
            final qty = int.parse(qtyCtrl.text.trim());
            final price = double.tryParse(priceCtrl.text.replaceAll(',', '.').trim());
            Navigator.pop(ctx, _TicketData(
              nameCtrl.text.trim(),
              unitCtrl.text.trim().isEmpty ? null : unitCtrl.text.trim(),
              catCtrl.text.trim().isEmpty ? null : catCtrl.text.trim(),
              qty,
              price,
            ));
          },
          child: const Text('Ajouter'),
        ),
      ],
    ),
  );
}

```

### chefia_courses/lib/ui/screens/lists_overview_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../features/lists/data/shopping_repository.dart';
import '../../features/lists/domain/shopping_list.dart';

final listsProvider = FutureProvider<List<ShoppingList>>((ref) async {
  return ShoppingRepository.getAllLists();
});

class ListsOverviewScreen extends ConsumerWidget {
  const ListsOverviewScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final asyncLists = ref.watch(listsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Mes listes'),
        actions: [
          IconButton(
            icon: const Icon(Icons.add),
            onPressed: () async {
              // Créer une nouvelle liste
              final newList = ShoppingList(
                id: DateTime.now().millisecondsSinceEpoch.toString(),
                name: 'Nouvelle liste',
                store: 'Magasin',
                createdAt: DateTime.now(),
                items: [],
              );
              await ShoppingRepository.createList(newList);
              ref.invalidate(listsProvider);
            },
          ),
        ],
      ),
      body: asyncLists.when(
        data: (lists) {
          if (lists.isEmpty) {
            return Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(Icons.list_alt_outlined, size: 64, color: Colors.grey),
                  const SizedBox(height: 16),
                  const Text('Aucune liste créée'),
                  const SizedBox(height: 8),
                  FilledButton.icon(
                    onPressed: () async {
                      final newList = ShoppingList(
                        id: DateTime.now().millisecondsSinceEpoch.toString(),
                        name: 'Ma première liste',
                        store: 'Magasin',
                        createdAt: DateTime.now(),
                        items: [],
                      );
                      await ShoppingRepository.createList(newList);
                      ref.invalidate(listsProvider);
                    },
                    icon: const Icon(Icons.add),
                    label: const Text('Créer ma première liste'),
                  ),
                ],
              ),
            );
          }
          return ListView.separated(
            itemCount: lists.length,
            separatorBuilder: (_, __) => const Divider(height: 1),
            itemBuilder: (context, i) {
              final list = lists[i];
              return ListTile(
                title: Text(list.name),
                subtitle: Text('${list.store} • ${list.items.length} articles'),
                leading: const Icon(Icons.list_alt),
                trailing: const Icon(Icons.chevron_right),
                onTap: () => context.push('/list/${list.id}'),
              );
            },
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Center(child: Text('Erreur: $e')),
      ),
    );
  }
}

```

### chefia_courses/lib/ui/screens/settings_screen.dart
```dart
import 'package:flutter/material.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Paramètres')),
      body: ListView(
        children: const [
          ListTile(
            leading: Icon(Icons.wifi_off),
            title: Text('Mode hors ligne'),
            subtitle: Text('Conserver les listes sans réseau'),
          ),
          Divider(height: 1),
          ListTile(
            leading: Icon(Icons.mic_none),
            title: Text('Ajout vocal'),
            subtitle: Text('Langue, activation rapide'),
          ),
          Divider(height: 1),
          ListTile(
            leading: Icon(Icons.qr_code_scanner),
            title: Text('Scan code‑barres'),
            subtitle: Text('Base produit / auto‑complétion'),
          ),
        ],
      ),
    );
  }
}

```

### chefia_courses/lib/ui/screens/shopping_split_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'dart:convert';
import 'package:flutter/services.dart'; // pour copier JSON (clipboard)
import 'package:url_launcher/url_launcher.dart';
import 'package:android_intent_plus/android_intent.dart';
import '../../features/shopping/models.dart';
import '../../features/shopping/providers.dart';
import '../../features/shopping/catalog.dart';
import '../../features/shopping/barcode_scan_sheet.dart';
import '../../features/shopping/voice_input.dart';
import '../../features/shopping/voice_parser.dart';
import '../../features/shopping/voice_nlu_cloud.dart';
import '../../features/personalization/user_lexicon.dart';

class ShoppingSplitScreen extends ConsumerStatefulWidget {
  const ShoppingSplitScreen({super.key});

  @override
  ConsumerState<ShoppingSplitScreen> createState() => _ShoppingSplitScreenState();
}

class _ShoppingSplitScreenState extends ConsumerState<ShoppingSplitScreen> {
  final _pageController = PageController();
  int _pageIndex = 0;

  @override
  void initState() {
    super.initState();
    // hydrate depuis SharedPreferences
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      await ref.read(persistenceInitProvider.future);
      // Charger le lexique utilisateur
      await ref.read(userLexiconProvider.notifier).load();
    });
  }

  // Utilitaire pour appliquer le lexique utilisateur
  ParsedVoiceItem applyLexicon(ParsedVoiceItem p, Map<String, LexEntry> lex) {
    final key = p.name.toLowerCase();
    final hit = lex[key];
    if (hit == null) return p;
    return ParsedVoiceItem(
      hit.canonical,
      unit: p.unit ?? hit.unit,
      category: hit.category,
      qty: p.qty > 1 ? p.qty : hit.defaultQty,
    );
  }

  Future<void> _handleQuickVoice(BuildContext context, WidgetRef ref, {required int pageIndex}) async {
    final raw = await VoiceInput.capture(context);
    if (raw == null || raw.isEmpty) return;

    // petit overlay de progression
    final navigator = Navigator.of(context);
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    // 1) Cloud par défaut
    final isBasket = pageIndex == 1;
    final cloud = await VoiceNLUCloud.parse(
      text: raw,
      context: isBasket ? 'basket' : 'list',
      sessionId: 'device', // ou un vrai id utilisateur si tu as
    );

    // 2) Fermer le loader (vérifier que le context est toujours valide)
    if (context.mounted && navigator.canPop()) navigator.pop();

    // 3) Choisir la source (cloud ou offline)
    if (cloud != null && cloud.isNotEmpty) {
      int pieces = 0;
      final previewNames = <String>[];
      for (final c in cloud) {
        final item = ShoppingItem(
          id: 'voice-cloud-${DateTime.now().millisecondsSinceEpoch}-${pieces}',
          name: c.name,
          unit: c.unit,
          category: c.category,
          isFromMain: !isBasket,
          isFromRecipe: false,
        );
        if (isBasket) {
          for (var i = 0; i < (c.qty <= 0 ? 1 : c.qty); i++) {
            ref.read(basketProvider.notifier).add(item);
          }
          final set = {...ref.read(checkedProvider)}..add(item.id);
          ref.read(checkedProvider.notifier).state = set;
          pieces += c.qty <= 0 ? 1 : c.qty;
        } else {
          final itemForList = item.copyWith(
            unit: c.unit ?? (c.qty > 1 ? 'x${c.qty}' : null),
          );
          ref.read(plannedListProvider.notifier).state = [
            ...ref.read(plannedListProvider),
            itemForList,
          ];
          pieces += c.qty <= 0 ? 1 : c.qty;
        }
        if (previewNames.length < 3) previewNames.add(c.qty > 1 ? '${c.name} x${c.qty}' : c.name);
      }

      // Vérifier que le context est toujours valide avant d'afficher le SnackBar
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(cloud.length == 1
              ? 'Ajouté : ${previewNames.join(', ')}'
              : 'Ajoutés (${cloud.length} items, $pieces pièces) : ${previewNames.join(', ')}${cloud.length > 3 ? "…" : ""}')),
        );
      }
      return;
    }

    // 4) Fallback offline (pas d'Internet, timeout, etc.)
    final parsed = parseVoiceToItems(raw);
    if (parsed.isEmpty) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Je n\'ai rien compris — réessaie en séparant par des virgules ou "et"')),
        );
      }
      return;
    }

    // Appliquer le lexique utilisateur pour améliorer la qualité offline
    final lex = ref.read(userLexiconProvider);
    final normalized = parsed.map((p) => applyLexicon(p, lex)).toList();

    int added = 0;
    final preview = <String>[];
    for (final p in normalized) {
      final item = ShoppingItem(
        id: 'voice-offline-${DateTime.now().millisecondsSinceEpoch}-$added',
        name: p.name,
        unit: p.unit,
        category: p.category,
        isFromMain: !isBasket,
        isFromRecipe: false,
      );
      if (isBasket) {
        for (var i = 0; i < p.qty; i++) {
          ref.read(basketProvider.notifier).add(item);
        }
        final set = {...ref.read(checkedProvider)}..add(item.id);
        ref.read(checkedProvider.notifier).state = set;
      } else {
        final itemForList = item.copyWith(unit: p.unit ?? (p.qty > 1 ? 'x${p.qty}' : null));
        ref.read(plannedListProvider.notifier).state = [
          ...ref.read(plannedListProvider),
          itemForList,
        ];
      }
      if (preview.length < 3) preview.add(p.qty > 1 ? '${p.name} x${p.qty}' : p.name);
      added += p.qty;
    }

    if (context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(normalized.length == 1
            ? 'Ajouté : ${preview.join(', ')}'
            : 'Ajoutés (${normalized.length} items, $added pièces) : ${preview.join(', ')}${normalized.length > 3 ? "…" : ""}')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final ref = this.ref;
    final filter = ref.watch(listFilterProvider);
    final planned = ref.watch(plannedListProvider);
    final checked = ref.watch(checkedProvider);
    final basket = ref.watch(basketProvider);
    final total = ref.watch(estimatedTotalProvider);

    final filtered = planned.where((e) {
      switch (filter) {
        case ListFilter.all:
          return true;
        case ListFilter.mainOnly:
          return e.isFromMain;
        case ListFilter.recipesOnly:
          return e.isFromRecipe;
        case ListFilter.specialsOnly:
          // Phase 1: pas de "spéciales" → false par défaut
          return false;
      }
    }).toList();

    return Scaffold(
      drawer: const _LeftDrawer(),
      appBar: AppBar(
        title: const Text('Courses'),
        centerTitle: true,
        actions: [
          // TODO: Implémenter l'import INBOX quand le système de sync sera prêt
          IconButton(
            tooltip: 'Import INBOX (à venir)',
            icon: const Icon(Icons.move_to_inbox),
            onPressed: () {
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Import INBOX - Fonctionnalité à venir')),
                );
              }
            },
          ),
        ],
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(56),
          child: Padding(
            padding: const EdgeInsets.fromLTRB(12, 0, 12, 8),
            child: Column(
              children: [
                SegmentedButton<int>(
                  segments: const [
                    ButtonSegment(value: 0, icon: Icon(Icons.list_alt), label: Text('Liste')),
                    ButtonSegment(value: 1, icon: Icon(Icons.shopping_basket_outlined), label: Text('Panier')),
                  ],
                  selected: {_pageIndex},
                  onSelectionChanged: (s) {
                    final i = s.first;
                    setState(() => _pageIndex = i);
                    _pageController.animateToPage(
                      i,
                      duration: const Duration(milliseconds: 250),
                      curve: Curves.easeOut,
                    );
                  },
                ),
                const SizedBox(height: 6),
                _DotsIndicator(index: _pageIndex),
              ],
            ),
          ),
        ),
      ),
      body: SafeArea(
        child: Column(
          children: [
            _FiltersBar(), // on garde les chips (Tout / Principale / Recettes / Spéciales)
            Expanded(
              child: PageView(
                controller: _pageController,
                onPageChanged: (i) => setState(() => _pageIndex = i),
                children: [
                  // Page 0 : LISTE PRÉVUE
                  _PlannedColumn(filtered: filtered, checked: checked),
                  // Page 1 : PANIER PRIS
                  _BasketColumn(basket: basket, total: total),
                ],
              ),
            ),
          ],
        ),
      ),
      floatingActionButton: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          // Mic : accès rapide
          Padding(
            padding: const EdgeInsets.only(bottom: 10),
            child: FloatingActionButton.small(
              heroTag: 'fab-mic',
              onPressed: () => _handleQuickVoice(context, ref, pageIndex: _pageIndex),
              child: const Icon(Icons.mic),
            ),
          ),
          // FAB principal (liste ou panier)
          if (_pageIndex == 0) const _FabAddList() else const _FabAddBasket(),
        ],
      ),
      bottomNavigationBar: _BottomBar(),
    );
  }
}

// ——— UI morceaux ———

class _FiltersBar extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final filter = ref.watch(listFilterProvider);
    ChoiceChip buildChip(String label, ListFilter val) {
      final selected = filter == val;
      return ChoiceChip(
        label: Text(label),
        selected: selected,
        onSelected: (_) => ref.read(listFilterProvider.notifier).state = val,
      );
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      child: Wrap(
        spacing: 8,
        children: [
          buildChip('Tout', ListFilter.all),
          buildChip('Principale', ListFilter.mainOnly),
          buildChip('Recettes', ListFilter.recipesOnly),
          buildChip('Spéciales', ListFilter.specialsOnly),
        ],
      ),
    );
  }
}

class _PlannedColumn extends StatelessWidget {
  final List<ShoppingItem> filtered;
  final Set<String> checked;
  const _PlannedColumn({required this.filtered, required this.checked});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const _PlannedHeader(),
        Expanded(child: _PlannedList(filtered: filtered, checked: checked)),
      ],
    );
  }
}

class _PlannedHeader extends StatelessWidget {
  const _PlannedHeader();

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text('Liste prévue', style: Theme.of(context).textTheme.titleMedium),
      subtitle: const Text('Ce que tu comptes acheter'),
      leading: const Icon(Icons.list_alt),
    );
  }
}

class _PlannedList extends ConsumerWidget {
  final List<ShoppingItem> filtered;
  final Set<String> checked;
  const _PlannedList({required this.filtered, required this.checked});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListView.separated(
      padding: const EdgeInsets.only(bottom: 100),
      itemCount: filtered.length,
      separatorBuilder: (_, __) => const Divider(height: 1),
      itemBuilder: (context, i) {
        final item = filtered[i];
        final isChecked = checked.contains(item.id);
        return Dismissible(
          key: ValueKey('planned-${item.id}'),
          direction: DismissDirection.endToStart, // glisser vers la gauche
          dismissThresholds: const {
            DismissDirection.endToStart: 0.35,
          },
          background: Container(
            color: Theme.of(context).colorScheme.primary.withOpacity(0.15),
            alignment: Alignment.centerRight,
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: const Icon(Icons.add_shopping_cart),
          ),
          // 👉 on fait l'action, mais on NE retire PAS l'item de la liste
          confirmDismiss: (_) async {
            final set = {...checked}..add(item.id);
            ref.read(checkedProvider.notifier).state = set;
            ref.read(basketProvider.notifier).add(item);
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('"${item.name}" ajouté au panier')),
            );
            return false; // ne pas dismiss => donc pas besoin de retirer du provider
          },
          child: ListTile(
            leading: Checkbox(
              value: isChecked,
              onChanged: (v) {
                final set = {...checked};
                if (v == true) {
                  set.add(item.id);
                  ref.read(basketProvider.notifier).add(item);
                } else {
                  set.remove(item.id);
                  ref.read(basketProvider.notifier).removeOne(item.id);
                }
                ref.read(checkedProvider.notifier).state = set;
              },
            ),
            title: Text(item.name),
            subtitle: Text([item.brand, item.unit, item.category].where((e) => e != null && e.isNotEmpty).join(' • ')),
            trailing: IconButton(
              icon: const Icon(Icons.arrow_forward),
              onPressed: () {
                final set = {...checked}..add(item.id);
                ref.read(checkedProvider.notifier).state = set;
                ref.read(basketProvider.notifier).add(item);
              },
            ),
            onLongPress: () async {
              final alias = await _promptAlias(context, defaultText: item.name);
              if (alias == null || alias.trim().isEmpty) return;
              ref.read(userLexiconProvider.notifier).upsert(
                LexEntry(
                  alias: alias.trim().toLowerCase(),
                  canonical: item.name,
                  category: item.category,
                  unit: item.unit,
                  defaultQty: 1,
                ),
              );
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Alias "$alias" créé pour "${item.name}"')),
              );
            },
          ),
        );
      },
    );
  }
}

class _BasketColumn extends StatelessWidget {
  final List<BasketLine> basket;
  final double? total;
  const _BasketColumn({required this.basket, required this.total});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _BasketHeader(total: total),
        Expanded(child: _BasketList(basket: basket)),
      ],
    );
  }
}

class _BasketHeader extends StatelessWidget {
  final double? total;
  const _BasketHeader({required this.total});

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text('Pris', style: Theme.of(context).textTheme.titleMedium),
      subtitle: Text('Ce que tu as mis dans le panier'),
      leading: const Icon(Icons.shopping_basket_outlined),
      trailing: (total != null)
          ? Text('${total!.toStringAsFixed(2)} €', style: Theme.of(context).textTheme.titleMedium)
          : const SizedBox.shrink(),
    );
  }
}

class _BasketList extends ConsumerWidget {
  final List<BasketLine> basket;
  const _BasketList({required this.basket});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListView.separated(
      padding: const EdgeInsets.only(bottom: 100),
      itemCount: basket.length,
      separatorBuilder: (_, __) => const Divider(height: 1),
      itemBuilder: (context, i) {
        final line = basket[i];
        return Dismissible(
          key: ValueKey('basket-${line.item.id}'),
          direction: DismissDirection.startToEnd, // glisser vers la droite
          dismissThresholds: const {
            DismissDirection.startToEnd: 0.35,
          },
          background: Container(
            color: Theme.of(context).colorScheme.errorContainer,
            alignment: Alignment.centerLeft,
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: const Icon(Icons.remove_shopping_cart),
          ),
          // 👉 si qty > 1 : on décrémente et on NE dismiss PAS
          // 👉 si qty == 1 : on retire et on dismiss (animation ok)
          confirmDismiss: (_) async {
            if (line.qty > 1) {
              ref.read(basketProvider.notifier).removeOne(line.item.id);
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('"${line.item.name}" −1')),
              );
              return false; // garder la tuile
            } else {
              // qty == 1 → suppression complète + décocher côté liste
              ref.read(basketProvider.notifier).removeOne(line.item.id);
              final set = {...ref.read(checkedProvider)}..remove(line.item.id);
              ref.read(checkedProvider.notifier).state = set;
              return true; // autorise le dismiss (animation + retrait visuel)
            }
          },
          onDismissed: (_) {}, // rien à faire, déjà géré ci‑dessus
          child: ListTile(
            title: Text(line.item.name),
            subtitle: Text([
              if (line.item.unit != null) line.item.unit!,
              if (line.item.unitPrice != null) '${line.item.unitPrice!.toStringAsFixed(2)} €',
            ].join(' • ')),
            leading: CircleAvatar(child: Text('${line.qty}')),
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(icon: const Icon(Icons.remove), onPressed: () => ref.read(basketProvider.notifier).removeOne(line.item.id)),
                IconButton(icon: const Icon(Icons.add), onPressed: () => ref.read(basketProvider.notifier).add(line.item)),
              ],
            ),
          ),
        );
      },
    );
  }
}

class _FabAddList extends ConsumerWidget {
  const _FabAddList({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return FloatingActionButton.extended(
      onPressed: () => _showAddListSheet(context, ref),
      icon: const Icon(Icons.playlist_add),
      label: const Text('Ajouter à la liste'),
    );
  }
}

void _showAddListSheet(BuildContext context, WidgetRef ref) {
  showModalBottomSheet(
    context: context,
    showDragHandle: true,
    builder: (ctx) {
      return SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.search),
              title: const Text('Parcourir produits'),
              onTap: () async {
                Navigator.pop(ctx);
                await showProductsCatalogBottomSheet(context, ref, targetIsBasket: false);
              },
            ),
            ListTile(
              leading: const Icon(Icons.edit),
              title: const Text('Ajouter manuellement'),
              onTap: () async {
                Navigator.pop(ctx);
                final data = await _promptManualItem(context, title: 'Ajouter à la liste');
                if (data == null) return;
                final item = ShoppingItem(
                  id: 'manual-${DateTime.now().millisecondsSinceEpoch}',
                  name: data.name,
                  unit: data.unit?.isEmpty == true ? null : data.unit,
                  category: data.category?.isEmpty == true ? 'Divers' : data.category!,
                  isFromMain: true,
                  isFromRecipe: false,
                );
                ref.read(plannedListProvider.notifier).state = [
                  ...ref.read(plannedListProvider),
                  item,
                ];
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('"${item.name}" ajouté à la liste')),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.mic_none),
              title: const Text('Ajout vocal'),
              onTap: () async {
                Navigator.pop(ctx);
                final text = await VoiceInput.capture(context);
                if (text == null || text.isEmpty) return;
                // Pré-remplir le dialogue manuel avec le texte reconnu
                final data = await _promptManualItem(context, title: 'Ajouter à la liste');
                // Si tu préfères auto-créer sans confirmation, remplace par création directe.
                if (data == null) {
                  // fallback: auto avec seulement le nom vocal
                  final item = ShoppingItem(
                    id: 'voice-${DateTime.now().millisecondsSinceEpoch}',
                    name: text,
                    unit: null,
                    category: 'Divers',
                    isFromMain: true,
                  );
                  ref.read(plannedListProvider.notifier).state = [
                    ...ref.read(plannedListProvider),
                    item,
                  ];
                } else {
                  final item = ShoppingItem(
                    id: 'manual-${DateTime.now().millisecondsSinceEpoch}',
                    name: data.name.isNotEmpty ? data.name : text,
                    unit: data.unit?.isEmpty == true ? null : data.unit,
                    category: data.category?.isEmpty == true ? 'Divers' : data.category!,
                    isFromMain: true,
                  );
                  ref.read(plannedListProvider.notifier).state = [
                    ...ref.read(plannedListProvider),
                    item,
                  ];
                }
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Ajouté à la liste')),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.qr_code_scanner),
              title: const Text('Scanner un code‑barres'),
              onTap: () async {
                Navigator.pop(ctx);
                final item = await showBarcodeScanSheet(context);
                if (item != null) {
                  ref.read(plannedListProvider.notifier).add(
                    item.copyWith(isFromMain: true, isFromRecipe: false),
                  );
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('"${item.name}" ajouté à la liste')),
                  );
                } else {
                  final data = await _promptManualItem(context, title: 'Produit non reconnu — ajouter à la liste');
                  if (data == null) return;
                  final manual = ShoppingItem(
                    id: 'manual-${DateTime.now().millisecondsSinceEpoch}',
                    name: data.name,
                    unit: data.unit?.isEmpty == true ? null : data.unit,
                    category: data.category?.isEmpty == true ? 'Divers' : data.category!,
                    isFromMain: true,
                    isFromRecipe: false,
                  );
                  ref.read(plannedListProvider.notifier).add(manual);
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Ajout manuel à la liste')),
                  );
                }
              },
            ),
            ListTile(
              leading: const Icon(Icons.sync_alt),
              title: const Text('Depuis ChefIA Cuisine'),
              subtitle: const Text('Importer ingrédients d\'une recette'),
              onTap: () {
                Navigator.pop(ctx);
                ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Bientôt disponible')));
              },
            ),
          ],
        ),
      );
    },
  );
}

class _FabAddBasket extends ConsumerWidget {
  const _FabAddBasket({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return FloatingActionButton.extended(
      onPressed: () => _showAddBasketSheet(context, ref),
      icon: const Icon(Icons.add_shopping_cart),
      label: const Text('Ajouter au panier'),
    );
  }
}

void _showAddBasketSheet(BuildContext context, WidgetRef ref) {
  showModalBottomSheet(
    context: context,
    showDragHandle: true,
    builder: (ctx) {
      return SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.search),
              title: const Text('Parcourir produits'),
              onTap: () async {
                Navigator.pop(ctx);
                await showProductsCatalogBottomSheet(context, ref, targetIsBasket: true);
              },
            ),
            ListTile(
              leading: const Icon(Icons.edit_note),
              title: const Text('Ajout manuel'),
              onTap: () async {
                Navigator.pop(ctx);
                final data = await _promptManualItem(context, title: 'Ajouter au panier');
                if (data == null) return;
                final item = ShoppingItem(
                  id: 'manual-${DateTime.now().millisecondsSinceEpoch}',
                  name: data.name,
                  unit: data.unit?.isEmpty == true ? null : data.unit,
                  category: data.category?.isEmpty == true ? 'Divers' : data.category!,
                  isFromMain: false,
                  isFromRecipe: false,
                );
                // ajouter au panier + cocher côté liste
                ref.read(basketProvider.notifier).add(item);
                final set = {...ref.read(checkedProvider)}..add(item.id);
                ref.read(checkedProvider.notifier).state = set;
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('"${item.name}" ajouté au panier')),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.photo_camera_outlined),
              title: const Text('Scan photo produit'),
              onTap: () {
                Navigator.pop(ctx);
                ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Bientôt disponible')));
              },
            ),
            ListTile(
              leading: const Icon(Icons.qr_code_scanner),
              title: const Text('Scan code-barres'),
              onTap: () async {
                Navigator.pop(ctx);
                final item = await showBarcodeScanSheet(context);
                if (item != null) {
                  // connu → on ajoute direct
                  ref.read(basketProvider.notifier).add(item);
                  final set = {...ref.read(checkedProvider)}..add(item.id);
                  ref.read(checkedProvider.notifier).state = set;
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('"${item.name}" ajouté au panier')),
                  );
                } else {
                  // inconnu → fallback saisie manuelle rapide
                  final data = await _promptManualItem(context, title: 'Produit non reconnu — ajouter manuellement');
                  if (data == null) return;
                  final manual = ShoppingItem(
                    id: 'manual-${DateTime.now().millisecondsSinceEpoch}',
                    name: data.name,
                    unit: data.unit?.isEmpty == true ? null : data.unit,
                    category: data.category?.isEmpty == true ? 'Divers' : data.category!,
                    isFromMain: false,
                    isFromRecipe: false,
                  );
                  ref.read(basketProvider.notifier).add(manual);
                  final set = {...ref.read(checkedProvider)}..add(manual.id);
                  ref.read(checkedProvider.notifier).state = set;
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Ajout manuel au panier')),
                  );
                }
              },
            ),
            ListTile(
              leading: const Icon(Icons.mic),
              title: const Text('Ajout vocal'),
              onTap: () async {
                Navigator.pop(ctx);
                final text = await VoiceInput.capture(context);
                if (text == null || text.isEmpty) return;

                final data = await _promptManualItem(context, title: 'Ajouter au panier');
                if (data == null) {
                  final item = ShoppingItem(
                    id: 'voice-${DateTime.now().millisecondsSinceEpoch}',
                    name: text,
                    category: 'Divers',
                    isFromMain: false,
                    isFromRecipe: false,
                  );
                  ref.read(basketProvider.notifier).add(item);
                  final set = {...ref.read(checkedProvider)}..add(item.id);
                  ref.read(checkedProvider.notifier).state = set;
                } else {
                  final item = ShoppingItem(
                    id: 'manual-${DateTime.now().millisecondsSinceEpoch}',
                    name: data.name.isNotEmpty ? data.name : text,
                    unit: data.unit?.isNotEmpty == true ? data.unit : null,
                    category: data.category?.isNotEmpty == true ? data.category! : 'Divers',
                    isFromMain: false,
                    isFromRecipe: false,
                  );
                  ref.read(basketProvider.notifier).add(item);
                  final set = {...ref.read(checkedProvider)}..add(item.id);
                  ref.read(checkedProvider.notifier).state = set;
                }
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Ajouté au panier')),
                );
              },
            ),
          ],
        ),
      );
    },
  );
}

class _ManualItemData {
  final String name;
  final String? unit;
  final String? category;
  _ManualItemData(this.name, this.unit, this.category);
}

Future<String?> _promptAlias(BuildContext context, {String? defaultText}) async {
  final ctrl = TextEditingController(text: defaultText ?? '');
  final formKey = GlobalKey<FormState>();
  return showDialog<String>(
    context: context,
    builder: (ctx) => AlertDialog(
      title: const Text('Associer un alias'),
      content: Form(
        key: formKey,
        child: TextFormField(
          controller: ctrl,
          autofocus: true,
          decoration: const InputDecoration(
            labelText: 'Alias (ex. "pq", "sopalin")',
          ),
          validator: (v) =>
              (v == null || v.trim().isEmpty) ? 'Alias requis' : null,
        ),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Annuler')),
        FilledButton(
          onPressed: () {
            if (formKey.currentState?.validate() != true) return;
            Navigator.pop(ctx, ctrl.text.trim().toLowerCase());
          },
          child: const Text('Enregistrer'),
        ),
      ],
    ),
  );
}

Future<_ManualItemData?> _promptManualItem(BuildContext context, {required String title}) async {
  final nameCtrl = TextEditingController();
  final unitCtrl = TextEditingController();
  final catCtrl = TextEditingController();
  final formKey = GlobalKey<FormState>();

  return showDialog<_ManualItemData>(
    context: context,
    builder: (ctx) => AlertDialog(
      title: Text(title),
      content: Form(
        key: formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextFormField(
              controller: nameCtrl,
              decoration: const InputDecoration(
                labelText: 'Produit',
                hintText: 'ex. Lait demi-écrémé',
              ),
              autofocus: true,
              validator: (v) => (v == null || v.trim().isEmpty) ? 'Nom requis' : null,
            ),
            const SizedBox(height: 8),
            TextFormField(
              controller: unitCtrl,
              decoration: const InputDecoration(
                labelText: 'Unité (optionnel)',
                hintText: 'ex. 1 L, 500 g',
              ),
            ),
            const SizedBox(height: 8),
            TextFormField(
              controller: catCtrl,
              decoration: const InputDecoration(
                labelText: 'Catégorie (optionnel)',
                hintText: 'ex. Épicerie, Frais',
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Annuler')),
        FilledButton(
          onPressed: () {
            if (formKey.currentState?.validate() != true) return;
            Navigator.pop(ctx, _ManualItemData(nameCtrl.text.trim(), unitCtrl.text.trim(), catCtrl.text.trim()));
          },
          child: const Text('Ajouter'),
        ),
      ],
    ),
  );
}

// ----- Helper pour construire le payload garde-manger -----

Map<String, dynamic> buildPantryPayload(WidgetRef ref) {
  final basket = ref.read(basketProvider);
  return {
    "source": "ChefIA Courses",
    "timestamp": DateTime.now().toIso8601String(),
    "items": basket.map((l) => {
      "id": l.item.id,
      "name": l.item.name,
      "brand": l.item.brand,
      "unit": l.item.unit,
      "category": l.item.category,
      "qty": l.qty,
      "unitPrice": l.item.unitPrice,
      "origin": l.item.isFromRecipe ? "recipe" : (l.item.isFromMain ? "main" : "special"),
    }).toList(),
  };
}

// ----- Fonction d'envoi broadcast vers ChefIA Cuisine -----

Future<void> sendBasketToCuisineBroadcast(Map<String, dynamic> payload) async {
  final jsonStr = jsonEncode(payload);
  final intent = AndroidIntent(
    action: 'com.chefia.cuisine.IMPORT_PANTRY',
    package: 'com.chefia.cuisine', // ← remplace par le package exact de l'app Cuisine
    arguments: {'payload': jsonStr}, // ou payload_b64 si tu préfères
  );
  try {
    await intent.sendBroadcast();
  } catch (e) {
    // Fallback silencieux si le broadcast échoue
    print('Broadcast vers Cuisine échoué: $e');
  }
}

class _BottomBar extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(12, 8, 12, 12),
        child: Row(
          children: [
            Expanded(
              child: OutlinedButton.icon(
                onPressed: () {
                  ref.read(basketProvider.notifier).clear();
                  ref.read(checkedProvider.notifier).state = <String>{};
                },
                icon: const Icon(Icons.restart_alt),
                label: const Text('Réinitialiser'),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: FilledButton.icon(
                onPressed: () async {
                  final payload = buildPantryPayload(ref);
                  final jsonStr = const JsonEncoder.withIndent('  ').convert(payload);

                  await showDialog(
                    context: context,
                    builder: (ctx) => AlertDialog(
                      title: const Text('Envoyer au garde-manger'),
                      content: SizedBox(
                        width: double.maxFinite,
                        child: SingleChildScrollView(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text('Articles : ${payload["items"].length}'),
                              const SizedBox(height: 8),
                              SelectableText(jsonStr, style: const TextStyle(fontFamily: 'monospace', fontSize: 12)),
                            ],
                          ),
                        ),
                      ),
                      actions: [
                        TextButton(
                          onPressed: () {
                            Clipboard.setData(ClipboardData(text: jsonStr));
                            Navigator.pop(ctx);
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(content: Text('Payload copié (clipboard)')),
                            );
                          },
                          child: const Text('Copier JSON'),
                        ),
                        FilledButton.icon(
                          onPressed: () async {
                            Navigator.pop(ctx);
                            
                            // 🔥 Vider le panier + décocher tout, immédiatement après envoi
                            ref.read(basketProvider.notifier).clear();
                            ref.read(checkedProvider.notifier).state = <String>{};
                            
                            // 🚀 Sync bidirectionnelle vers ChefIA Cuisine
                            
                            // 1) Offline & silencieux (n'ouvre pas l'app Cuisine)
                            await sendBasketToCuisineBroadcast(payload);
                            
                            // 2) Option visible (deeplink) si tu veux ouvrir Cuisine en plus :
                            final jsonStr = const JsonEncoder.withIndent('  ').convert(payload);
                            final uri = Uri.parse('chefiacuisine://pantry/import?data=${base64Url.encode(utf8.encode(jsonStr))}');
                            try {
                              await launchUrl(uri, mode: LaunchMode.externalApplication);
                            } catch (e) {
                              // Fallback si le deeplink échoue
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(content: Text('Deeplink échoué: $e')),
                              );
                            }
                            
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(content: Text('Envoyé au garde-manger (mock)')),
                            );
                          },
                          icon: const Icon(Icons.send),
                          label: const Text('Envoyer'),
                        ),
                      ],
                    ),
                  );
                },
                icon: const Icon(Icons.inventory_2),
                label: const Text('Envoyer au garde-manger'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _DotsIndicator extends StatelessWidget {
  final int index;
  const _DotsIndicator({required this.index});

  @override
  Widget build(BuildContext context) {
    final inactive = Theme.of(context).colorScheme.outlineVariant;
    final active = Theme.of(context).colorScheme.primary;
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: List.generate(2, (i) {
        final selected = i == index;
        return AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          margin: const EdgeInsets.symmetric(horizontal: 4, vertical: 8),
          height: 6,
          width: selected ? 18 : 6,
          decoration: BoxDecoration(
            color: selected ? active : inactive,
            borderRadius: BorderRadius.circular(999),
          ),
        );
      }),
    );
  }
}

class _LeftDrawer extends StatelessWidget {
  const _LeftDrawer();

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Drawer(
      child: SafeArea(
        child: ListView(
          padding: const EdgeInsets.symmetric(vertical: 8),
          children: [
            ListTile(
              leading: const Icon(Icons.add_circle_outline),
              title: const Text('Nouvelle liste'),
              subtitle: const Text('Créer/voir tes listes'),
              onTap: () {
                Navigator.of(context).pop();
                context.push('/lists');
              },
            ),
            const Divider(height: 1),
            ListTile(
              leading: const Icon(Icons.receipt_long),
              title: const Text('Comparer panier / ticket'),
              subtitle: const Text('Photo du ticket, rapprochement'),
              onTap: () {
                Navigator.of(context).pop();
                context.push('/compare');
              },
            ),
            const Divider(height: 1),
            ListTile(
              leading: const Icon(Icons.settings_outlined),
              title: const Text('Paramètres'),
              onTap: () {
                Navigator.of(context).pop();
                context.push('/settings');
              },
            ),
            const SizedBox(height: 16),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: Text(
                'Astuce : glisse de gauche à droite pour ouvrir le menu.',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.outline,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```
