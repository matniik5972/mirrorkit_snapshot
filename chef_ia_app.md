# Snapshot – chef_ia_app – 2025-09-15T23:19:23
**Snapshot-Of:** `6482085b719a5dd2e6e053ebcd5c4b3ae03bd177`
**Generated:** 2025-09-15T23:19:23
**Files:** 103

## Index
- `chef_ia_app/pubspec.yaml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/pubspec.yaml)
- `chef_ia_app/android/app/src/debug/AndroidManifest.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/debug/AndroidManifest.xml)
- `chef_ia_app/android/app/src/main/AndroidManifest.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/AndroidManifest.xml)
- `chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/MainActivity.kt` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/MainActivity.kt)
- `chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/bridge/PantryBridgePlugin.kt` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/bridge/PantryBridgePlugin.kt)
- `chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/bridge/PantryBroadcastReceiver.kt` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/bridge/PantryBroadcastReceiver.kt)
- `chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/bridge/PantryProvider.kt` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/bridge/PantryProvider.kt)
- `chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/pantry/CuisineImportReceiver.kt` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/pantry/CuisineImportReceiver.kt)
- `chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/pantry/CuisineImportWorker.kt` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/pantry/CuisineImportWorker.kt)
- `chef_ia_app/android/app/src/main/res/drawable/launch_background.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/res/drawable/launch_background.xml)
- `chef_ia_app/android/app/src/main/res/drawable-v21/launch_background.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/res/drawable-v21/launch_background.xml)
- `chef_ia_app/android/app/src/main/res/values/styles.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/res/values/styles.xml)
- `chef_ia_app/android/app/src/main/res/values-night/styles.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/main/res/values-night/styles.xml)
- `chef_ia_app/android/app/src/profile/AndroidManifest.xml` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/android/app/src/profile/AndroidManifest.xml)
- `chef_ia_app/lib/agents/pantry_agent_cache.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/agents/pantry_agent_cache.dart)
- `chef_ia_app/lib/agents/pantry_silent_agent.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/agents/pantry_silent_agent.dart)
- `chef_ia_app/lib/core/clock.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/clock.dart)
- `chef_ia_app/lib/core/deeplinks.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/deeplinks.dart)
- `chef_ia_app/lib/core/dev_logger.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/dev_logger.dart)
- `chef_ia_app/lib/core/events.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/events.dart)
- `chef_ia_app/lib/core/event_bus.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/event_bus.dart)
- `chef_ia_app/lib/core/grace_policy.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/grace_policy.dart)
- `chef_ia_app/lib/core/logging.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/logging.dart)
- `chef_ia_app/lib/core/orchestrator.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/orchestrator.dart)
- `chef_ia_app/lib/core/tips_engine.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/tips_engine.dart)
- `chef_ia_app/lib/core/models/recipe.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/models/recipe.dart)
- `chef_ia_app/lib/core/models/recipe_step_vis.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/models/recipe_step_vis.dart)
- `chef_ia_app/lib/core/models/user_models.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/models/user_models.dart)
- `chef_ia_app/lib/core/prompt/prompt_builder.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/prompt/prompt_builder.dart)
- `chef_ia_app/lib/core/services/context_builder.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/services/context_builder.dart)
- `chef_ia_app/lib/core/stores/assistant_state.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/stores/assistant_state.dart)
- `chef_ia_app/lib/core/stores/user_context_provider.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/stores/user_context_provider.dart)
- `chef_ia_app/lib/core/style/style_engine.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/style/style_engine.dart)
- `chef_ia_app/lib/core/theme/theme_controller.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/theme/theme_controller.dart)
- `chef_ia_app/lib/core/utils/duration_parser.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/core/utils/duration_parser.dart)
- `chef_ia_app/lib/data/kitchen_store.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/data/kitchen_store.dart)
- `chef_ia_app/lib/data/user_prefs_store.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/data/user_prefs_store.dart)
- `chef_ia_app/lib/data/user_profile_store.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/data/user_profile_store.dart)
- `chef_ia_app/lib/domain/models/product.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/domain/models/product.dart)
- `chef_ia_app/lib/domain/models/shopping_item.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/domain/models/shopping_item.dart)
- `chef_ia_app/lib/features/pantry/home_boot_example.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/home_boot_example.dart)
- `chef_ia_app/lib/features/pantry/inbox_import.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/inbox_import.dart)
- `chef_ia_app/lib/features/pantry/inbox_import_riverpod.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/inbox_import_riverpod.dart)
- `chef_ia_app/lib/features/pantry/pantry_sender.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/pantry_sender.dart)
- `chef_ia_app/lib/features/pantry/advice/pantry_advisor_provider.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/advice/pantry_advisor_provider.dart)
- `chef_ia_app/lib/features/pantry/providers/pantry_prefs_provider.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/providers/pantry_prefs_provider.dart)
- `chef_ia_app/lib/features/pantry/screens/pantry_body.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/screens/pantry_body.dart)
- `chef_ia_app/lib/features/pantry/state/household_provider.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/state/household_provider.dart)
- `chef_ia_app/lib/features/pantry/state/pantry_provider.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/state/pantry_provider.dart)
- `chef_ia_app/lib/features/pantry/state/pantry_state.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/state/pantry_state.dart)
- `chef_ia_app/lib/features/pantry/widgets/pantry_advisory_banner.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/widgets/pantry_advisory_banner.dart)
- `chef_ia_app/lib/features/pantry/widgets/pantry_app_bar.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/widgets/pantry_app_bar.dart)
- `chef_ia_app/lib/features/pantry/widgets/pantry_effects.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/widgets/pantry_effects.dart)
- `chef_ia_app/lib/features/pantry/widgets/pantry_empty_state.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/widgets/pantry_empty_state.dart)
- `chef_ia_app/lib/features/pantry/widgets/pantry_fab.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/widgets/pantry_fab.dart)
- `chef_ia_app/lib/features/pantry/widgets/pantry_filters_bar.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/widgets/pantry_filters_bar.dart)
- `chef_ia_app/lib/features/pantry/widgets/pantry_item_tile.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/widgets/pantry_item_tile.dart)
- `chef_ia_app/lib/features/pantry/widgets/pantry_list_view.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/widgets/pantry_list_view.dart)
- `chef_ia_app/lib/features/pantry/widgets/pantry_optimized_image.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/widgets/pantry_optimized_image.dart)
- `chef_ia_app/lib/features/pantry/widgets/pantry_smart_empty_state.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/features/pantry/widgets/pantry_smart_empty_state.dart)
- `chef_ia_app/lib/models/household.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/models/household.dart)
- `chef_ia_app/lib/models/pantry_advisory.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/models/pantry_advisory.dart)
- `chef_ia_app/lib/models/pantry_item.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/models/pantry_item.dart)
- `chef_ia_app/lib/models/recipe_option.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/models/recipe_option.dart)
- `chef_ia_app/lib/models/mappers/shopping_item_mapper.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/models/mappers/shopping_item_mapper.dart)
- `chef_ia_app/lib/providers/grace_policy_provider.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/providers/grace_policy_provider.dart)
- `chef_ia_app/lib/providers/pantry_prefs_provider.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/providers/pantry_prefs_provider.dart)
- `chef_ia_app/lib/providers/pantry_silent_agent_provider.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/providers/pantry_silent_agent_provider.dart)
- `chef_ia_app/lib/screens/home_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/screens/home_screen.dart)
- `chef_ia_app/lib/screens/user_prefs_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/screens/user_prefs_screen.dart)
- `chef_ia_app/lib/screens/user_profile_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/screens/user_profile_screen.dart)
- `chef_ia_app/lib/services/ai_service.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/ai_service.dart)
- `chef_ia_app/lib/services/ai/advisory_engine.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/ai/advisory_engine.dart)
- `chef_ia_app/lib/services/ai/advisor_factory.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/ai/advisor_factory.dart)
- `chef_ia_app/lib/services/ai/cloud_client.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/ai/cloud_client.dart)
- `chef_ia_app/lib/services/ai/cloud_pantry_advisor_v2.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/ai/cloud_pantry_advisor_v2.dart)
- `chef_ia_app/lib/services/ai/local_pantry_advisor_v2.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/ai/local_pantry_advisor_v2.dart)
- `chef_ia_app/lib/services/ai/pantry_advisor_v2.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/ai/pantry_advisor_v2.dart)
- `chef_ia_app/lib/services/chat/pantry_chat.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/chat/pantry_chat.dart)
- `chef_ia_app/lib/services/notify/ai_notifier.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/notify/ai_notifier.dart)
- `chef_ia_app/lib/services/notify/bg_tasks.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/notify/bg_tasks.dart)
- `chef_ia_app/lib/services/storage/pantry_store.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/services/storage/pantry_store.dart)
- `chef_ia_app/lib/ui/responsive.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/responsive.dart)
- `chef_ia_app/lib/ui/a11y/a11y_semantics.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/a11y/a11y_semantics.dart)
- `chef_ia_app/lib/ui/layout/containers.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/layout/containers.dart)
- `chef_ia_app/lib/ui/screens/barcode_scan_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/barcode_scan_screen.dart)
- `chef_ia_app/lib/ui/screens/logs_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/logs_screen.dart)
- `chef_ia_app/lib/ui/screens/onboarding_intro_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/onboarding_intro_screen.dart)
- `chef_ia_app/lib/ui/screens/onboarding_questionnaire_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/onboarding_questionnaire_screen.dart)
- `chef_ia_app/lib/ui/screens/pantry_chat_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/pantry_chat_screen.dart)
- `chef_ia_app/lib/ui/screens/pantry_export_import.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/pantry_export_import.dart)
- `chef_ia_app/lib/ui/screens/pantry_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/pantry_screen.dart)
- `chef_ia_app/lib/ui/screens/pantry_settings_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/pantry_settings_screen.dart)
- `chef_ia_app/lib/ui/screens/recipe_detail_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/recipe_detail_screen.dart)
- `chef_ia_app/lib/ui/screens/recipe_runner_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/recipe_runner_screen.dart)
- `chef_ia_app/lib/ui/screens/tester_feedback_screen.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/screens/tester_feedback_screen.dart)
- `chef_ia_app/lib/ui/widgets/bottom_gutter.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/widgets/bottom_gutter.dart)
- `chef_ia_app/lib/ui/widgets/input_bar.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/widgets/input_bar.dart)
- `chef_ia_app/lib/ui/widgets/message_bubble.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/widgets/message_bubble.dart)
- `chef_ia_app/lib/ui/widgets/pantry_advice_chips.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/widgets/pantry_advice_chips.dart)
- `chef_ia_app/lib/ui/widgets/pantry_chat_bubble.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/widgets/pantry_chat_bubble.dart)
- `chef_ia_app/lib/ui/widgets/recipe_card.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/ui/widgets/recipe_card.dart)
- `chef_ia_app/lib/utils/recipe_parser.dart` — [RAW](https://raw.githubusercontent.com/matniik5972/mirrorkit_snapshot/main/files/chef_ia_app/lib/utils/recipe_parser.dart)

---
## Fichiers

### chef_ia_app/pubspec.yaml
```yaml
name: chef_ia_app
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.8.1

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter
  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  flutter_riverpod: ^2.5.1
  crypto: ^3.0.3
  http: ^1.5.0
  shared_preferences: ^2.2.2
  uuid: ^4.5.1
  mobile_scanner: ^5.1.1
  path_provider: ^2.1.3
  share_plus: ^10.0.2
  image_picker: ^1.1.2
  speech_to_text: ^7.3.0
  flutter_tts: ^3.8.3
  google_generative_ai: ^0.4.6
  intl: ^0.19.0
  flutter_local_notifications: ^17.1.2
  timezone: ^0.9.2
  android_intent_plus: ^5.0.2
  url_launcher: ^6.3.0
  app_links: ^3.4.5
  go_router: ^14.2.0
  hive: ^2.2.3
  hive_flutter: ^1.1.0
  shared_models:
    path: ../packages/shared_models
  
dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^6.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  assets:
    - assets/testing/synonyms.json
    - assets/images/background.png
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package
    
```

### chef_ia_app/android/app/src/debug/AndroidManifest.xml
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### chef_ia_app/android/app/src/main/AndroidManifest.xml
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.RECORD_AUDIO"/>
    <application
        android:label="chef_ia_app"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        
        <!-- ContentProvider pour stocker l'inbox d'articles reçus -->
        <provider
            android:name=".bridge.PantryProvider"
            android:authorities="${applicationId}.pantry.provider"
            android:exported="false" />

        <!-- Récepteur d'Intent (hors ligne, sans UI) -->
        <receiver
            android:name=".bridge.PantryBroadcastReceiver"
            android:exported="true">
          <intent-filter>
            <!-- Action que l'app Courses enverra -->
            <action android:name="com.chefia.PANTRY_ADD_ITEMS" />
            <category android:name="android.intent.category.DEFAULT" />
          </intent-filter>
        </receiver>
        
        <!-- Receiver pour importer le panier depuis Courses -->
        <receiver
            android:name=".pantry.CuisineImportReceiver"
            android:exported="false">
          <intent-filter>
            <action android:name="com.chefia.cuisine.IMPORT_PANTRY" />
          </intent-filter>
        </receiver>
        
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
            
            <!-- Deep Links pour l'explorateur -->
            <intent-filter android:autoVerify="true">
                <action android:name="android.intent.action.VIEW"/>
                <category android:name="android.intent.category.DEFAULT"/>
                <category android:name="android.intent.category.BROWSABLE"/>
                <!-- schéma custom : chefia://app/pantry -->
                <data android:scheme="chefia" android:host="app" />
                <!-- liens web : https://chefia.app/pantry -->
                <data android:scheme="https" android:host="chefia.app" />
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

```

### chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/MainActivity.kt
```text
package com.example.chef_ia_app

import android.content.Intent
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel

class MainActivity : FlutterActivity() {

    private val CHANNEL = "app/deeplink"

    private fun extractPathFromIntent(intent: Intent?): String? {
        val uri = intent?.data ?: return null
        // on veut /pantry, /create, etc.
        val path = uri.path ?: "/"
        val query = uri.query?.let { "?$it" } ?: ""
        return "$path$query"
    }

    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)

        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL)
            .invokeMethod("initialLink", extractPathFromIntent(intent))
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        setIntent(intent)
        val path = extractPathFromIntent(intent)
        if (path != null) {
            flutterEngine?.let { engine ->
                MethodChannel(engine.dartExecutor.binaryMessenger, CHANNEL)
                    .invokeMethod("newLink", path)
            }
        }
    }
}

```

### chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/bridge/PantryBridgePlugin.kt
```text
package com.example.chef_ia_app.bridge

import android.database.Cursor
import android.net.Uri
import io.flutter.embedding.engine.plugins.FlutterPlugin
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel

class PantryBridgePlugin : FlutterPlugin, MethodChannel.MethodCallHandler {
  private lateinit var channel: MethodChannel
  private lateinit var ctx: android.content.Context

  override fun onAttachedToEngine(binding: FlutterPlugin.FlutterPluginBinding) {
    ctx = binding.applicationContext
    channel = MethodChannel(binding.binaryMessenger, "chefia/pantry_bridge")
    channel.setMethodCallHandler(this)
  }

  override fun onMethodCall(call: MethodCall, result: MethodChannel.Result) {
    when (call.method) {
      "consumeInbox" -> {
        try {
          val authority = "${ctx.packageName}.pantry.provider"
          val uri = Uri.parse("content://$authority/${PantryProvider.PATH}")
          val cur: Cursor? = ctx.contentResolver.query(uri, null, null, null, "id ASC")
          val items = ArrayList<Map<String, Any?>>()
          cur?.use {
            val idxName = it.getColumnIndex("name")
            val idxQty  = it.getColumnIndex("qty")
            val idxUnit = it.getColumnIndex("unit")
            val idxBar  = it.getColumnIndex("barcode")
            val idxCat  = it.getColumnIndex("category")
            val idxTs   = it.getColumnIndex("created_at")
            while (it.moveToNext()) {
              val m = hashMapOf<String, Any?>(
                "name" to it.getString(idxName),
                "qty" to if (idxQty >= 0 && !it.isNull(idxQty)) it.getDouble(idxQty) else null,
                "unit" to if (idxUnit >= 0 && !it.isNull(idxUnit)) it.getString(idxUnit) else null,
                "barcode" to if (idxBar >= 0 && !it.isNull(idxBar)) it.getString(idxBar) else null,
                "category" to if (idxCat >= 0 && !it.isNull(idxCat)) it.getString(idxCat) else null,
                "createdAtMs" to if (idxTs >= 0 && !it.isNull(idxTs)) it.getLong(idxTs) else null
              )
              items.add(m)
            }
          }
          // vide la table
          ctx.contentResolver.delete(uri, null, null)
          result.success(items)
        } catch (e: Throwable) {
          result.error("ERR", e.message, null)
        }
      }
      else -> result.notImplemented()
    }
  }

  override fun onDetachedFromEngine(binding: FlutterPlugin.FlutterPluginBinding) {
    channel.setMethodCallHandler(null)
  }
}





```

### chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/bridge/PantryBroadcastReceiver.kt
```text
package com.example.chef_ia_app.bridge

import android.content.*
import android.net.Uri
import org.json.JSONObject
import org.json.JSONArray

class PantryBroadcastReceiver : BroadcastReceiver() {
  override fun onReceive(context: Context, intent: Intent) {
    if (intent.action != "com.chefia.PANTRY_ADD_ITEMS") return
    val payload = intent.getStringExtra("payload") ?: return
    try {
      val json = JSONObject(payload)
      val items = json.optJSONArray("items") ?: JSONArray()
      if (items.length() == 0) return

      val authority = "${context.packageName}.pantry.provider"
      val uri = Uri.parse("content://$authority/${PantryProvider.PATH}")

      // Prépare un bulkInsert
      val list = ArrayList<ContentValues>(items.length())
      val now = System.currentTimeMillis()
      for (i in 0 until items.length()) {
        val it = items.getJSONObject(i)
        val cv = ContentValues().apply {
          put("name", it.optString("name"))
          if (it.has("qty")) put("qty", it.optDouble("qty"))
          put("unit", it.optString("unit", null))
          put("barcode", it.optString("barcode", null))
          put("category", it.optString("category", null))
          put("created_at", now)
        }
        list.add(cv)
      }
      context.contentResolver.bulkInsert(uri, list.toTypedArray())
      // Fin : à ce stade, les articles sont stockés localement, sans ouvrir l'app.
    } catch (_: Throwable) { /* ignore */ }
  }
}





```

### chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/bridge/PantryProvider.kt
```text
package com.example.chef_ia_app.bridge

import android.content.*
import android.database.Cursor
import android.database.SQLException
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
import android.net.Uri

class PantryProvider : ContentProvider() {

  companion object {
    private const val DB_NAME = "chefia_bridge.db"
    private const val DB_VER = 1
    private const val TABLE = "inbox_pantry"
    // Schéma très simple pour l'inbox
    private const val CREATE = """
      CREATE TABLE IF NOT EXISTS $TABLE (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        qty REAL,
        unit TEXT,
        barcode TEXT,
        category TEXT,
        created_at INTEGER NOT NULL
      );
    """
    const val PATH = "pantry_inbox"
  }

  private lateinit var db: SQLiteDatabase
  private lateinit var uriMatcher: UriMatcher
  private lateinit var authority: String

  override fun onCreate(): Boolean {
    authority = "${context!!.packageName}.pantry.provider"
    uriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
      addURI(authority, PATH, 1)
    }
    val helper = object : SQLiteOpenHelper(context, DB_NAME, null, DB_VER) {
      override fun onCreate(db: SQLiteDatabase) { db.execSQL(CREATE) }
      override fun onUpgrade(db: SQLiteDatabase, oldV: Int, newV: Int) {}
    }
    db = helper.writableDatabase
    return true
  }

  override fun insert(uri: Uri, values: ContentValues?): Uri? {
    if (uriMatcher.match(uri) != 1) throw IllegalArgumentException("Bad URI")
    val id = db.insert(TABLE, null, values)
    if (id <= 0) throw SQLException("Insert failed")
    context?.contentResolver?.notifyChange(uri, null)
    return ContentUris.withAppendedId(uri, id)
  }

  override fun bulkInsert(uri: Uri, values: Array<out ContentValues>): Int {
    if (uriMatcher.match(uri) != 1) throw IllegalArgumentException("Bad URI")
    db.beginTransaction()
    var count = 0
    try {
      for (cv in values) {
        if (db.insert(TABLE, null, cv) > 0) count++
      }
      db.setTransactionSuccessful()
    } finally { db.endTransaction() }
    context?.contentResolver?.notifyChange(uri, null)
    return count
  }

  override fun query(uri: Uri, proj: Array<out String>?, sel: String?, selArgs: Array<out String>?, sort: String?): Cursor? {
    if (uriMatcher.match(uri) != 1) throw IllegalArgumentException("Bad URI")
    return db.query(TABLE, proj, sel, selArgs, null, null, sort)
  }

  override fun delete(uri: Uri, where: String?, args: Array<out String>?): Int {
    if (uriMatcher.match(uri) != 1) throw IllegalArgumentException("Bad URI")
    val n = db.delete(TABLE, where, args)
    if (n > 0) context?.contentResolver?.notifyChange(uri, null)
    return n
  }

  override fun update(uri: Uri, v: ContentValues?, w: String?, a: Array<out String>?): Int = 0
  override fun getType(uri: Uri): String? = "vnd.android.cursor.dir/vnd.${context!!.packageName}.pantry_inbox"
}





```

### chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/pantry/CuisineImportReceiver.kt
```text
package com.example.chef_ia_app.pantry

import android.content.*
import android.util.Base64
import androidx.work.*
import java.util.concurrent.TimeUnit

class CuisineImportReceiver : BroadcastReceiver() {
  override fun onReceive(context: Context, intent: Intent) {
    val rawJson = intent.getStringExtra("payload")
      ?: intent.getStringExtra("payload_b64")?.let {
        String(Base64.decode(it, Base64.DEFAULT))
      } ?: return

    val data = Data.Builder().putString("payload", rawJson).build()
    val req = OneTimeWorkRequestBuilder<CuisineImportWorker>()
      .setInputData(data)
      .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 10, TimeUnit.SECONDS)
      .build()
    WorkManager.getInstance(context).enqueue(req)
  }
}







```

### chef_ia_app/android/app/src/main/kotlin/com/example/chef_ia_app/pantry/CuisineImportWorker.kt
```text
package com.example.chef_ia_app.pantry

import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import org.json.JSONObject

class CuisineImportWorker(appContext: Context, params: WorkerParameters)
  : CoroutineWorker(appContext, params) {

  override suspend fun doWork(): Result {
    val prefs = applicationContext.getSharedPreferences("chefia_cuisine", Context.MODE_PRIVATE)
    val payload = inputData.getString("payload") ?: return Result.failure()

    try {
      val obj = JSONObject(payload)
      if (!obj.has("items")) return Result.failure()
    } catch (_: Exception) {
      return Result.failure()
    }

    // INBOX pour le côté Dart de Cuisine (qui mettra à jour le garde‑manger)
    val key = "inbox_from_courses_v1"
    val set = prefs.getStringSet(key, mutableSetOf())?.toMutableSet() ?: mutableSetOf()
    set.add(payload)
    prefs.edit().putStringSet(key, set).apply()
    return Result.success()
  }
}







```

### chef_ia_app/android/app/src/main/res/drawable/launch_background.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### chef_ia_app/android/app/src/main/res/drawable-v21/launch_background.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

```

### chef_ia_app/android/app/src/main/res/values/styles.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### chef_ia_app/android/app/src/main/res/values-night/styles.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

```

### chef_ia_app/android/app/src/profile/AndroidManifest.xml
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

```

### chef_ia_app/lib/agents/pantry_agent_cache.dart
```dart
// lib/agents/pantry_agent_cache.dart
import 'dart:convert';
import 'package:crypto/crypto.dart';

class AdvisoryCacheEntry {
  final String key; // hash du contexte
  final DateTime ts;
  final List<Map<String, dynamic>> advisories; // JSON sérialisable
  const AdvisoryCacheEntry({required this.key, required this.ts, required this.advisories});
  bool isFresh(Duration ttl) => DateTime.now().difference(ts) <= ttl;
}

class PantryAgentCache {
  AdvisoryCacheEntry? _last;

  String makeKey(Map<String, Object?> ctx) {
    final s = jsonEncode(ctx);
    return sha256.convert(utf8.encode(s)).toString();
  }

  AdvisoryCacheEntry? getIfFresh(String key, {Duration ttl = const Duration(minutes: 5)}) {
    final e = _last;
    if (e == null) return null;
    if (e.key != key) return null;
    return e.isFresh(ttl) ? e : null;
  }

  void put(String key, List<Map<String, dynamic>> advisories) {
    _last = AdvisoryCacheEntry(key: key, ts: DateTime.now(), advisories: advisories);
  }
}












```

### chef_ia_app/lib/agents/pantry_silent_agent.dart
```dart
// lib/agents/pantry_silent_agent.dart
import 'dart:async';
import 'package:uuid/uuid.dart';
import 'package:chef_ia_app/core/event_bus.dart';
import 'package:chef_ia_app/core/events.dart';
import 'package:chef_ia_app/core/logging.dart';
import 'package:chef_ia_app/core/clock.dart';
import 'package:chef_ia_app/core/grace_policy.dart';
import 'package:chef_ia_app/agents/pantry_agent_cache.dart';
import 'package:chef_ia_app/models/pantry_item.dart';
import 'package:chef_ia_app/models/pantry_advisory.dart';
import 'package:chef_ia_app/services/ai/pantry_advisor_v2.dart';
import 'package:chef_ia_app/services/ai/local_pantry_advisor_v2.dart';
import 'package:chef_ia_app/services/ai/cloud_pantry_advisor_v2.dart';
import 'package:chef_ia_app/services/ai/cloud_client.dart';

typedef Json = Map<String, dynamic>;

class PantrySilentAgent {
  final EventBus _bus;
  final PantryAdvisor _local;
  final PantryAdvisor _cloud;
  final GracePolicy _grace;
  final PantryAgentCache _cache;
  final Clock _clock;
  final Duration cacheTtl;

  StreamSubscription<Json>? _sub;
  final List<PantryItem> _items = [];

  PantrySilentAgent({
    EventBus? bus,
    required PantryAdvisor local,
    required PantryAdvisor cloud,
    required GracePolicy grace,
    Clock clock = const SystemClock(),
    PantryAgentCache? cache,
    this.cacheTtl = const Duration(minutes: 5),
  })  : _bus = bus ?? EventBus(),
        _local = local,
        _cloud = cloud,
        _grace = grace,
        _cache = cache ?? PantryAgentCache(),
        _clock = clock;

  void start() {
    _sub ??= _bus.stream.listen(_onEvent);
    logEvent(module: 'agent.silent', event: 'started');
  }

  void stop() async {
    await _sub?.cancel();
    _sub = null;
    logEvent(module: 'agent.silent', event: 'stopped');
  }

  // Heuristique simple : si prefs.useCloud == true ET beaucoup d'items → cloud, sinon local
  bool _preferCloud(PantryUserPrefs prefs, int count) {
    if (!prefs.useCloud) return false;
    if (count >= 50) return true; // seuil simple ; ajustable
    return false;
  }

  void _onEvent(Json e) {
    try {
      final type = e['type'] as String? ?? '';
      final payload = (e['payload'] as Map?)?.cast<String, dynamic>() ?? const <String, dynamic>{};

      switch (type) {
        case 'pantry.item.added':
          _applyAdd(payload);
          break;
        case 'pantry.item.updated':
          _applyUpdate(payload);
          break;
        case 'pantry.item.deleted':
          _applyDelete(payload);
          break;
        case 'pantry.expiry.tick': // tick planifié (quotidien)
        case 'pantry.chat.requested': // demande implicite de conseils
          _recomputeAndPublish(payload);
          break;
        default:
          break;
      }
    } catch (err) {
      logEvent(module: 'agent.silent', event: 'event_error', level: 'ERROR', fields: {'error': err.toString()});
    }
  }

  void _applyAdd(Json p) {
    final it = _itemFromPayload(p);
    if (it == null) return;
    _items.removeWhere((x) => x.id == it.id);
    _items.add(it);
  }

  void _applyUpdate(Json p) => _applyAdd(p);

  void _applyDelete(Json p) {
    final id = p['id'] as String?;
    if (id == null) return;
    _items.removeWhere((x) => x.id == id);
  }

  PantryItem? _itemFromPayload(Json p) {
    try {
      // payload minimal : id, name?, category, expiry?, quantity?, unit?
      return PantryItem(
        id: p['id'] as String,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        name: p['name'] as String? ?? (p['barcode'] as String? ?? 'item'),
        category: p['category'] as String? ?? 'Autre',
        quantity: (p['quantity'] as num?)?.toDouble() ?? 1.0,
        unit: p['unit'] as String? ?? 'pc',
        expiry: (p['expiry'] as String?) != null ? DateTime.tryParse(p['expiry'] as String) : null,
        barcode: p['barcode'] as String?,
        lastUpdate: DateTime.now(),
        photos: (p['photos'] as List?)?.map((e) => e.toString()).toList() ?? const [],
        tags: (p['tags'] as List?)?.map((e) => e.toString()).toList() ?? const [],
        note: p['note'] as String?,
      );
    } catch (_) {
      return null;
    }
  }

  void _recomputeAndPublish(Json payload) {
    final prefs = _extractPrefs(payload);
    final ctxKey = _cache.makeKey({
      'count': _items.length,
      'useCloud': prefs.useCloud,
      'topK': prefs.topK,
      'grace': _grace.graceByCategory,
      // on pourrait inclure un hash des ids + expiries pour plus de précision
    });

    final cached = _cache.getIfFresh(ctxKey, ttl: cacheTtl);
    if (cached != null) {
      logEvent(module: 'agent.silent', event: 'cache_hit', fields: {'advisories': cached.advisories.length});
      _publishAdvisories(cached.advisories, fromCache: true);
      return;
    }

    final state = PantryState(items: List.unmodifiable(_items));
    final advisor = _preferCloud(prefs, _items.length) ? _cloud : _local;
    final t0 = DateTime.now();
    final result = advisor.advise(state, prefs); // sync by design (fallback géré côté cloud)
    final ms = DateTime.now().difference(t0).inMilliseconds;

    final asJson = result.map((a) => a.toJson()).toList();
    _cache.put(ctxKey, asJson);

    logEvent(module: 'agent.silent', event: 'advise_ready', fields: {
      'advisor': advisor == _cloud ? 'cloud' : 'local',
      'ms': ms,
      'items': _items.length,
      'advisories': result.length,
    });

    _publishAdvisories(asJson);
  }

  PantryUserPrefs _extractPrefs(Json payload) {
    // payload peut surcharger des prefs ponctuelles (ex: topK)
    final useCloud = (payload['useCloud'] as bool?) ?? true;
    final privacy = (payload['privacyCloud'] as bool?) ?? true;
    final topK = (payload['topK'] as int?) ?? 10;
    return PantryUserPrefs(useCloud: useCloud, privacyCloud: privacy, topK: topK);
  }

  void _publishAdvisories(List<Json> advisories, {bool fromCache = false}) {
    _bus.publish(PantryEvent(
      id: const Uuid().v4(),
      ts: DateTime.now(),
      type: 'pantry.advisory.ready',
      payload: {
        'fromCache': fromCache,
        'count': advisories.length,
        'advisories': advisories,
      },
      schemaVersion: 1,
    ).toJson());
  }
}

```

### chef_ia_app/lib/core/clock.dart
```dart
// lib/core/clock.dart
abstract class Clock {
  DateTime now();
}

class SystemClock implements Clock {
  const SystemClock();
  @override
  DateTime now() => DateTime.now();
}

class FixedClock implements Clock {
  DateTime _now;
  FixedClock(this._now);
  void set(DateTime t) => _now = t;
  @override
  DateTime now() => _now;
}












```

### chef_ia_app/lib/core/deeplinks.dart
```dart
// lib/core/deeplinks.dart
Uri buildPantryDeepLink(String filter) =>
    Uri.parse('app://chefia/pantry?filter=$filter');

String? parsePantryFilter(Uri? uri) {
  if (uri == null) return null;
  if (uri.host != 'chefia' && uri.scheme != 'app') return null;
  if (!uri.path.contains('pantry')) return null;
  return uri.queryParameters['filter'];
}












```

### chef_ia_app/lib/core/dev_logger.dart
```dart
import 'dart:convert';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';

// Nécessaire aux hooks
// ignore: depend_on_referenced_packages
import 'package:flutter/foundation.dart';

class DevLogEntry {
  final DateTime ts;
  final String level; // INFO/WARN/ERROR
  final String tag;
  final String message;
  final String? stack;
  final Map<String, dynamic>? meta;

  DevLogEntry({
    required this.ts,
    required this.level,
    required this.tag,
    required this.message,
    this.stack,
    this.meta,
  });

  Map<String, dynamic> toJson() => {
        'ts': ts.toIso8601String(),
        'level': level,
        'tag': tag,
        'message': message,
        if (stack != null) 'stack': stack,
        if (meta != null) 'meta': meta,
      };

  @override
  String toString() =>
      "[${ts.toIso8601String()}][$level][$tag] $message${stack != null ? "\n$stack" : ""}";
}

class DevLogger {
  static final List<DevLogEntry> _logs = [];
  static bool betaMode = false; // Par défaut désactivé

  // === API simple ===
  static void info(String tag, String message, {Map<String, dynamic>? meta, bool betaOnly = false}) {
    if (betaOnly && !betaMode) return; // n'enregistre que si betaMode actif
    _add(DevLogEntry(ts: DateTime.now(), level: "INFO", tag: tag, message: message, meta: meta));
  }

  static void warn(String tag, String message, {Map<String, dynamic>? meta, bool betaOnly = false}) {
    if (betaOnly && !betaMode) return; // n'enregistre que si betaMode actif
    _add(DevLogEntry(ts: DateTime.now(), level: "WARN", tag: tag, message: message, meta: meta));
  }

  static void error(String tag, String message, {Object? err, StackTrace? stack, Map<String, dynamic>? meta, bool betaOnly = false}) {
    if (betaOnly && !betaMode) return; // n'enregistre que si betaMode actif
    _add(DevLogEntry(
      ts: DateTime.now(),
      level: "ERROR",
      tag: tag,
      message: message,
      stack: stack?.toString(),
      meta: {
        if (meta != null) ...meta,
        if (err != null) 'error': err.toString(),
      },
    ));
  }

  static List<DevLogEntry> getLogs() => List.unmodifiable(_logs);
  static void clear() => _logs.clear();

  // === Export fichiers ===
  static Future<File> _writeTextFile() async {
    final dir = await getApplicationDocumentsDirectory();
    final f = File("${dir.path}/chefia_logs.txt");
    final buf = StringBuffer();
    for (final e in _logs) {
      buf.writeln(e.toString());
    }
    await f.writeAsString(buf.toString());
    return f;
  }

  static Future<File> _writeJsonFile() async {
    final dir = await getApplicationDocumentsDirectory();
    final f = File("${dir.path}/chefia_logs.json");
    await f.writeAsString(jsonEncode(_logs.map((e) => e.toJson()).toList()));
    return f;
  }

  static Future<void> shareLogs({bool asJson = true}) async {
    final file = asJson ? await _writeJsonFile() : await _writeTextFile();
    await Share.shareXFiles([XFile(file.path)], text: "Logs ChefIA (bêta-test)");
  }

  // === Hook globaux ===
  static void hookFlutterErrors() {
    // Flutter layer
    FlutterError.onError = (details) {
      DevLogger.error("Flutter", "FlutterError", err: details.exception, stack: details.stack);
      FlutterError.presentError(details);
    };
    // Dart isolates
    PlatformDispatcher.instance.onError = (error, stack) {
      DevLogger.error("Dart", "Uncaught zone error", err: error, stack: stack);
      return true; // handled
    };
  }

  // === interne ===
  static void _add(DevLogEntry e) {
    _logs.add(e);
    // Print en console (utile en dev)
    // ignore: avoid_print
    print(e.toString());
  }
}

```

### chef_ia_app/lib/core/events.dart
```dart
// lib/core/events.dart

/// Clés d'événements centralisées pour éviter les typos
abstract class AppEvents {
  static const pantryItemsChanged = 'pantry.items.changed';
  static const pantryItemAdded = 'pantry.item.added';
  static const pantryItemUpdated = 'pantry.item.updated';
  static const pantryItemDeleted = 'pantry.item.deleted';
  static const pantryItemRestored = 'pantry.item.restored';
  static const pantryItemsPurged = 'pantry.items.purged';
  static const pantryItemsImported = 'pantry.items.imported';
  static const pantryStorageUpserted = 'pantry.storage.upserted';
}

class PantryEvent {
  final String id; // uuid
  final DateTime ts;
  final String type; // e.g. pantry.item.updated
  final Map<String, dynamic> payload; // JSON stable versionné
  final int schemaVersion;

  PantryEvent({
    required this.id,
    required this.ts,
    required this.type,
    required this.payload,
    this.schemaVersion = 1,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'ts': ts.toIso8601String(),
    'type': type,
    'schemaVersion': schemaVersion,
    'payload': payload,
  };
}

// ============================================================
// LEGACY EVENT MODEL (compat old tips_engine / runner)
// ============================================================
abstract class AppEvent {
  final String type;
  final Map<String, dynamic> payload;
  const AppEvent(this.type, this.payload);

  // helpers communs (accès style .message dans l'ancien code)
  String? get message => payload['message'] as String?;
  String? get stepId  => payload['stepId'] as String?;
  String? get risk    => payload['risk'] as String?;
}

class StepStarted extends AppEvent {
  StepStarted(String stepId) : super('step.started', {'stepId': stepId});
}

class RiskDetected extends AppEvent {
  RiskDetected(String stepId, String risk)
      : super('risk.detected', {'stepId': stepId, 'risk': risk});
}

class TipsRequested extends AppEvent {
  TipsRequested(String stepId, String question)
      : super('tips.requested', {'stepId': stepId, 'question': question});
  String? get question => payload['question'] as String?;
}

class TipsPushed extends AppEvent {
  TipsPushed(String stepId, String message)
      : super('tips.pushed', {'stepId': stepId, 'message': message});
}

class AdviceEvent extends AppEvent {
  AdviceEvent(String message) : super('advice.event', {'message': message});
}

// Événements typés (compat unifiée)
class PantryChanged extends AppEvent {
  PantryChanged(Map<String, dynamic> payload) : super('pantry.changed', payload);
}
class PantryAdvisoryReady extends AppEvent {
  PantryAdvisoryReady(Map<String, dynamic> payload) : super('pantry.advisory.ready', payload);
}
class ChefIntentCook extends AppEvent {
  ChefIntentCook(Map<String, dynamic> payload) : super('chef.intent.cook', payload);
}
class CoursesIntentAdd extends AppEvent {
  CoursesIntentAdd(Map<String, dynamic> payload) : super('courses.intent.add', payload);
}

/// Conversion Map -> AppEvent (pour EventBus.on('type'))
AppEvent? appEventFrom(Map<String, dynamic> e) {
  final t = e['type'] as String? ?? '';
  final p = (e['payload'] as Map?)?.cast<String, dynamic>() ?? const <String, dynamic>{};
  switch (t) {
    case 'step.started':
      final id = p['stepId'] as String?;
      return id == null ? null : StepStarted(id);
    case 'risk.detected':
      final id = p['stepId'] as String?;
      final r  = p['risk'] as String?;
      return (id == null || r == null) ? null : RiskDetected(id, r);
    case 'tips.requested':
      final id = p['stepId'] as String?;
      final q  = p['question'] as String?;
      return (id == null || q == null) ? null : TipsRequested(id, q);
    case 'tips.pushed':
      final id = p['stepId'] as String?;
      final m  = p['message'] as String?;
      return (id == null || m == null) ? null : TipsPushed(id, m);
    case 'advice.event':
      final m = p['message'] as String?;
      return m == null ? null : AdviceEvent(m);
    case 'pantry.changed': return PantryChanged(p);
    case 'pantry.advisory.ready': return PantryAdvisoryReady(p);
    case 'chef.intent.cook': return ChefIntentCook(p);
    case 'courses.intent.add': return CoursesIntentAdd(p);
  }
  return null;
}

```

### chef_ia_app/lib/core/event_bus.dart
```dart
import 'dart:async';
import 'events.dart';

typedef EventListener = void Function(AppEvent e);

// Les classes d'événements sont maintenant dans events.dart

class EventBus {
  /// Singleton compat : `EventBus()` renvoie la même instance partout.
  factory EventBus() => _I;
  EventBus._internal();
  static final EventBus _I = EventBus._internal();

  // Diffusion globale
  final _controller = StreamController<AppEvent>.broadcast();
  Stream<AppEvent> get stream => _controller.stream;
  Stream<AppEvent> on(String type) => _controller.stream.where((e) => e.type == type);

  // Listeners callback par type
  final _map = <String, List<EventListener>>{};

  void Function() onListener(String type, EventListener f) {
    final ls = _map.putIfAbsent(type, () => <EventListener>[]);
    ls.add(f);
    return () { ls.remove(f); };
  }

  // ===== API unifiée =====
  // 1) emit(AppEvent)          2) emit('type', payload)         3) publish(Map)
  void emit(dynamic typeOrEvent, [Map<String, dynamic>? payload]) {
    AppEvent? e;
    if (typeOrEvent is AppEvent) {
      e = typeOrEvent;
    } else if (typeOrEvent is String) {
      e = _GenericAppEvent(typeOrEvent, payload ?? const {});
    } else if (typeOrEvent is Map<String, dynamic>) {
      // compat publish(Map) → typed si possible
      e = appEventFrom(typeOrEvent) ??
          _GenericAppEvent(
            (typeOrEvent['type'] as String?) ?? 'app.unknown',
            (typeOrEvent['payload'] as Map<String, dynamic>?) ?? const {},
          );
    }
    if (e == null) return;
    // callbacks
    final ls = _map[e.type];
    if (ls != null) {
      for (final f in List<EventListener>.from(ls)) { f(e); }
    }
    // stream global
    _controller.add(e);
  }

  // alias rétro-compat publish(Map|AppEvent)
  void publish(dynamic any) => emit(any);

  // alias explicite pour (String, Map)
  void emitType(String type, Map<String, dynamic> payload) => emit(type, payload);
}

// Classe concrète pour les AppEvent génériques
class _GenericAppEvent extends AppEvent {
  _GenericAppEvent(String type, Map<String, dynamic> payload) : super(type, payload);
}

```

### chef_ia_app/lib/core/grace_policy.dart
```dart
// lib/core/grace_policy.dart
class GracePolicy {
  final Map<String, int> graceByCategory;
  final int defaultGraceDays;

  const GracePolicy({
    this.graceByCategory = const {
      'frais': 2,
      'charcuterie': 0,
      'viande': 0,
      'poisson': 0,
      'épicerie': 7,
      'boissons': 7,
      'surgelé': 30,
    },
    this.defaultGraceDays = 2,
  });

  int graceFor(String? category) {
    if (category == null || category.isEmpty) return defaultGraceDays;
    final key = category.toLowerCase();
    return graceByCategory[key] ?? defaultGraceDays;
  }
}












```

### chef_ia_app/lib/core/logging.dart
```dart
// lib/core/logging.dart
import 'dart:convert';
import 'dart:developer' as dev;

void logEvent({
  required String module,
  required String event,
  Map<String, Object?> fields = const {},
  String level = 'INFO',
}) {
  final payload = {
    'ts': DateTime.now().toIso8601String(),
    'level': level,
    'module': module,
    'event': event,
    'fields': fields,
  };
  dev.log(jsonEncode(payload), name: module);
}












```

### chef_ia_app/lib/core/orchestrator.dart
```dart
import 'dart:async';
import 'event_bus.dart';

/// Modèle minimal d'une étape
class RecipeStep {
  final String id;
  final String title;
  final String instruction; // texte court pour l'étape
  final List<String> deps;  // ids des étapes prérequises
  final int? timerSec;      // si l'étape contient un chrono (facultatif)
  final List<String> risks; // risques connus (ex: "risque d'attacher")

  const RecipeStep({
    required this.id,
    required this.title,
    required this.instruction,
    this.deps = const [],
    this.timerSec,
    this.risks = const [],
  });
}

/// Graphe simple (DAG) de recette
class RecipeGraph {
  final Map<String, RecipeStep> nodes;
  final List<String> start; // ids des premières étapes (sans dépendances)
  const RecipeGraph({required this.nodes, required this.start});
}

/// Orchestrateur : avance/recul, timers, events
class RecipeOrchestrator {
  final EventBus _bus = EventBus();

  late final RecipeGraph _graph;
  final List<String> _ordered; // ordre compilé (simple: topologique/linéaire)
  int _idx = -1;

  Timer? _timer;
  int _remaining = 0;

  RecipeOrchestrator._(this._graph, this._ordered);

  /// Compile un ordre simple (si deps vides -> ordre donné)
  static RecipeOrchestrator fromLinear(List<RecipeStep> steps) {
    final nodes = {for (final s in steps) s.id: s};
    final start = steps.isNotEmpty ? [steps.first.id] : <String>[];
    return RecipeOrchestrator._(RecipeGraph(nodes: nodes, start: start), steps.map((s) => s.id).toList());
  }

  /// Ex: si tu veux un DAG plus tard, tu pourras ajouter fromGraph(RecipeGraph g)
  static RecipeOrchestrator fromGraph(RecipeGraph g, List<String> topoOrder) {
    return RecipeOrchestrator._(g, topoOrder);
  }

  RecipeStep? get currentStep =>
      (_idx >= 0 && _idx < _ordered.length) ? _graph.nodes[_ordered[_idx]] : null;

  List<RecipeStep> get allSteps => _ordered.map((id) => _graph.nodes[id]!).toList();
  int get currentIndex => _idx;
  int get total => _ordered.length;
  int get remainingTimerSec => _remaining;

  void start() {
    if (_ordered.isEmpty) return;
    _idx = 0;
    _onEnterStep();
  }

  void next() {
    _cancelTimerIfAny();
    if (_idx < _ordered.length - 1) {
      _idx++;
      _onEnterStep();
    }
  }

  void previous() {
    _cancelTimerIfAny();
    if (_idx > 0) {
      _idx--;
      _onEnterStep();
    }
  }

  void _onEnterStep() {
    final step = currentStep;
    if (step == null) return;

    _bus.emit(StepStarted(step.id));

    // Déclenchement de risques connus → tips automatiques potentiels côté TipsEngine
    for (final r in step.risks) {
      _bus.emit(RiskDetected(step.id, r));
    }

    // Timer éventuel
    if (step.timerSec != null && step.timerSec! > 0) {
      _remaining = step.timerSec!;
      _timer = Timer.periodic(const Duration(seconds: 1), (t) {
        _remaining -= 1;
        _bus.emit(TimerTick(step.id, _remaining));
        if (_remaining <= 0) {
          t.cancel();
          _timer = null;
          _bus.emit(StepCompleted(step.id));
        }
      });
    } else {
      // Étape sans timer → attend action utilisateur (Suivant)
    }
  }

  void _cancelTimerIfAny() {
    _timer?.cancel();
    _timer = null;
    _remaining = 0;
  }

  void dispose() {
    _cancelTimerIfAny();
  }
}


```

### chef_ia_app/lib/core/tips_engine.dart
```dart
import 'dart:async';
import 'event_bus.dart';
import 'events.dart';
import 'package:chef_ia_app/services/ai_service.dart'; // accès à AiService (Gemini)
import 'dev_logger.dart';
import 'services/context_builder.dart';

/// Moteur de conseils "sidecar"
/// - écoute les événements
/// - pousse des TipsPushed(stepId, tip)
/// Plus tard, tu pourras brancher un LLM ici.
class TipsEngine {
  final EventBus _bus = EventBus();
  final List<StreamSubscription> _subs = [];
  
  final _ai = AiService();            // client LLM
  final bool _useCloud = true;        // interrupteur pour activer/désactiver le cloud

  TipsEngine() {
    // Écouter tous les types d'événements legacy
    _subs.add(_bus.on('step.started').listen(_onEvent));
    _subs.add(_bus.on('risk.detected').listen(_onEvent));
    _subs.add(_bus.on('tips.requested').listen(_onEvent));
  }

  void _onEvent(dynamic e) {
    if (e is! AppEvent) return;
    if (e is StepStarted) {
      // Exemple de conseils automatiques au démarrage d'une étape
      final stepId = e.stepId ?? 'unknown';
      _bus.emit(TipsPushed(stepId, "Pense à préparer ton poste de travail proprement."));
    }
    if (e is RiskDetected) {
      // Règles simples, tu enrichiras au fur et à mesure
      final m = <String, String>{
        "attacher": "Remue régulièrement et baisse le feu si nécessaire.",
        "brûler": "Surveille la coloration et utilise un fond épais.",
        "grumeaux": "Incorpore progressivement et fouette sans t'arrêter.",
      };
      final risk = e.risk?.toLowerCase() ?? '';
      final tip = m.entries.firstWhere(
        (kv) => risk.contains(kv.key),
        orElse: () => const MapEntry("", ""),
      ).value;
      if (tip.isNotEmpty) {
        final stepId = e.stepId ?? 'unknown';
        _bus.emit(TipsPushed(stepId, '⚠️ Risque détecté: ${e.risk}. Astuce: $tip'));
      }
      
      // (optionnel) renfort LLM pour un tip ciblé sur le risque
      final stepId = e.stepId ?? 'unknown';
      _answerWithLLM(stepId: stepId, question: 'Risque détecté: ${e.risk}. Donne UNE astuce concrète et très courte.');
    }
    if (e is TipsRequested) {
      // Réponse cloud courte et contextuelle
      final stepId = e.stepId ?? 'unknown';
      final question = e.question ?? 'Comment procéder ?';
      _answerWithLLM(stepId: stepId, question: question);
    }
  }
  
  /// Nettoie et formate les réponses de l'IA
  String _sanitize(String s) {
    if (s.isEmpty) return s;
    // nettoie éventuels balises/markdown trop verbeux
    s = s.replaceAll(RegExp(r'```+[^`]*```+', dotAll: true), '');
    s = s.replaceAll(RegExp(r'\s+'), ' ').trim();
    // limite la longueur pour ne pas polluer l'UI conseils
    if (s.length > 240) s = s.substring(0, 240).trimRight() + '…';
    return s;
  }
  
  /// Génère une réponse intelligente via l'IA cloud
  Future<void> _answerWithLLM({required String stepId, required String question}) async {
    if (!_useCloud) {
      EventBus().emit(TipsPushed(stepId, 'Astuce: $question → coupe avec un couteau bien affûté et un mouvement de balancier.'));
      return;
    }

    final contextJson = await ContextBuilder.buildContextJson(); // ⬅️ NEW

    final prompt = """Tu es ChefIA. Réponds en 1 à 2 phrases max, concrètes et actionnables.
Contexte JSON:
$contextJson
Étape (id): $stepId
Question: "$question"
Règles:
- Si allergie ou contrainte d'équipement: propose une alternative.
- Adapte le niveau au profil (débutant/intermédiaire/expert).
- ⚠️ Utilise cet emoji uniquement si sécurité en jeu.
- Va droit au but (verbes d'action).
- Pas de listes, pas d'emojis sauf ⚠️ si pertinent.""";

    try {
      // TODO: Implémenter une vraie méthode d'IA pour les conseils
      // Pour l'instant, on utilise un fallback local
      final tip = "Astuce: $question → fais simple et précis, étape par étape.";
      EventBus().emit(TipsPushed(stepId, tip));
      
      // Log bêta détaillé
      DevLogger.info("TipsEngine", "Fallback local activé - question: '$question'", betaOnly: true);
    } catch (e) {
      // fallback discret
      EventBus().emit(TipsPushed(stepId, "Astuce: $question → fais simple et précis, étape par étape."));
      
      // Log de l'erreur pour le debugging
      DevLogger.error("TipsEngine", "LLM indisponible, fallback local", err: e, stack: StackTrace.current);
    }
  }

  void dispose() {
    for (final sub in _subs) {
      sub.cancel();
    }
  }

  // Nouvelle méthode pour déclencher des conseils lors du changement d'étape
  void onStepStarted(String stepDescription) {
    // Générer un conseil automatique basé sur la description de l'étape
    final tip = _generateStepTip(stepDescription);
    if (tip != null) {
      // Émettre l'événement AdviceEvent pour les toasts
      EventBus().emit(AdviceEvent(tip));
    }
  }

  String? _generateStepTip(String stepDescription) {
    stepDescription = stepDescription.toLowerCase();
    
    // Conseils contextuels basés sur le contenu de l'étape
    if (stepDescription.contains("coupe") || stepDescription.contains("découpe")) {
      return "🔪 Conseil: Gardez vos doigts repliés lors de la découpe pour éviter les coupures";
    }
    if (stepDescription.contains("four") || stepDescription.contains("cuisson")) {
      return "🔥 Conseil: Préchauffez toujours votre four pour une cuisson uniforme";
    }
    if (stepDescription.contains("mélange") || stepDescription.contains("fouetter")) {
      return "🥄 Conseil: Mélangez délicatement pour préserver la texture et l'air";
    }
    if (stepDescription.contains("repos") || stepDescription.contains("attendre")) {
      return "⏰ Conseil: Le repos permet aux saveurs de se développer, soyez patient";
    }
    if (stepDescription.contains("sel") || stepDescription.contains("assaisonner")) {
      return "🧂 Conseil: Salez progressivement et goûtez à chaque fois";
    }
    
    return null;
  }
}

// AdviceEvent est maintenant défini dans events.dart

```

### chef_ia_app/lib/core/models/recipe.dart
```dart
// lib/core/models/recipe.dart
import 'package:flutter/foundation.dart';

@immutable
class Ingredient {
  final String name;       // ex: "farine T55"
  final double? quantity;  // ex: 250
  final String? unit;      // ex: "g"
  const Ingredient({required this.name, this.quantity, this.unit});
}

@immutable
class InstructionStep {
  final int index;         // 0-based
  final String text;       // phrase lisible
  final int? minutes;      // durée estimée
  const InstructionStep({required this.index, required this.text, this.minutes});
}

enum RecipeType { unknown, everyday, refined, gourmet }

@immutable
class Recipe {
  final String id;
  final String title;
  final RecipeType type;       // classification simple
  final int? prepMinutes;      // préparation
  final int? cookMinutes;      // cuisson
  final int? serves;           // nb de personnes
  final List<Ingredient> ingredients;
  final List<InstructionStep> steps;

  const Recipe({
    required this.id,
    required this.title,
    this.type = RecipeType.unknown,
    this.prepMinutes,
    this.cookMinutes,
    this.serves,
    this.ingredients = const [],
    this.steps = const [],
  });

  int get totalMinutes => (prepMinutes ?? 0) + (cookMinutes ?? 0);
}

```

### chef_ia_app/lib/core/models/recipe_step_vis.dart
```dart
class RecipeStepVis {
  final String title;
  final String instruction;
  final int? timerSec; // null si pas de chrono
  const RecipeStepVis({required this.title, required this.instruction, this.timerSec});
}

```

### chef_ia_app/lib/core/models/user_models.dart
```dart


/// Profil utilisateur complet avec identité et personnalisation
class UserProfile {
  final String userId;
  final String? displayName;
  final UserStyle style;
  final FoodPreferences foodPrefs;
  final HealthConstraints health;
  final UserConsents consents;
  final DateTime createdAt;
  final DateTime lastActive;

  const UserProfile({
    required this.userId,
    this.displayName,
    required this.style,
    required this.foodPrefs,
    required this.health,
    required this.consents,
    required this.createdAt,
    required this.lastActive,
  });

  factory UserProfile.defaultFor(String userId) {
    return UserProfile(
      userId: userId,
      style: const UserStyle(),
      foodPrefs: const FoodPreferences(),
      health: const HealthConstraints(),
      consents: const UserConsents(),
      createdAt: DateTime.now(),
      lastActive: DateTime.now(),
    );
  }

  UserProfile copyWith({
    String? displayName,
    UserStyle? style,
    FoodPreferences? foodPrefs,
    HealthConstraints? health,
    UserConsents? consents,
    DateTime? lastActive,
  }) {
    return UserProfile(
      userId: userId,
      displayName: displayName ?? this.displayName,
      style: style ?? this.style,
      foodPrefs: foodPrefs ?? this.foodPrefs,
      health: health ?? this.health,
      consents: consents ?? this.consents,
      createdAt: createdAt,
      lastActive: lastActive ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toJson() => {
    'user_id': userId,
    'display_name': displayName,
    'style': style.toJson(),
    'food_prefs': foodPrefs.toJson(),
    'health': health.toJson(),
    'consents': consents.toJson(),
    'created_at': createdAt.toIso8601String(),
    'last_active': lastActive.toIso8601String(),
  };

  factory UserProfile.fromJson(Map<String, dynamic> json) {
    return UserProfile(
      userId: json['user_id'] as String,
      displayName: json['display_name'] as String?,
      style: UserStyle.fromJson(json['style'] as Map<String, dynamic>),
      foodPrefs: FoodPreferences.fromJson(json['food_prefs'] as Map<String, dynamic>),
      health: HealthConstraints.fromJson(json['health'] as Map<String, dynamic>),
      consents: UserConsents.fromJson(json['consents'] as Map<String, dynamic>),
      createdAt: DateTime.parse(json['created_at'] as String),
      lastActive: DateTime.parse(json['last_active'] as String),
    );
  }
}

/// Style de communication et personnalisation
class UserStyle {
  final String preferredPronouns; // "tu" | "vous"
  final String styleNotes; // Résumé du ton (local-only)
  final List<String> signatureWords; // Mots récurrents
  final String greetingStyle; // "décontracté" | "formel" | "complice"
  final bool useEmojis;
  final int averageSentenceLength; // 1-5 (court à long)

  const UserStyle({
    this.preferredPronouns = 'tu',
    this.styleNotes = 'Ton détendu et direct',
    this.signatureWords = const [],
    this.greetingStyle = 'décontracté',
    this.useEmojis = true,
    this.averageSentenceLength = 3,
  });

  String toStyleHint() {
    final tone = styleNotes.isNotEmpty ? styleNotes : 'Ton détendu et clair';
    final emoji = useEmojis ? ', quelques emojis' : '';
    final length = averageSentenceLength <= 2 ? ', phrases courtes' : 
                   averageSentenceLength >= 4 ? ', phrases détaillées' : '';
    
    return '$tone$emoji$length';
  }

  Map<String, dynamic> toJson() => {
    'preferred_pronouns': preferredPronouns,
    'style_notes': styleNotes,
    'signature_words': signatureWords,
    'greeting_style': greetingStyle,
    'use_emojis': useEmojis,
    'average_sentence_length': averageSentenceLength,
  };

  factory UserStyle.fromJson(Map<String, dynamic> json) {
    return UserStyle(
      preferredPronouns: json['preferred_pronouns'] as String? ?? 'tu',
      styleNotes: json['style_notes'] as String? ?? 'Ton détendu et direct',
      signatureWords: List<String>.from(json['signature_words'] ?? []),
      greetingStyle: json['greeting_style'] as String? ?? 'décontracté',
      useEmojis: json['use_emojis'] as bool? ?? true,
      averageSentenceLength: json['average_sentence_length'] as int? ?? 3,
    );
  }

  UserStyle copyWith({
    String? preferredPronouns,
    String? styleNotes,
    List<String>? signatureWords,
    String? greetingStyle,
    bool? useEmojis,
    int? averageSentenceLength,
  }) {
    return UserStyle(
      preferredPronouns: preferredPronouns ?? this.preferredPronouns,
      styleNotes: styleNotes ?? this.styleNotes,
      signatureWords: signatureWords ?? this.signatureWords,
      greetingStyle: greetingStyle ?? this.greetingStyle,
      useEmojis: useEmojis ?? this.useEmojis,
      averageSentenceLength: averageSentenceLength ?? this.averageSentenceLength,
    );
  }
}

/// Préférences culinaires et goûts
class FoodPreferences {
  final List<String> likes; // Tags d'ingrédients/cuisines aimés
  final List<String> dislikes; // Tags d'ingrédients/cuisines détestés
  final Map<String, int> styleSliders; // epice: 0-3, acidite: 0-3, gras: 0-3, croquant: 0-3
  final List<String> goals; // "équilibré", "perte_poids", "sport", "gastronomique"
  final List<String> equipment; // Matériel disponible
  final int defaultServings;
  final String budget; // "bas", "moyen", "élevé"

  const FoodPreferences({
    this.likes = const [],
    this.dislikes = const [],
    this.styleSliders = const {
      'epice': 1,
      'acidite': 1,
      'gras': 1,
      'croquant': 1,
    },
    this.goals = const ['équilibré'],
    this.equipment = const ['poêle', 'four'],
    this.defaultServings = 2,
    this.budget = 'moyen',
  });

  Map<String, dynamic> toJson() => {
    'likes': likes,
    'dislikes': dislikes,
    'style_sliders': styleSliders,
    'goals': goals,
    'equipment': equipment,
    'default_servings': defaultServings,
    'budget': budget,
  };

  factory FoodPreferences.fromJson(Map<String, dynamic> json) {
    return FoodPreferences(
      likes: List<String>.from(json['likes'] ?? []),
      dislikes: List<String>.from(json['dislikes'] ?? []),
      styleSliders: Map<String, int>.from(json['style_sliders'] ?? {
        'epice': 1,
        'acidite': 1,
        'gras': 1,
        'croquant': 1,
      }),
      goals: List<String>.from(json['goals'] ?? ['équilibré']),
      equipment: List<String>.from(json['equipment'] ?? ['poêle', 'four']),
      defaultServings: json['default_servings'] as int? ?? 2,
      budget: json['budget'] as String? ?? 'moyen',
    );
  }

  FoodPreferences copyWith({
    List<String>? likes,
    List<String>? dislikes,
    Map<String, int>? styleSliders,
    List<String>? goals,
    List<String>? equipment,
    int? defaultServings,
    String? budget,
  }) {
    return FoodPreferences(
      likes: likes ?? this.likes,
      dislikes: dislikes ?? this.dislikes,
      styleSliders: styleSliders ?? this.styleSliders,
      goals: goals ?? this.goals,
      equipment: equipment ?? this.equipment,
      defaultServings: defaultServings ?? this.defaultServings,
      budget: budget ?? this.budget,
    );
  }
}

/// Contraintes de santé et restrictions
class HealthConstraints {
  final List<String> allergens; // Allergènes à éviter
  final List<String> healthFlags; // "diabète", "low_salt", "hypertension", "sport"
  final int? calorieTarget; // Objectif calorique quotidien
  final Map<String, double> nutritionTargets; // protein_g, carb_g, fat_g, fiber_g
  final List<String> restrictions; // "sans_gluten", "végétarien", "halal", etc.

  const HealthConstraints({
    this.allergens = const [],
    this.healthFlags = const [],
    this.calorieTarget,
    this.nutritionTargets = const {},
    this.restrictions = const [],
  });

  bool isRecipeSafe(Map<String, dynamic> recipeData) {
    final recipeIngredients = (recipeData['ingredients'] as List?)?.cast<String>() ?? [];
    for (final allergen in allergens) {
      if (recipeIngredients.any((ing) => 
          ing.toLowerCase().contains(allergen.toLowerCase()))) {
        return false;
      }
    }
    return true;
  }

  Map<String, dynamic> toHealthSummary() {
    return {
      'allergens': allergens,
      'health_flags': healthFlags,
      'calorie_target': calorieTarget,
      'nutrition_targets': nutritionTargets,
      'restrictions': restrictions,
    };
  }

  Map<String, dynamic> toJson() => {
    'allergens': allergens,
    'health_flags': healthFlags,
    'calorie_target': calorieTarget,
    'nutrition_targets': nutritionTargets,
    'restrictions': restrictions,
  };

  factory HealthConstraints.fromJson(Map<String, dynamic> json) {
    return HealthConstraints(
      allergens: List<String>.from(json['allergens'] ?? []),
      healthFlags: List<String>.from(json['health_flags'] ?? []),
      calorieTarget: json['calorie_target'] as int?,
      nutritionTargets: Map<String, double>.from(json['nutrition_targets'] ?? {}),
      restrictions: List<String>.from(json['restrictions'] ?? []),
    );
  }

  HealthConstraints copyWith({
    List<String>? allergens,
    List<String>? healthFlags,
    int? calorieTarget,
    Map<String, double>? nutritionTargets,
    List<String>? restrictions,
  }) {
    return HealthConstraints(
      allergens: allergens ?? this.allergens,
      healthFlags: healthFlags ?? this.healthFlags,
      calorieTarget: calorieTarget ?? this.calorieTarget,
      nutritionTargets: nutritionTargets ?? this.nutritionTargets,
      restrictions: restrictions ?? this.restrictions,
    );
  }
}

/// Consentements pour la personnalisation
class UserConsents {
  final bool allowNameInCloud; // Autorise l'envoi du prénom au cloud
  final bool allowStyleHintInCloud; // Autorise l'envoi du style au cloud
  final bool allowHealthDataInCloud; // Autorise l'envoi des données santé au cloud
  final bool allowLearningFromFeedback; // Autorise l'apprentissage des préférences

  const UserConsents({
    this.allowNameInCloud = false,
    this.allowStyleHintInCloud = true,
    this.allowHealthDataInCloud = true,
    this.allowLearningFromFeedback = true,
  });

  Map<String, dynamic> toJson() => {
    'allow_name_in_cloud': allowNameInCloud,
    'allow_style_hint_in_cloud': allowStyleHintInCloud,
    'allow_health_data_in_cloud': allowHealthDataInCloud,
    'allow_learning_from_feedback': allowLearningFromFeedback,
  };

  factory UserConsents.fromJson(Map<String, dynamic> json) {
    return UserConsents(
      allowNameInCloud: json['allow_name_in_cloud'] as bool? ?? false,
      allowStyleHintInCloud: json['allow_style_hint_in_cloud'] as bool? ?? true,
      allowHealthDataInCloud: json['allow_health_data_in_cloud'] as bool? ?? true,
      allowLearningFromFeedback: json['allow_learning_from_feedback'] as bool? ?? true,
    );
  }

  UserConsents copyWith({
    bool? allowNameInCloud,
    bool? allowStyleHintInCloud,
    bool? allowHealthDataInCloud,
    bool? allowLearningFromFeedback,
  }) {
    return UserConsents(
      allowNameInCloud: allowNameInCloud ?? this.allowNameInCloud,
      allowStyleHintInCloud: allowStyleHintInCloud ?? this.allowStyleHintInCloud,
      allowHealthDataInCloud: allowHealthDataInCloud ?? this.allowHealthDataInCloud,
      allowLearningFromFeedback: allowLearningFromFeedback ?? this.allowLearningFromFeedback,
    );
  }
}





```

### chef_ia_app/lib/core/prompt/prompt_builder.dart
```dart
import 'dart:convert';

// Modèles de compatibilité pour PromptBuilder
class UserPrefs {
  final String language; // "fr"
  final int? servings; // null = laissé libre
  final String? diet; // ex: "halal", "végétarien", "keto", null
  final List<String> avoidAllergens; // ex: ["gluten","arachide"]
  final List<String> dislikes; // ex: ["coriandre"]
  final String style; // "simple" | "raffiné" | "gastronomique"
  final int? timeLimitMin; // ex: 30
  final String budget; // "bas" | "moyen" | "élevé"

  const UserPrefs({
    this.language = 'fr',
    this.servings,
    this.diet,
    this.avoidAllergens = const [],
    this.dislikes = const [],
    this.style = 'simple',
    this.timeLimitMin,
    this.budget = 'moyen',
  });

  Map<String, dynamic> toJson() {
    return {
      'language': language,
      'servings': servings,
      'diet': diet,
      'avoid_allergens': avoidAllergens,
      'dislikes': dislikes,
      'style': style,
      'time_limit_min': timeLimitMin,
      'budget': budget,
    };
  }
}

class KitchenProfile {
  final List<String> availableEquipment; // ex: ["four","poêle","mixeur"]
  final List<String> unavailableEquipment; // ex: ["robot pâtissier"]
  const KitchenProfile({
    this.availableEquipment = const [],
    this.unavailableEquipment = const [],
  });

  Map<String, dynamic> toJson() {
    return {
      'available_equipment': availableEquipment,
      'unavailable_equipment': unavailableEquipment,
    };
  }
}

class PantryItem {
  final String item; // "tomates"
  final double? quantity; // ex: 200
  final String? unit; // "g","ml","pièce"
  final String? category; // ex: "Épicerie", "Frais", "Épices"
  final DateTime? expiry; // date de péremption
  final DateTime? createdAt; // date d'ajout
  final String? barcode; // code-barres EAN
  final String? imageUrl; // photo/miniature
  final String? location; // placard/frigo/congélo
  final bool? favorite; // étoile
  
  PantryItem(
    this.item, {
    this.quantity,
    this.unit,
    this.category,
    this.expiry,
    DateTime? createdAt,
    this.barcode,
    this.imageUrl,
    this.location,
    this.favorite,
  }) : createdAt = createdAt ?? DateTime.now();

  Map<String, dynamic> toJson() {
    return {
      'item': item,
      if (quantity != null) 'quantity': quantity,
      if (unit != null) 'unit': unit,
      if (category != null) 'category': category,
      if (expiry != null) 'expiry': expiry!.toIso8601String(),
      'createdAt': createdAt?.toIso8601String() ?? DateTime.now().toIso8601String(),
      if (barcode != null) 'barcode': barcode,
      if (imageUrl != null) 'imageUrl': imageUrl,
      if (location != null) 'location': location,
      if (favorite != null) 'favorite': favorite,
    };
  }
}

class PromptBuilder {
  final UserPrefs prefs;
  final KitchenProfile kitchen;
  final List<PantryItem> pantry;

  const PromptBuilder({
    required this.prefs,
    required this.kitchen,
    this.pantry = const [],
  });

  String build(String userPrompt) {
    final pantryJson = pantry.map((p) => {
      'item': p.item,
      if (p.quantity != null) 'quantity': p.quantity,
      if (p.unit != null) 'unit': p.unit,
    }).toList();

    // Bloc PERSONNALISATION injecté dans le prompt strict
    final personalization = {
      'language': prefs.language,
      if (prefs.servings != null) 'servings': prefs.servings,
      if (prefs.diet != null) 'diet': prefs.diet,
      'avoid_allergens': prefs.avoidAllergens,
      'dislikes': prefs.dislikes,
      'style': prefs.style,
      if (prefs.timeLimitMin != null) 'time_limit_min': prefs.timeLimitMin,
      'budget': prefs.budget,
      'available_equipment': kitchen.availableEquipment,
      'unavailable_equipment': kitchen.unavailableEquipment,
      'pantry': pantryJson,
      'measurement_system': 'metric', // force g / ml
    };

    // Prompt strict + schéma + contraintes (identique à ta v1) + PERSONNALISATION
    return '''
Tu es un expert culinaire francophone. Ta mission : produire UNIQUEMENT un JSON valide respectant exactement le schéma ChefIA v1.
Ne mets NI commentaires, NI code fences, NI texte hors JSON. Pas de Markdown.

SCHÉMA :
{
  "version": "chefia.v1",
  "metadata": {
    "language": "fr",
    "servings": <int>,
    "time": { "prep_min": <int>, "cook_min": <int>, "rest_min": <int> },
    "difficulty": "facile|moyen|difficile"
  },
  "title": <string>,
  "equipment": <string[]>,
  "ingredients": [
    { "item": <string>, "quantity": <number>, "unit": <string>, "notes": <string> }
  ],
  "steps": [
    { "n": <int>, "text": <string>, "timer_min": <int|null>, "tips": <string> }
  ],
  "allergens": <string[]>,
  "notes": <string[]>
}

CONTRAINTES :
- Français naturel.
- Unités: g, ml, pièce, c.à.s, c.à.c.
- Étapes actionnables, numérotées, une action clé par phrase.
- Timer en minutes si utile.
- Si l'utilisateur demande d'éviter des allergènes, adapte.
- Utiliser en priorité le contenu du garde-manger ("pantry") et le matériel disponible.
- Si un ingrédient indispensable manque, proposer une alternative dans "notes".
- Respecter "time_limit_min" si fourni (adapter la technique/choix de recette).
- Adapter le style du plat selon "style" :
  - simple = rapide, familial, accessible
  - raffiné = plus travaillé, présentation soignée, ingrédients plus variés
  - gastronomique = haut niveau, dressage artistique, techniques avancées
- Éviter strictement ce qui est dans "dislikes".

PERSONNALISATION_UTILISATEUR (JSON) :
${jsonEncode(personalization)}

CONTEXTE_UTILISATEUR :
$userPrompt

RENVOIE UNIQUEMENT LE JSON.
''';
  }
}

```

### chef_ia_app/lib/core/services/context_builder.dart
```dart
import 'dart:convert';
import '../models/user_models.dart';
import '../../data/user_profile_store.dart';
import '../../data/kitchen_store.dart';
import '../../equipment_service.dart' as equipment;

class ContextBuilder {
  /// Construit un JSON compact avec profil + garde-manger + matériel
  static Future<String> buildContextJson() async {
    final map = <String, dynamic>{};

    // Profil utilisateur
    final UserProfile? p = await UserProfileStore.getCurrentUser();
    map['profile'] = p?.toJson() ?? {
      'displayName': '',
      'style': {'preferredPronouns': 'tu', 'styleNotes': 'Ton détendu et direct'},
      'foodPrefs': {'likes': [], 'dislikes': []},
      'health': {'allergens': []},
    };

    // Garde-manger (best-effort)
    try {
      final pantry = await KitchenStore.loadPantry(); // adapte si API diff
      map['pantry'] = pantry.map((e) => {
        'name': e.name,
        'quantity': e.quantity,
        'unit': e.unit,
        'category': e.category,
      }).toList();
    } catch (_) {
      map['pantry'] = [];
    }

    // Matériel (best-effort)
    try {
      final eq = await equipment.EquipmentService.getEquipmentList();
      map['equipment'] = eq;
    } catch (_) {
      map['equipment'] = [];
    }

    return jsonEncode(map);
  }
}

```

### chef_ia_app/lib/core/stores/assistant_state.dart
```dart
import 'package:flutter/foundation.dart';
import '../models/recipe.dart';

/// Message minimal pour le chat
class ChatMessage {
  final bool isAi;
  final String text;
  const ChatMessage.ai(this.text) : isAi = true;
  const ChatMessage.user(this.text) : isAi = false;
}

enum AssistantMode { chat, create, execute, adapt }

/// État léger pour l'assistant (centralisé, observable)
class AssistantState extends ChangeNotifier {
  final List<ChatMessage> messages = <ChatMessage>[];
  bool loading = false;
  AssistantMode mode = AssistantMode.chat;
  List<Recipe> proposals = [];

  // mutations centralisées
  void addMessage(ChatMessage m) {
    messages.add(m);
    notifyListeners();
  }

  void setLoading(bool v) {
    if (loading == v) return;
    loading = v;
    notifyListeners();
  }

  void setMode(AssistantMode m) {
    if (mode == m) return;
    mode = m;
    notifyListeners();
  }

  void setProposals(List<Recipe> list) {
    proposals = list;
    notifyListeners();
  }

  void clearProposals() {
    proposals.clear();
    notifyListeners();
  }

  // helpers
  void resetConversation({String? greeting}) {
    messages.clear();
    if (greeting != null && greeting.isNotEmpty) {
      messages.add(ChatMessage.ai(greeting));
    }
    proposals.clear();
    loading = false;
    mode = AssistantMode.chat;
    notifyListeners();
  }
}

```

### chef_ia_app/lib/core/stores/user_context_provider.dart
```dart
import '../../data/user_prefs_store.dart';
import '../../data/kitchen_store.dart';
import '../prompt/prompt_builder.dart';
import '../../models/pantry_item.dart' as new_model;

/// Fournisseur de contexte utilisateur agrégé
/// Snapshot des préférences + cuisine + garde-manger pour l'IA
class UserContextProvider {
  /// Capture un snapshot complet du contexte utilisateur
  Future<UserContextSnapshot> snapshot() async {
    final prefs = await UserPrefsStore.load();
    final kitchen = await KitchenStore.loadKitchen();
    final pantry = await KitchenStore.loadPantry();

    return UserContextSnapshot(
      prefs: prefs,
      kitchen: kitchen,
      pantry: pantry,
    );
  }

  /// Snapshot du contexte utilisateur
  Future<Map<String, dynamic>> contextJson() async {
    final snapshot = await this.snapshot();
    return snapshot.toJson();
  }
}

/// Snapshot du contexte utilisateur (immutable)
class UserContextSnapshot {
  final UserPrefs prefs;
  final KitchenProfile kitchen;
  final List<new_model.PantryItem> pantry;

  const UserContextSnapshot({
    required this.prefs,
    required this.kitchen,
    required this.pantry,
  });

  /// Conversion vers JSON pour l'IA cloud
  Map<String, dynamic> toJson() {
    return {
      'preferences': {
        'language': prefs.language,
        'servings': prefs.servings,
        'diet': prefs.diet,
        'avoidAllergens': prefs.avoidAllergens,
        'dislikes': prefs.dislikes,
        'style': prefs.style,
        'timeLimitMin': prefs.timeLimitMin,
        'budget': prefs.budget,
      },
      'kitchen': {
        'availableEquipment': kitchen.availableEquipment,
        'unavailableEquipment': kitchen.unavailableEquipment,
      },
      'pantry': pantry.map((item) => {
        'name': item.name,
        'quantity': item.quantity,
        'unit': item.unit,
        'category': item.category,
      }).toList(),
    };
  }

  /// Résumé textuel pour l'IA locale
  String toHumanReadable() {
    final style = prefs.style;
    final servings = prefs.servings;
    final timeLimit = prefs.timeLimitMin;
    final budget = prefs.budget;
    
    final equipment = kitchen.availableEquipment.join(', ');
    final pantryItems = pantry.map((p) => p.name).join(', ');
    
    return '''
Style: $style
Personnes: $servings
Temps max: ${timeLimit}min
Budget: $budget
Équipement: $equipment
Garde-manger: $pantryItems
'''.trim();
  }

  /// Vérifie si un équipement est disponible
  bool hasEquipment(String equipmentName) {
    return kitchen.availableEquipment
        .any((e) => e.toLowerCase().contains(equipmentName.toLowerCase()));
  }

  /// Vérifie si un ingrédient est dans le garde-manger
  bool hasIngredient(String ingredientName) {
    return pantry.any((p) => 
        p.name.toLowerCase().contains(ingredientName.toLowerCase()));
  }

  /// Liste des ingrédients disponibles (noms uniquement)
  List<String> get availableIngredients {
    return pantry.map((p) => p.name).toList();
  }

  /// Liste des équipements disponibles
  List<String> get availableEquipment {
    return List.from(kitchen.availableEquipment);
  }
}

```

### chef_ia_app/lib/core/style/style_engine.dart
```dart
import '../models/user_models.dart';

/// Moteur de style pour personnaliser les réponses selon le profil utilisateur
class StyleEngine {
  const StyleEngine();

  /// Adapte le ton d'un texte selon le style utilisateur
  String adaptTone(String text, UserStyle style) {
    var adapted = text;

    // Adaptation des pronoms
    if (style.preferredPronouns == 'tu') {
      adapted = _convertToTu(adapted);
    } else if (style.preferredPronouns == 'vous') {
      adapted = _convertToVous(adapted);
    }

    // Adaptation de la longueur des phrases
    adapted = _adjustSentenceLength(adapted, style.averageSentenceLength);

    // Ajout d'emojis si autorisé
    if (style.useEmojis) {
      adapted = _addEmojis(adapted);
    }

    // Ajout de mots signature
    if (style.signatureWords.isNotEmpty) {
      adapted = _addSignatureWords(adapted, style.signatureWords);
    }

    // Adaptation du style de salutation
    adapted = _addGreeting(adapted, style.greetingStyle);

    return adapted;
  }

  /// Convertit le texte en utilisant "tu"
  String _convertToTu(String text) {
    return text
        .replaceAll(RegExp(r'\bVous\b'), 'Tu')
        .replaceAll(RegExp(r'\bvous\b'), 'tu')
        .replaceAll(RegExp(r'\bVotre\b'), 'Ton')
        .replaceAll(RegExp(r'\bvotre\b'), 'ton')
        .replaceAll(RegExp(r'\bVos\b'), 'Tes')
        .replaceAll(RegExp(r'\bvos\b'), 'tes');
  }

  /// Convertit le texte en utilisant "vous"
  String _convertToVous(String text) {
    return text
        .replaceAll(RegExp(r'\bTu\b'), 'Vous')
        .replaceAll(RegExp(r'\btu\b'), 'vous')
        .replaceAll(RegExp(r'\bTon\b'), 'Votre')
        .replaceAll(RegExp(r'\bton\b'), 'votre')
        .replaceAll(RegExp(r'\bTes\b'), 'Vos')
        .replaceAll(RegExp(r'\btes\b'), 'vos');
  }

  /// Ajuste la longueur des phrases
  String _adjustSentenceLength(String text, int targetLength) {
    final sentences = text.split(RegExp(r'[.!?]+'));
    final adjustedSentences = <String>[];

    for (final sentence in sentences) {
      if (sentence.trim().isEmpty) continue;

      var adjusted = sentence.trim();
      
      if (targetLength <= 2) {
        // Phrases courtes
        adjusted = _makeShorter(adjusted);
      } else if (targetLength >= 4) {
        // Phrases longues
        adjusted = _makeLonger(adjusted);
      }

      adjustedSentences.add(adjusted);
    }

    return adjustedSentences.join('. ') + (text.endsWith('.') ? '' : '.');
  }

  /// Raccourcit une phrase
  String _makeShorter(String sentence) {
    // Supprime les mots de liaison non essentiels
    final connectors = [
      'en effet', 'par ailleurs', 'de plus', 'en outre',
      'cependant', 'néanmoins', 'toutefois'
    ];

    for (final connector in connectors) {
      sentence = sentence.replaceAll(RegExp(connector, caseSensitive: false), '');
    }

    // Supprime les répétitions simples (désactivé temporairement)
    // sentence = sentence.replaceAll(RegExp(r'(\w+)\s+\1'), '$1');

    return sentence.trim();
  }

  /// Allonge une phrase
  String _makeLonger(String sentence) {
    // Ajoute des détails descriptifs
    const enhancements = [
      'avec soin',
      'de manière délicate',
      'pour un résultat optimal',
      'afin d\'obtenir le meilleur goût',
    ];

    // Utilisation des enhancements pour améliorer la phrase
    if (sentence.contains('cuire') && !sentence.contains('avec soin')) {
      sentence = sentence.replaceAll('cuire', 'cuire avec soin');
    }

    if (sentence.contains('mélanger') && !sentence.contains('délicatement')) {
      sentence = sentence.replaceAll('mélanger', 'mélanger délicatement');
    }

    return sentence;
  }

  /// Ajoute des emojis appropriés
  String _addEmojis(String text) {
    var enhanced = text;

    // Emojis pour les actions culinaires
    enhanced = enhanced.replaceAll('cuire', 'cuire 👨‍🍳');
    enhanced = enhanced.replaceAll('mélanger', 'mélanger 🔄');
    enhanced = enhanced.replaceAll('déguster', 'déguster 😋');
    enhanced = enhanced.replaceAll('servir', 'servir 🍽️');

    // Emojis pour les ingrédients
    enhanced = enhanced.replaceAll('poulet', 'poulet 🍗');
    enhanced = enhanced.replaceAll('poisson', 'poisson 🐟');
    enhanced = enhanced.replaceAll('légumes', 'légumes 🥬');
    enhanced = enhanced.replaceAll('épices', 'épices 🌶️');

    // Emojis pour les résultats
    if (enhanced.contains('délicieux')) {
      enhanced = enhanced.replaceAll('délicieux', 'délicieux 😍');
    }
    if (enhanced.contains('parfait')) {
      enhanced = enhanced.replaceAll('parfait', 'parfait ✨');
    }

    // Ajout d'emojis de fin pour les phrases positives
    if (enhanced.contains('bon appétit') || enhanced.contains('dégustez')) {
      enhanced += ' 🎉';
    }

    return enhanced;
  }

  /// Ajoute des mots signature
  String _addSignatureWords(String text, List<String> signatureWords) {
    if (signatureWords.isEmpty) return text;

    var enhanced = text;
    final randomWord = signatureWords[DateTime.now().millisecond % signatureWords.length];

    // Ajoute le mot signature à la fin de certaines phrases
    if (text.contains('Voilà') || text.contains('C\'est prêt') || text.contains('Terminé')) {
      enhanced = enhanced.replaceAll('!', ' $randomWord !');
    }

    // Ajoute au début pour les encouragements
    if (text.contains('Tu peux') || text.contains('N\'hésite pas')) {
      enhanced = enhanced.replaceAll('Tu peux', '$randomWord, tu peux');
      enhanced = enhanced.replaceAll('N\'hésite pas', '$randomWord, n\'hésite pas');
    }

    return enhanced;
  }

  /// Ajoute une salutation selon le style
  String _addGreeting(String text, String greetingStyle) {
    switch (greetingStyle) {
      case 'décontracté':
        return 'Salut ! $text';
      case 'formel':
        return 'Bonjour, $text';
      case 'complice':
        return 'Hey chef ! $text';
      default:
        return text;
    }
  }

  /// Génère un hint de style pour le cloud (sans info nominative)
  String generateStyleHint(UserStyle style) {
    final tone = style.styleNotes.isNotEmpty ? style.styleNotes : 'Ton détendu et clair';
    final emoji = style.useEmojis ? ', quelques emojis' : '';
    final length = style.averageSentenceLength <= 2 ? ', phrases courtes' : 
                   style.averageSentenceLength >= 4 ? ', phrases détaillées' : '';
    final pronouns = style.preferredPronouns == 'tu' ? ', tutoiement' : ', vouvoiement';
    
    return '$tone$emoji$length$pronouns';
  }

  /// Adapte une recette complète selon le style utilisateur
  Map<String, dynamic> adaptRecipeStyle(Map<String, dynamic> recipeData, UserStyle style) {
    final adapted = Map<String, dynamic>.from(recipeData);

    // Adaptation du titre
    if (adapted.containsKey('title')) {
      adapted['title'] = adaptTone(adapted['title'] as String, style);
    }

    // Adaptation des notes
    if (adapted.containsKey('notes')) {
      final notes = (adapted['notes'] as List?)?.cast<String>() ?? [];
      adapted['notes'] = notes.map((note) => adaptTone(note, style)).toList();
    }

    // Adaptation des étapes (optionnel - garder technique)
    if (adapted.containsKey('steps') && style.averageSentenceLength >= 4) {
      final steps = (adapted['steps'] as List?)?.cast<String>() ?? [];
      adapted['steps'] = steps.map((step) => _makeStepMoreDetailed(step, style)).toList();
    }

    return adapted;
  }

  /// Rend une étape plus détaillée
  String _makeStepMoreDetailed(String step, UserStyle style) {
    var detailed = step;

    // Ajoute des détails techniques si style détaillé
    if (style.averageSentenceLength >= 4) {
      if (detailed.contains('cuire') && !detailed.contains('à feu moyen')) {
        detailed = detailed.replaceAll('cuire', 'cuire à feu moyen');
      }
      if (detailed.contains('mélanger') && !detailed.contains('délicatement')) {
        detailed = detailed.replaceAll('mélanger', 'mélanger délicatement');
      }
    }

    return detailed;
  }

  /// Génère un message de feedback personnalisé
  String generateFeedbackMessage(int rating, List<String> reasons, UserStyle style) {
    String message = '';

    if (rating >= 4) {
      message = 'Super ! Cette recette t\'a plu !';
    } else if (rating >= 3) {
      message = 'Pas mal, on peut faire mieux !';
    } else {
      message = 'Pas terrible, on va s\'améliorer !';
    }

    // Ajoute des suggestions basées sur les raisons
    if (reasons.isNotEmpty) {
      message += ' Je note que ';
      message += reasons.join(', ');
      message += '. Je vais adapter mes prochaines suggestions !';
    }

    return adaptTone(message, style);
  }

  /// Génère un message d'encouragement personnalisé
  String generateEncouragementMessage(UserStyle style) {
    final encouragements = [
      'Tu vas y arriver !',
      'Courage, c\'est presque fini !',
      'Continue comme ça !',
      'Tu es sur la bonne voie !',
      'Excellent travail !',
    ];

    final random = DateTime.now().millisecond % encouragements.length;
    return adaptTone(encouragements[random], style);
  }

  /// Génère un message d'erreur empathique
  String generateErrorMessage(String error, UserStyle style) {
    String message = 'Oups ! Il y a eu un petit problème : $error. ';
    message += 'Pas de panique, on va réessayer !';
    
    return adaptTone(message, style);
  }

  /// Génère un message de confirmation d'adaptation
  String generateAdaptationMessage(List<String> adaptations, UserStyle style) {
    if (adaptations.isEmpty) return '';

    String message = 'J\'ai adapté la recette pour toi : ';
    message += adaptations.join(', ');
    message += '. Ça devrait mieux te convenir !';

    return adaptTone(message, style);
  }

  /// Génère un message de suggestion d'alternative
  String generateAlternativeMessage(String reason, UserStyle style) {
    String message = 'Cette recette ne te convient pas ? ';
    message += 'Je peux te proposer une alternative plus $reason si tu veux !';

    return adaptTone(message, style);
  }

  /// Analyse le style d'un message utilisateur pour l'apprentissage
  UserStyle analyzeUserStyle(String userMessage) {
    // Analyse du tutoiement/vouvoiement
    final usesTu = userMessage.toLowerCase().contains('tu');
    final usesVous = userMessage.toLowerCase().contains('vous');
    final preferredPronouns = usesTu ? 'tu' : (usesVous ? 'vous' : 'tu');

    // Analyse de la longueur des phrases
    final sentences = userMessage.split(RegExp(r'[.!?]+'));
    final avgLength = sentences.isEmpty ? 3 : 
        sentences.map((s) => s.split(' ').length).reduce((a, b) => a + b) / sentences.length;
    final sentenceLength = avgLength <= 5 ? 1 : (avgLength <= 10 ? 2 : (avgLength <= 15 ? 3 : 4));

    // Analyse des emojis
    final hasEmojis = RegExp(r'[😀-🙏🌀-🗿🚀-🛿]', unicode: true).hasMatch(userMessage);

    // Analyse du style de communication
    String greetingStyle = 'décontracté';
    if (userMessage.toLowerCase().contains('bonjour') || userMessage.toLowerCase().contains('salut')) {
      greetingStyle = 'décontracté';
    } else if (userMessage.toLowerCase().contains('monsieur') || userMessage.toLowerCase().contains('madame')) {
      greetingStyle = 'formel';
    }

    // Détection de mots signature (simplifié)
    final signatureWords = <String>[];
    final commonWords = ['grave', 'ok', 'cool', 'super', 'génial'];
    for (final word in commonWords) {
      if (userMessage.toLowerCase().contains(word)) {
        signatureWords.add(word);
      }
    }

    return UserStyle(
      preferredPronouns: preferredPronouns,
      averageSentenceLength: sentenceLength,
      useEmojis: hasEmojis,
      greetingStyle: greetingStyle,
      signatureWords: signatureWords,
      styleNotes: _generateStyleNotes(userMessage),
    );
  }

  /// Génère des notes de style basées sur le message
  String _generateStyleNotes(String message) {
    if (message.length < 10) return 'Style concis';
    if (message.length > 100) return 'Style détaillé';
    if (RegExp(r'[😀-🙏🌀-🗿🚀-🛿]', unicode: true).hasMatch(message)) return 'Style décontracté avec emojis';
    if (message.toLowerCase().contains('merci')) return 'Style poli';
    return 'Style neutre';
  }
}

```

### chef_ia_app/lib/core/theme/theme_controller.dart
```dart
import 'package:flutter/material.dart';
import 'package:chef_ia_app/data/user_prefs_store.dart';

class ThemeController extends ChangeNotifier {
  ThemeController._();
  static final ThemeController instance = ThemeController._();

  bool _highContrast = false;
  double _textScale = 1.0;
  bool _reduceMotion = false;

  bool get highContrast => _highContrast;
  double get textScale => _textScale;
  bool get reduceMotion => _reduceMotion;

  Future<void> load() async {
    _highContrast = await UserPrefsStore.getHighContrast();
    _textScale = await UserPrefsStore.getTextScale();
    _reduceMotion = await UserPrefsStore.getReduceMotion();
    notifyListeners();
  }

  Future<void> setHighContrast(bool v) async {
    _highContrast = v;
    await UserPrefsStore.setHighContrast(v);
    notifyListeners();
  }

  Future<void> setTextScale(double v) async {
    _textScale = v.clamp(1.0, 1.6);
    await UserPrefsStore.setTextScale(_textScale);
    notifyListeners();
  }

  Future<void> setReduceMotion(bool v) async {
    _reduceMotion = v;
    await UserPrefsStore.setReduceMotion(v);
    notifyListeners();
  }
}

```

### chef_ia_app/lib/core/utils/duration_parser.dart
```dart
/// Extrait un timer en secondes depuis une instruction FR (best-effort).
/// Ex: "cuire 10 min" → 600 ; "laisser reposer 1h 15" → 4500
int? extractTimerSec(String text) {
  final t = text.toLowerCase();

  // cas "x h y min" ou "xh y"
  final reHM = RegExp(r'(\d+)\s*h(?:eures?)?\s*(\d+)?\s*(?:min|m|minutes?)?');
  final mHM = reHM.firstMatch(t);
  if (mHM != null) {
    final h = int.tryParse(mHM.group(1) ?? '0') ?? 0;
    final mn = int.tryParse(mHM.group(2) ?? '0') ?? 0;
    final total = h * 3600 + mn * 60;
    return total > 0 ? total : null;
  }

  // cas "x min" / "x m" / "x minutes"
  final reM = RegExp(r'(\d+)\s*(?:min|m|minutes?)');
  final mM = reM.firstMatch(t);
  if (mM != null) {
    final mn = int.tryParse(mM.group(1) ?? '0') ?? 0;
    return mn > 0 ? mn * 60 : null;
  }

  // cas "x sec" / "x s" / "x secondes"
  final reS = RegExp(r'(\d+)\s*(?:sec|s|secondes?)');
  final mS = reS.firstMatch(t);
  if (mS != null) {
    final s = int.tryParse(mS.group(1) ?? '0') ?? 0;
    return s > 0 ? s : null;
  }

  return null;
}


```

### chef_ia_app/lib/data/kitchen_store.dart
```dart
import 'dart:async';
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../core/prompt/prompt_builder.dart';
import '../models/pantry_item.dart' as new_model;

/// Store du matériel (cuisine) et du garde‑manger (pantry).
/// - Persistance via SharedPreferences
/// - Diffusion des changements via 2 streams (kitchen + pantry)
class KitchenStore {
  static const _kKitchen = 'chefia_kitchen_v1';
  static const _kPantry  = 'chefia_pantry_v1';

  // --- STREAMS RÉACTIFS ---
  static final _kitchenController = StreamController<KitchenProfile>.broadcast();
  static Stream<KitchenProfile> get kitchenStream => _kitchenController.stream;

  static final _pantryController = StreamController<List<new_model.PantryItem>>.broadcast();
  static Stream<List<new_model.PantryItem>> get pantryStream => _pantryController.stream;

  // ---------------- Matériel ----------------
  static Future<void> saveKitchen(KitchenProfile k) async {
    final sp = await SharedPreferences.getInstance();
    await sp.setString(_kKitchen, jsonEncode({
      'available': k.availableEquipment,
      'unavailable': k.unavailableEquipment,
    }));

    // Notify listeners
    _kitchenController.add(k);
  }

  static Future<KitchenProfile> loadKitchen() async {
    final sp = await SharedPreferences.getInstance();
    final raw = sp.getString(_kKitchen);
    if (raw == null) {
      // Valeurs par défaut au 1er lancement
      return const KitchenProfile(
        availableEquipment: ['Poêle', 'Casserole', 'Four'],
        unavailableEquipment: [],
      );
    }
    final m = jsonDecode(raw) as Map<String, dynamic>;
    return KitchenProfile(
      availableEquipment: (m['available'] as List?)?.cast<String>() ?? const [],
      unavailableEquipment: (m['unavailable'] as List?)?.cast<String>() ?? const [],
    );
  }

  // ---------------- Pantry ----------------
  static Future<void> savePantry(List<new_model.PantryItem> items) async {
    final sp = await SharedPreferences.getInstance();
    final data = items.map((p) => p.toJson()).toList();
    await sp.setString(_kPantry, jsonEncode(data));

    // Notify listeners
    _pantryController.add(items);
  }

  static Future<List<new_model.PantryItem>> loadPantry() async {
    final sp = await SharedPreferences.getInstance();
    final raw = sp.getString(_kPantry);
    if (raw == null) {
      // Pantry par défaut au 1er lancement
      return [
        new_model.PantryItem(
          id: new_model.PantryItem.generateId(),
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
          name: 'Sel',
          quantity: 100,
          unit: 'g',
          category: 'Épicerie',
        ),
        new_model.PantryItem(
          id: new_model.PantryItem.generateId(),
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
          name: 'Sucre',
          quantity: 200,
          unit: 'g',
          category: 'Épicerie',
        ),
        new_model.PantryItem(
          id: new_model.PantryItem.generateId(),
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
          name: 'Farine',
          quantity: 500,
          unit: 'g',
          category: 'Épicerie',
        ),
      ];
    }
    final list = (jsonDecode(raw) as List).cast<Map<String, dynamic>>();
    return list.map((m) => new_model.PantryItem.fromJson(m)).toList();
  }

  /// Ajoute un item au garde-manger
  static Future<void> addPantryItem(new_model.PantryItem item) async {
    final currentPantry = await loadPantry();
    final updatedPantry = [...currentPantry, item];
    await savePantry(updatedPantry);
  }
}

```

### chef_ia_app/lib/data/user_prefs_store.dart
```dart
import 'dart:async';
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../core/prompt/prompt_builder.dart';

/// Store des préférences utilisateur (source de vérité unique).
/// - Persistance via SharedPreferences
/// - Diffusion des changements via Stream.broadcast()
class UserPrefsStore {
  static const _k = 'chefia_user_prefs_v1';
  static const _kHighContrast = 'a11y_high_contrast'; // bool
  static const _kTextScale   = 'a11y_text_scale';     // double (1.0–1.6)
  static const _kReduceMotion= 'a11y_reduce_motion';  // bool

  // --- STREAM RÉACTIF ---
  static final _prefsController = StreamController<UserPrefs>.broadcast();
  static Stream<UserPrefs> get stream => _prefsController.stream;

  /// Sauvegarde et notifie les abonnés.
  static Future<void> save(UserPrefs prefs) async {
    final sp = await SharedPreferences.getInstance();
    final data = {
      'language': prefs.language,
      'servings': prefs.servings,
      'diet': prefs.diet,
      'avoidAllergens': prefs.avoidAllergens,
      'dislikes': prefs.dislikes,
      'style': prefs.style, // "simple" | "raffiné" | "gastronomique" | "mixte"
      'timeLimitMin': prefs.timeLimitMin,
      'budget': prefs.budget, // "bas" | "moyen" | "élevé"
    };
    await sp.setString(_k, jsonEncode(data));

    // Notify listeners
    _prefsController.add(prefs);
  }

  /// Charge depuis SharedPreferences (avec valeurs par défaut au 1er lancement).
  static Future<UserPrefs> load() async {
    final sp = await SharedPreferences.getInstance();
    final raw = sp.getString(_k);
    if (raw == null) {
      // Valeurs par défaut (non enregistrées tant que l'user ne modifie pas)
      return const UserPrefs(
        language: 'fr',
        servings: 2,
        diet: null,
        avoidAllergens: [],
        dislikes: [],
        style: 'simple', // change en "mixte" si tu veux 2/2/1 par défaut
        timeLimitMin: 30,
        budget: 'moyen',
      );
    }
    final m = jsonDecode(raw) as Map<String, dynamic>;
    return UserPrefs(
      language: (m['language'] as String?) ?? 'fr',
      servings: m['servings'] as int?,
      diet: m['diet'] as String?,
      avoidAllergens: (m['avoidAllergens'] as List?)?.cast<String>() ?? const [],
      dislikes: (m['dislikes'] as List?)?.cast<String>() ?? const [],
      style: (m['style'] as String?) ?? 'simple',
      timeLimitMin: m['timeLimitMin'] as int?,
      budget: (m['budget'] as String?) ?? 'moyen',
    );
  }

  // --- GESTION DE L'ACCESSIBILITÉ ---
  static Future<void> setHighContrast(bool v) async {
    final p = await SharedPreferences.getInstance();
    await p.setBool(_kHighContrast, v);
  }
  
  static Future<bool> getHighContrast() async {
    final p = await SharedPreferences.getInstance();
    return p.getBool(_kHighContrast) ?? false;
  }

  static Future<void> setTextScale(double v) async {
    final p = await SharedPreferences.getInstance();
    await p.setDouble(_kTextScale, v.clamp(1.0, 1.6));
  }
  
  static Future<double> getTextScale() async {
    final p = await SharedPreferences.getInstance();
    return (p.getDouble(_kTextScale) ?? 1.0).clamp(1.0, 1.6);
  }

  static Future<void> setReduceMotion(bool v) async {
    final p = await SharedPreferences.getInstance();
    await p.setBool(_kReduceMotion, v);
  }
  
  static Future<bool> getReduceMotion() async {
    final p = await SharedPreferences.getInstance();
    return p.getBool(_kReduceMotion) ?? false;
  }

  // --- Pantry view prefs ---
  static const _kPantrySort = 'pantry_sort';           // 'alpha' | 'category' | 'expiry' | 'recent' | 'lowQty'
  static const _kPantryGroupByCategory = 'pantry_group_by_category'; // bool
  static const _kPantryShowImages = 'pantry_show_images';            // bool

  static Future<void> setPantrySort(String v) async {
    final p = await SharedPreferences.getInstance();
    await p.setString(_kPantrySort, v);
  }
  
  static Future<String> getPantrySort() async {
    final p = await SharedPreferences.getInstance();
    return p.getString(_kPantrySort) ?? 'alpha';
  }

  static Future<void> setPantryGroupByCategory(bool v) async {
    final p = await SharedPreferences.getInstance();
    await p.setBool(_kPantryGroupByCategory, v);
  }
  
  static Future<bool> getPantryGroupByCategory() async {
    final p = await SharedPreferences.getInstance();
    return p.getBool(_kPantryGroupByCategory) ?? true;
  }

  static Future<void> setPantryShowImages(bool v) async {
    final p = await SharedPreferences.getInstance();
    await p.setBool(_kPantryShowImages, v);
  }
  
  static Future<bool> getPantryShowImages() async {
    final p = await SharedPreferences.getInstance();
    return p.getBool(_kPantryShowImages) ?? true;
  }
}

```

### chef_ia_app/lib/data/user_profile_store.dart
```dart
import 'dart:async';
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';
import '../core/models/user_models.dart';

/// Store pour gérer les profils utilisateur multi-utilisateurs
class UserProfileStore {
  static const _k = 'chefia_user_profiles_v1';
  static const _currentUserKey = 'chefia_current_user_id';
  static const _uuid = Uuid();

  // --- STREAM RÉACTIF ---
  static final _profileController = StreamController<UserProfile>.broadcast();
  static Stream<UserProfile> get stream => _profileController.stream;

  /// Crée un nouvel utilisateur
  static Future<UserProfile> createUser({String? displayName}) async {
    final userId = _uuid.v4();
    final profile = UserProfile.defaultFor(userId).copyWith(
      displayName: displayName,
    );

    await _saveProfile(profile);
    await _setCurrentUser(userId);
    
    _profileController.add(profile);
    return profile;
  }

  /// Charge le profil utilisateur courant
  static Future<UserProfile?> getCurrentUser() async {
    final userId = await _getCurrentUserId();
    if (userId == null) return null;
    
    return await getUserById(userId);
  }

  /// Charge un utilisateur par ID
  static Future<UserProfile?> getUserById(String userId) async {
    final sp = await SharedPreferences.getInstance();
    final profilesJson = sp.getString(_k);
    
    if (profilesJson == null) return null;
    
    final profiles = Map<String, dynamic>.from(jsonDecode(profilesJson));
    final userJson = profiles[userId];
    
    if (userJson == null) return null;
    
    return UserProfile.fromJson(userJson);
  }

  /// Sauvegarde un profil utilisateur
  static Future<void> saveProfile(UserProfile profile) async {
    await _saveProfile(profile);
    _profileController.add(profile);
  }

  /// Met à jour le profil utilisateur
  static Future<void> updateProfile(UserProfile profile) async {
    final updated = profile.copyWith(lastActive: DateTime.now());
    await _saveProfile(updated);
    _profileController.add(updated);
  }

  /// Met à jour les préférences alimentaires
  static Future<void> updateFoodPreferences(String userId, FoodPreferences prefs) async {
    final profile = await getUserById(userId);
    if (profile == null) return;

    final updated = profile.copyWith(
      foodPrefs: prefs,
      lastActive: DateTime.now(),
    );
    
    await _saveProfile(updated);
    _profileController.add(updated);
  }

  /// Met à jour les contraintes de santé
  static Future<void> updateHealthConstraints(String userId, HealthConstraints health) async {
    final profile = await getUserById(userId);
    if (profile == null) return;

    final updated = profile.copyWith(
      health: health,
      lastActive: DateTime.now(),
    );
    
    await _saveProfile(updated);
    _profileController.add(updated);
  }

  /// Met à jour le style utilisateur
  static Future<void> updateUserStyle(String userId, UserStyle style) async {
    final profile = await getUserById(userId);
    if (profile == null) return;

    final updated = profile.copyWith(
      style: style,
      lastActive: DateTime.now(),
    );
    
    await _saveProfile(updated);
    _profileController.add(updated);
  }

  /// Met à jour les consentements
  static Future<void> updateConsents(String userId, UserConsents consents) async {
    final profile = await getUserById(userId);
    if (profile == null) return;

    final updated = profile.copyWith(
      consents: consents,
      lastActive: DateTime.now(),
    );
    
    await _saveProfile(updated);
    _profileController.add(updated);
  }



  /// Change d'utilisateur courant
  static Future<void> switchUser(String userId) async {
    await _setCurrentUser(userId);
    final profile = await getUserById(userId);
    if (profile != null) {
      _profileController.add(profile);
    }
  }

  /// Liste tous les utilisateurs
  static Future<List<UserProfile>> getAllUsers() async {
    final sp = await SharedPreferences.getInstance();
    final profilesJson = sp.getString(_k);
    
    if (profilesJson == null) return [];
    
    final profiles = Map<String, dynamic>.from(jsonDecode(profilesJson));
    return profiles.values
        .map((json) => UserProfile.fromJson(json))
        .toList()
      ..sort((a, b) => b.lastActive.compareTo(a.lastActive));
  }

  /// Supprime un utilisateur
  static Future<void> deleteUser(String userId) async {
    final sp = await SharedPreferences.getInstance();
    final profilesJson = sp.getString(_k);
    
    if (profilesJson == null) return;
    
    final profiles = Map<String, dynamic>.from(jsonDecode(profilesJson));
    profiles.remove(userId);
    
    await sp.setString(_k, jsonEncode(profiles));
    
    // Si c'était l'utilisateur courant, le changer
    final currentUserId = await _getCurrentUserId();
    if (currentUserId == userId) {
      final remainingUsers = profiles.keys.toList();
      if (remainingUsers.isNotEmpty) {
        await _setCurrentUser(remainingUsers.first);
      } else {
        await sp.remove(_currentUserKey);
      }
    }
  }

  // --- MÉTHODES PRIVÉES ---

  /// Sauvegarde un profil dans le stockage
  static Future<void> _saveProfile(UserProfile profile) async {
    final sp = await SharedPreferences.getInstance();
    final profilesJson = sp.getString(_k);
    
    Map<String, dynamic> profiles;
    if (profilesJson == null) {
      profiles = {};
    } else {
      profiles = Map<String, dynamic>.from(jsonDecode(profilesJson));
    }
    
    profiles[profile.userId] = profile.toJson();
    await sp.setString(_k, jsonEncode(profiles));
  }

  /// Définit l'utilisateur courant
  static Future<void> _setCurrentUser(String userId) async {
    final sp = await SharedPreferences.getInstance();
    await sp.setString(_currentUserKey, userId);
  }

  /// Récupère l'ID de l'utilisateur courant
  static Future<String?> _getCurrentUserId() async {
    final sp = await SharedPreferences.getInstance();
    return sp.getString(_currentUserKey);
  }



  /// Vérifie si un profil existe
  static Future<bool> hasProfile() async {
    try {
      final prefs = await SharedPreferences
          .getInstance()
          .timeout(const Duration(seconds: 2));
      // adapte la clé si différente chez toi
      return prefs.containsKey('user_profile');
    } catch (_) {
      return false;
    }
  }

  /// Marque l'onboarding comme vu
  static Future<void> setSeenOnboarding() async {
    final sp = await SharedPreferences.getInstance();
    await sp.setBool('chefia_onboarding_seen', true);
  }

  /// Sauvegarde un profil (alias pour saveProfile)
  static Future<void> save(UserProfile profile) async {
    await saveProfile(profile);
  }

  /// Nettoie les ressources
  static void dispose() {
    _profileController.close();
  }
}





```

### chef_ia_app/lib/domain/models/product.dart
```dart
class Product {
  final String id;           // code-barres ou UUID
  final String name;
  final String? brand;
  final double? quantity;    // ex. 1.0
  final String? unit;        // ex. "L", "g", "pcs"
  final List<String> tags;   // catégories, labels (bio, sans gluten...)

  const Product({
    required this.id,
    required this.name,
    this.brand,
    this.quantity,
    this.unit,
    this.tags = const [],
  });

  factory Product.fromJson(Map<String, dynamic> json) {
    return Product(
      id: json['id'] as String,
      name: json['name'] as String,
      brand: json['brand'] as String?,
      quantity: json['quantity'] as double?,
      unit: json['unit'] as String?,
      tags: List<String>.from(json['tags'] ?? []),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'brand': brand,
      'quantity': quantity,
      'unit': unit,
      'tags': tags,
    };
  }
}


```

### chef_ia_app/lib/domain/models/shopping_item.dart
```dart
import 'package:shared_models/shared_models.dart';

class ShoppingItem {
  final Product product;
  final int quantity;         // quantité à acheter
  final double? price;        // dernier prix observé
  final bool checked;         // coché dans la liste ?

  const ShoppingItem({
    required this.product,
    this.quantity = 1,
    this.price,
    this.checked = false,
  });

  ShoppingItem copyWith({int? quantity, double? price, bool? checked}) {
    return ShoppingItem(
      product: product,
      quantity: quantity ?? this.quantity,
      price: price ?? this.price,
      checked: checked ?? this.checked,
    );
  }

  factory ShoppingItem.fromJson(Map<String, dynamic> json) {
    return ShoppingItem(
      product: Product.fromJson(json['product'] as Map<String, dynamic>),
      quantity: json['quantity'] as int? ?? 1,
      price: json['price'] as double?,
      checked: json['checked'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'product': product.toJson(),
      'quantity': quantity,
      'price': price,
      'checked': checked,
    };
  }
}


```

### chef_ia_app/lib/features/pantry/home_boot_example.dart
```dart
import 'package:flutter/material.dart';
import 'inbox_import.dart';

// EXEMPLE: adapte ce callback à ton modèle de garde‑manger
Future<void> upsertIntoPantry(ImportedPantryLine line) async {
  // 1) Mapper vers ton modèle (ex: PantryItem)
  // 2) Si l'item existe déjà → incrémente la quantité
  // 3) Sinon → crée l'entrée avec qty=line.qty
  // 4) Optionnel: stocker unitPrice si tu gères les prix
  
  // TODO: Implémente ta logique d'upsert ici
  // Exemple:
  // final existingItem = await findPantryItemByName(line.name);
  // if (existingItem != null) {
  //   await updatePantryItemQuantity(existingItem.id, existingItem.qty + line.qty);
  // } else {
  //   await createPantryItem(line);
  // }
}

class HomeBoot extends StatefulWidget {
  const HomeBoot({super.key});
  @override
  State<HomeBoot> createState() => _HomeBootState();
}

class _HomeBootState extends State<HomeBoot> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      final imported = await importFromCoursesInbox(onUpsert: upsertIntoPantry);
      if (imported > 0 && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Garde‑manger mis à jour : +$imported article(s)')),
        );
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return const SizedBox.shrink(); // ou ton vrai Home
  }
}

/// Exemple d'utilisation dans un écran de paramètres / garde‑manger
class PantryImportButton extends StatelessWidget {
  const PantryImportButton({super.key});

  @override
  Widget build(BuildContext context) {
    return FilledButton.icon(
      onPressed: () async {
        final imported = await importFromCoursesInbox(onUpsert: upsertIntoPantry);
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(imported > 0
                ? 'Importé : +$imported article(s)'
                : 'Rien à importer'),
            ),
          );
        }
      },
      icon: const Icon(Icons.move_to_inbox),
      label: const Text('Importer depuis Courses'),
    );
  }
}







```

### chef_ia_app/lib/features/pantry/inbox_import.dart
```dart
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';

/// Représente une ligne importée depuis Courses
class ImportedPantryLine {
  final String id;
  final String name;
  final String? brand;
  final String? unit;
  final String category;
  final int qty;
  final double? unitPrice;
  final String origin; // "recipe" | "main" | "special"

  ImportedPantryLine({
    required this.id,
    required this.name,
    this.brand,
    this.unit,
    required this.category,
    required this.qty,
    this.unitPrice,
    required this.origin,
  });
}

/// Consomme l'INBOX poussée par Courses (Broadcast + WorkManager côté Courses)
/// et te laisse gérer l'insertion via [onUpsert].
///
/// Retourne le nombre total de pièces importées (somme des qty).
Future<int> importFromCoursesInbox({
  required Future<void> Function(ImportedPantryLine line) onUpsert,
}) async {
  const inboxKey = 'inbox_from_courses_v1';
  final prefs = await SharedPreferences.getInstance();
  final set = prefs.getStringList(inboxKey) ?? [];

  if (set.isEmpty) return 0;

  var total = 0;

  for (final raw in set) {
    try {
      final map = jsonDecode(raw) as Map<String, dynamic>;
      final items = (map['items'] as List).cast<Map<String, dynamic>>();

      for (final it in items) {
        final line = ImportedPantryLine(
          id: (it['id'] ?? '').toString(),
          name: (it['name'] ?? '').toString(),
          brand: (it['brand'] as String?),
          unit: (it['unit'] as String?),
          category: (it['category'] as String?) ?? 'Divers',
          qty: (it['qty'] as num?)?.toInt() ?? 1,
          unitPrice: (it['unitPrice'] as num?)?.toDouble(),
          origin: (it['origin'] as String?) ?? 'special',
        );

        // Laisse l'app appelante décider comment stocker/merger
        await onUpsert(line);
        total += line.qty;
      }
    } catch (_) {
      // ignore / log si besoin
    }
  }

  // Purge de l'INBOX une fois consommée
  await prefs.remove(inboxKey);
  return total;
}







```

### chef_ia_app/lib/features/pantry/inbox_import_riverpod.dart
```dart
import 'dart:convert';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'inbox_import.dart'; // Utilise la classe ImportedPantryLine définie ici

/// Provider d'un callback d'upsert dans TON garde‑manger.
/// 👉 Branche ici ton repo/service réel (remplace le TODO).
final pantryUpsertFnProvider =
    Provider<Future<void> Function(ImportedPantryLine)>((ref) {
  return (line) async {
    // TODO: remplace par ton vrai upsert :
    // ex: await ref.read(pantryRepositoryProvider).upsert(line.toPantryItem());
  };
});

/// Consomme l'INBOX poussée par Courses (Broadcast+WorkManager côté Courses)
/// et appelle pantryUpsertFnProvider pour insérer/mettre à jour.
/// Retourne le nombre total de pièces importées.
Future<int> _importFromCoursesInbox(
    Future<void> Function(ImportedPantryLine) onUpsert) async {
  const inboxKey = 'inbox_from_courses_v1';
  final prefs = await SharedPreferences.getInstance();
  final set = prefs.getStringList(inboxKey) ?? [];
  if (set.isEmpty) return 0;

  var total = 0;
  for (final raw in set) {
    try {
      final map = jsonDecode(raw) as Map<String, dynamic>;
      final items = (map['items'] as List).cast<Map<String, dynamic>>();
      for (final it in items) {
        final line = ImportedPantryLine(
          id: (it['id'] ?? '').toString(),
          name: (it['name'] ?? '').toString(),
          brand: it['brand'] as String?,
          unit: it['unit'] as String?,
          category: (it['category'] as String?) ?? 'Divers',
          qty: (it['qty'] as num?)?.toInt() ?? 1,
          unitPrice: (it['unitPrice'] as num?)?.toDouble(),
          origin: (it['origin'] as String?) ?? 'special',
        );
        await onUpsert(line);
        total += line.qty;
      }
    } catch (_) {
      // ignore / log si besoin
    }
  }
  await prefs.remove(inboxKey); // purge après import
  return total;
}

/// FutureProvider pour lancer l'import au boot (ou à la demande).
final coursesInboxConsumerProvider = FutureProvider<int>((ref) async {
  final upsert = ref.read(pantryUpsertFnProvider);
  final count = await _importFromCoursesInbox(upsert);
  return count;
});







```

### chef_ia_app/lib/features/pantry/pantry_sender.dart
```dart
import 'dart:convert';
import 'package:android_intent_plus/android_intent.dart';
import '../../models/pantry_item.dart';

/// Envoie le panier de ChefIA Cuisine vers ChefIA Courses via Broadcast Intent
/// ✅ Marche sans Internet
/// ✅ L'utilisateur n'a pas besoin d'ouvrir Courses
/// ✅ Le Receiver + WorkManager se chargent du reste
Future<void> sendPantryToCourses(Map<String, dynamic> payload) async {
  final jsonStr = jsonEncode(payload);
  final intent = AndroidIntent(
    action: 'com.chefia.courses.IMPORT_PANTRY',
    package: 'com.chefia.courses', // ← remplace par le package exact de Courses
    arguments: <String, dynamic>{
      'payload': jsonStr, // ou 'payload_b64': base64Url.encode(utf8.encode(jsonStr))
    },
  );
  await intent.sendBroadcast();
}

/// Helper pour créer le payload du panier
Map<String, dynamic> createPantryPayload({
  required List<Map<String, dynamic>> items,
  String? recipeName,
  String? origin,
}) {
  return {
    'timestamp': DateTime.now().millisecondsSinceEpoch,
    'recipeName': recipeName,
    'origin': origin ?? 'recipe',
    'items': items,
  };
}

/// Exemple d'utilisation pour envoyer un panier de recette
Future<void> sendRecipePantryToCourses({
  required String recipeName,
  required List<Map<String, dynamic>> ingredients,
}) async {
  final payload = createPantryPayload(
    items: ingredients,
    recipeName: recipeName,
    origin: 'recipe',
  );
  
  await sendPantryToCourses(payload);
}

/// Helper pour convertir un PantryItem en payload
Map<String, dynamic> toPayload(PantryItem it) => {
  'id': it.id,
  'name': it.name,
  'quantity': it.quantity,
  'unit': it.unit,
  'category': it.category,
  'expiry': it.expiry?.toIso8601String(),
  'barcode': it.barcode,
  'updatedAt': it.updatedAt.toIso8601String(),
  'source': it.source ?? 'chefia',
  'householdId': it.householdId,
};







```

### chef_ia_app/lib/features/pantry/advice/pantry_advisor_provider.dart
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:http/http.dart' as http;
import 'package:chef_ia_app/features/pantry/state/pantry_provider.dart';
import 'package:chef_ia_app/services/ai/pantry_advisor_v2.dart';
import 'package:chef_ia_app/services/ai/local_pantry_advisor_v2.dart';
import 'package:chef_ia_app/models/pantry_advisory.dart';

const bool kCloudAdviceEnabled = bool.fromEnvironment('CHEFIA_ADVICE_CLOUD', defaultValue: false);
const String? kCloudAdviceEndpoint = String.fromEnvironment('CHEFIA_ADVICE_ENDPOINT');

final pantryAdvisorProvider = Provider<PantryAdvisor>((ref) {
  final local = LocalPantryAdvisor();
  final cloud = (kCloudAdviceEnabled && kCloudAdviceEndpoint != null)
      ? CloudPantryAdvisor(endpoint: kCloudAdviceEndpoint!)
      : const NoopCloudPantryAdvisor();
  return HybridPantryAdvisor(local: local, cloud: cloud);
});

/// Produit des conseils asynchrones basés sur les items visibles
final pantryAdvisoryProvider = FutureProvider.autoDispose<List<SimplePantryAdvisory>>((ref) async {
  final advisor = ref.watch(pantryAdvisorProvider);
  final items = ref.watch(pantryVisibleItemsProvider);
  if (items.isEmpty) return [];
  return advisor.compute(items);
});


```

### chef_ia_app/lib/features/pantry/providers/pantry_prefs_provider.dart
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Provider pour la persistance des préférences du garde-manger par foyer
final pantryPrefsProvider = Provider((ref) => PantryPrefsRepo());

class PantryPrefsRepo {
  static const _kSort = 'pantry.sort';
  static const _kFilter = 'pantry.filter';
  
  Future<void> saveSort(String householdId, String sort) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('$_kSort.$householdId', sort);
  }
  
  Future<String?> loadSort(String householdId) async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString('$_kSort.$householdId');
  }
  
  Future<void> saveFilter(String householdId, String filter) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('$_kFilter.$householdId', filter);
  }
  
  Future<String?> loadFilter(String householdId) async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString('$_kFilter.$householdId');
  }
  
  Future<void> clearPrefs(String householdId) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('$_kSort.$householdId');
    await prefs.remove('$_kFilter.$householdId');
  }
}


```

### chef_ia_app/lib/features/pantry/screens/pantry_body.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import 'package:chef_ia_app/features/pantry/state/pantry_provider.dart';
import 'package:chef_ia_app/features/pantry/widgets/pantry_filters_bar.dart';
import 'package:chef_ia_app/features/pantry/widgets/pantry_empty_state.dart';
import 'package:chef_ia_app/features/pantry/widgets/pantry_advisory_banner.dart';
import 'package:chef_ia_app/features/pantry/widgets/pantry_list_view.dart';
import 'package:chef_ia_app/models/pantry_item.dart';

class PantryBody extends ConsumerStatefulWidget {
  const PantryBody({super.key});

  @override
  ConsumerState<PantryBody> createState() => _PantryBodyState();
}

class _PantryBodyState extends ConsumerState<PantryBody> {
  final _qtyCtrl = TextEditingController();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(pantryNotifierProvider.notifier).loadInitial();
    });
  }

  Future<void> _quickAdd() async {
    final controller = TextEditingController();
    DateTime? pickedDate;

    final name = await showDialog<String>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Ajouter un produit'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              key: const Key('add_name_field'),
              controller: controller, 
              decoration: const InputDecoration(hintText: 'Nom')
            ),
            const SizedBox(height: 8),
            TextField(
              key: const Key('add_qty_field'),
              controller: _qtyCtrl,
              keyboardType: TextInputType.number,
              decoration: const InputDecoration(labelText: 'Quantité (optionnel)'),
            ),
            const SizedBox(height: 8),
            Align(
              alignment: Alignment.centerLeft,
              child: TextButton.icon(
                icon: const Icon(Icons.event),
                label: Text(pickedDate == null
                    ? 'Date de péremption (optionnel)'
                    : 'Péremption : ${pickedDate!.toLocal().toString().split(' ').first}'),
                onPressed: () async {
                  final now = DateTime.now();
                  final d = await showDatePicker(
                    context: context,
                    firstDate: now.subtract(const Duration(days: 1)),
                    lastDate: now.add(const Duration(days: 365 * 3)),
                    initialDate: pickedDate ?? now,
                  );
                  if (d != null) {
                    pickedDate = d;
                    (context as Element).markNeedsBuild();
                  }
                },
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            key: const Key('add_cancel_btn'),
            onPressed: () => Navigator.pop(context), 
            child: const Text('Annuler')
          ),
          FilledButton(
            key: const Key('add_save_btn'),
            onPressed: () => Navigator.pop(context, controller.text.trim()), 
            child: const Text('Ajouter')
          ),
        ],
      ),
    );

    if (name == null || name.isEmpty) return;
    final q = int.tryParse(_qtyCtrl.text);
    await ref.read(pantryNotifierProvider.notifier).addItem(
      PantryItem(
        id: const Uuid().v4(),
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        name: name,
        quantity: q?.toDouble(),
        expirationDate: pickedDate,
      ),
    );
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('"$name" ajouté')));
    }
  }

  @override
  Widget build(BuildContext context) {
    final hasItems = ref.watch(pantryVisibleItemsProvider).isNotEmpty;

    return Padding(
      padding: const EdgeInsets.all(12),
      child: Column(
        children: [
          // Bannière de conseils AI (auto-réactive)
          const PantryAdvisoryBanner(),

          // Barre de recherche / filtres
          PantryFiltersBar(
            searchText: ref.watch(pantrySearchTextProvider),
            onSearchChanged: ref.read(pantryNotifierProvider.notifier).setSearchTextDebounced,
            activeFilters: ref.watch(pantryActiveFiltersProvider).toList(),
            onClearFilters: ref.read(pantryActiveFiltersProvider).isNotEmpty
                ? ref.read(pantryNotifierProvider.notifier).clearFilters
                : null,
            trailing: IconButton(
              icon: const Icon(Icons.qr_code_scanner),
              onPressed: () => ref.read(pantryNotifierProvider.notifier).scan(() {
                // appelle ton handler existant si tu veux garder la logique native
              }),
            ),
          ),

          const SizedBox(height: 8),

          // Liste ou état vide
          Expanded(
            child: hasItems
                ? const PantryListView()
                : PantryEmptyState(
                    title: 'Garde-manger vide',
                    message: "Ajoute un produit manuellement ou scanne un code-barres.",
                    cta: ElevatedButton.icon(
                      key: const Key('pantry_empty_add_btn'),
                      onPressed: _quickAdd,
                      icon: const Icon(Icons.add),
                      label: const Text('Ajouter un produit'),
                    ),
                  ),
          ),
        ],
      ),
    );
  }
}


```

### chef_ia_app/lib/features/pantry/state/household_provider.dart
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../models/household.dart';

final currentHouseholdIdProvider = StateProvider<String?>((_) => null); // null = mode solo (local)
final householdsProvider = StateNotifierProvider<_Households, List<Household>>((_) => _Households());

class _Households extends StateNotifier<List<Household>> {
  _Households() : super(const []);
  
  void createLocal(String name, String id) {
    final hh = Household(id: id, name: name);
    state = [...state, hh];
  }
  
  void rename(String id, String name) {
    state = state.map((h) => h.id == id ? h.copyWith(name: name, updatedAt: DateTime.now()) : h).toList();
  }
}

```

### chef_ia_app/lib/features/pantry/state/pantry_provider.dart
```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:chef_ia_app/features/pantry/state/pantry_state.dart';
import 'package:chef_ia_app/features/pantry/providers/pantry_prefs_provider.dart';
import 'package:chef_ia_app/services/storage/pantry_store.dart';
import 'package:chef_ia_app/models/pantry_item.dart';
import 'package:chef_ia_app/models/pantry_advisory.dart';
import 'package:chef_ia_app/features/pantry/advice/pantry_advisor_provider.dart';
import 'package:chef_ia_app/features/pantry/state/household_provider.dart';
import 'package:chef_ia_app/core/event_bus.dart';
import 'package:chef_ia_app/core/events.dart';

/// Fournit l'implémentation de persistance
final pantryStoreProvider = Provider<PantryStore?>((ref) {
  return PantryStore();
});

/// Notifier Riverpod pilotant l'état du garde-manger
class PantryNotifier extends StateNotifier<PantryState> {
  final PantryStore? store;
  late final _SaveDebouncer _debouncer;
  Timer? _searchDebouncer;

  PantryNotifier({this.store}) : super(const PantryState()) {
    _debouncer = _SaveDebouncer(store);
  }

  @override
  void dispose() {
    _debouncer.dispose();
    _searchDebouncer?.cancel();
    super.dispose();
  }

  // ---- Chargement / Persistance ------------------------------------------------
  Future<void> loadInitial() async {
    try {
      state = state.copyWith(isLoading: true, error: null);
      // Mode solo par défaut (pas de foyer)
      final loaded = await store?.load() ?? <PantryItem>[];
      state = state.copyWith(allItems: loaded, isLoading: false);
      
      // Charger les préférences persistées
      await _loadPersistedPrefs();
    } catch (e) {
      state = state.copyWith(error: e.toString(), isLoading: false);
    }
  }

  Future<void> _loadPersistedPrefs() async {
    try {
      final prefs = ref.read(pantryPrefsProvider);
      final householdId = ref.read(householdProvider).id;
      
      final savedSort = await prefs.loadSort(householdId);
      final savedFilter = await prefs.loadFilter(householdId);
      
      if (savedSort != null) {
        // TODO: Implémenter setSort si nécessaire
        // ref.read(pantryFilterProvider.notifier).setSort(savedSort);
      }
      if (savedFilter != null) {
        // TODO: Implémenter setFilter si nécessaire
        // ref.read(pantryFilterProvider.notifier).setFilter(savedFilter);
      }
    } catch (e) {
      // Ignorer les erreurs de préférences
    }
  }

  // ---- CRUD Operations --------------------------------------------------------
  Future<void> addItem(PantryItem item) async {
    try {
      // Mode solo par défaut (pas de foyer)
      await store?.upsert(item);
      final updated = [...state.allItems, item];
      state = state.copyWith(allItems: updated);
      _debouncer.schedule(updated);
      EventBus().emit(PantryChanged({'action':'add','id': item.id}));
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  Future<void> updateItem(PantryItem item) async {
    try {
      await store?.upsert(item);
      final updated = state.allItems.map((i) => i.id == item.id ? item : i).toList();
      state = state.copyWith(allItems: updated);
      _debouncer.schedule(updated);
      EventBus().emit('pantry.changed', {'action':'update','id': item.id});
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  Future<void> deleteItem(String id) async {
    try {
      await store?.deleteItem(id);
      final updated = state.allItems.where((i) => i.id != id).toList();
      state = state.copyWith(allItems: updated);
      _debouncer.schedule(updated);
      EventBus().emit('pantry.changed', {'action':'remove','id': id});
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  // ---- Search & Filter --------------------------------------------------------
  void setSearchText(String text) {
    state = state.copyWith(searchText: text);
  }

  void setSearchTextDebounced(String text) {
    _searchDebouncer?.cancel();
    _searchDebouncer = Timer(const Duration(milliseconds: 300), () {
      state = state.copyWith(searchText: text);
    });
  }

  void toggleFilter(String filter) {
    final filters = Set<String>.from(state.activeFilters);
    if (filters.contains(filter)) {
      filters.remove(filter);
    } else {
      filters.add(filter);
    }
    state = state.copyWith(activeFilters: filters);
  }

  // ---- Recalcul des conseils IA ----------------------------------------------
  Future<void> recomputeAdvisories() async {
    try {
      // Invalider le provider des conseils pour forcer le recalcul
      // Le pantryAdvisoryProvider se chargera du recalcul automatiquement
      // via l'écoute des changements d'items
      EventBus().emit('pantry.advisory.ready', {'count': state.allItems.length});
    } catch (e) {
      state = state.copyWith(error: 'Erreur recalcul conseils: $e');
    }
  }

  void applySmartFilter(String label) {
    // Impl. simple : si libellé contient "périm", on active un filtre interne
    final soon = label.toLowerCase().contains('périm');
    // TODO: Ajouter un champ activeFilterSoonExpired dans PantryState
    // state = state.copyWith(activeFilterSoonExpired: soon);
    // puis re-filtrer items visibles (ex: via un selector existant)
  }

  Future<void> handoffToChef(SimplePantryAdvisory a) async {
    final items = state.allItems; // adapte si tu as un selector d'items visibles
    final now = DateTime.now();
    final soon = items.where((it) =>
      it.expirationDate != null &&
      it.expirationDate!.isBefore(now.add(const Duration(days: 3)))
    ).toList();

    final payload = {
      'intent': 'chef.intent.cook',
      'from': 'pantry',
      'advisory': a.toJson(),
      'context': {
        'available': items.where((it) => (it.quantity ?? 1) > 0)
                          .map((e) => {'id': e.id, 'name': e.name, 'qty': e.quantity, 'exp': e.expirationDate?.toIso8601String()})
                          .toList(),
        'expiringSoon': soon.map((e) => e.id).toList(),
      },
    };

    // EventBus → l'agent Chef écoute et gère la génération de recettes
    EventBus().emit(ChefIntentCook(payload));
  }

  Future<void> handoffToCourses(SimplePantryAdvisory a) async {
    final items = state.allItems; // adapte si tu as un selector 'visible'
    final missing = items.where((it) => (it.quantity ?? 0) <= 0).map((e) => {
      'id': e.id, 'name': e.name, 'qty': e.quantity ?? 0,
      'exp': e.expirationDate?.toIso8601String(),
    }).toList();
    if (missing.isEmpty) return;

    final payload = {
      'intent': 'courses.intent.add',
      'from': 'pantry',
      'advisory': a.toJson(),
      'context': {'missing': missing},
    };

    // EventBus → l'autre agent écoute et gère l'ajout/mapping côté liste de courses
    EventBus().emit(CoursesIntentAdd(payload));
  }

  void navigateForAdvisory(SimplePantryAdvisory a) {
    // stub: navigation interne (catégories, etc.)
    // TODO: Navigation interne
  }

  // ---- Gestion des erreurs ---------------------------------------------------
  void clearError() {
    state = state.copyWith(error: null);
  }

  // ---- Méthodes manquantes pour compatibilité ---------------------------------
  void add(VoidCallback callback) {
    // TODO: Implémenter l'ajout d'item
    callback();
  }

  void scan(VoidCallback callback) {
    // TODO: Implémenter le scan de code-barres
    callback();
  }

  void openItem(PantryItem item, Function(PantryItem) callback) {
    // TODO: Implémenter l'ouverture d'item
    callback(item);
  }

  void showItemMenu(PantryItem item, Function(PantryItem) callback) {
    // TODO: Implémenter le menu d'item
    callback(item);
  }

  void removeItem(String id) {
    deleteItem(id);
  }

  void clearFilters() {
    state = state.copyWith(activeFilters: const {});
  }
}

/// Provider du notifier
final pantryNotifierProvider = StateNotifierProvider<PantryNotifier, PantryState>((ref) {
  final store = ref.watch(pantryStoreProvider);
  return PantryNotifier(store: store);
});

/// Provider des items visibles
final pantryVisibleItemsProvider = Provider<List<PantryItem>>((ref) {
  final state = ref.watch(pantryNotifierProvider);
  return state.visibleItems;
});

/// Provider des IDs visibles
final pantryVisibleIdsProvider = Provider<List<String>>((ref) {
  final items = ref.watch(pantryVisibleItemsProvider);
  return items.map((item) => item.id).toList();
});

/// Provider d'un item par ID
final pantryItemByIdProvider = Provider.family<PantryItem?, String>((ref, id) {
  final items = ref.watch(pantryVisibleItemsProvider);
  try {
    return items.firstWhere((item) => item.id == id);
  } catch (e) {
    return null;
  }
});

/// Sélecteurs granulaires pour les propriétés spécifiques d'un item
final pantryItemNameProvider = Provider.family<String, String>((ref, id) {
  final item = ref.watch(pantryItemByIdProvider(id));
  return item?.name ?? '';
});

final pantryItemQuantityProvider = Provider.family<double?, String>((ref, id) {
  final item = ref.watch(pantryItemByIdProvider(id));
  return item?.quantity;
});

final pantryItemExpiryProvider = Provider.family<DateTime?, String>((ref, id) {
  final item = ref.watch(pantryItemByIdProvider(id));
  return item?.expiry;
});

final pantryItemCategoryProvider = Provider.family<String, String>((ref, id) {
  final item = ref.watch(pantryItemByIdProvider(id));
  return item?.category ?? 'Autre';
});

/// Provider du texte de recherche
final pantrySearchTextProvider = Provider<String>((ref) {
  final state = ref.watch(pantryNotifierProvider);
  return state.searchText;
});

/// Provider des filtres actifs
final pantryActiveFiltersProvider = Provider<Set<String>>((ref) {
  final state = ref.watch(pantryNotifierProvider);
  return state.activeFilters;
});

/// Provider du nombre total d'items
final pantryTotalCountProvider = Provider<int>((ref) {
  final state = ref.watch(pantryNotifierProvider);
  return state.allItems.length;
});

/// Debouncer pour les sauvegardes
class _SaveDebouncer {
  _SaveDebouncer(this._store);
  final PantryStore? _store;
  Timer? _t;
  
  void schedule(List<PantryItem> items) {
    _t?.cancel();
    _t = Timer(const Duration(milliseconds: 500), () async {
      if (_store != null) {
        await _store?.save(items);
      }
    });
  }
  
  void dispose() => _t?.cancel();
}

```

### chef_ia_app/lib/features/pantry/state/pantry_state.dart
```dart
import 'package:flutter/foundation.dart';
// ⚠️ Adapte le chemin d'import selon ton projet.
import 'package:chef_ia_app/models/pantry_item.dart';

@immutable
class PantryState {
  final List<PantryItem> allItems;
  final String searchText;
  final Set<String> activeFilters;
  final bool isLoading;
  final String? error;

  const PantryState({
    this.allItems = const [],
    this.searchText = '',
    this.activeFilters = const {},
    this.isLoading = false,
    this.error,
  });

  PantryState copyWith({
    List<PantryItem>? allItems,
    String? searchText,
    Set<String>? activeFilters,
    bool? isLoading,
    String? error,
  }) {
    return PantryState(
      allItems: allItems ?? this.allItems,
      searchText: searchText ?? this.searchText,
      activeFilters: activeFilters ?? this.activeFilters,
      isLoading: isLoading ?? this.isLoading,
      error: error,
    );
  }

  /// Items filtrés + recherche (exemple simple, adapte la logique à ton besoin)
  List<PantryItem> get visibleItems {
    Iterable<PantryItem> items = allItems;

    if (activeFilters.isNotEmpty) {
      items = items.where((it) {
        // EXEMPLE : on filtre par tags/catégorie s'ils existent
        final tags = it.tags;
        return activeFilters.any(tags.contains);
      });
    }

    final q = searchText.trim().toLowerCase();
    if (q.isNotEmpty) {
      items = items.where((it) =>
          it.name.toLowerCase().contains(q) ||
          it.category.toLowerCase().contains(q));
    }

    return items.toList(growable: false);
  }
}

```

### chef_ia_app/lib/features/pantry/widgets/pantry_advisory_banner.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'package:chef_ia_app/features/pantry/advice/pantry_advisor_provider.dart';
import 'package:chef_ia_app/features/pantry/state/pantry_provider.dart';

class PantryAdvisoryBanner extends ConsumerWidget {
  const PantryAdvisoryBanner({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final advisories = ref.watch(pantryAdvisoryProvider);

    return advisories.when(
      data: (advisories) {
        if (advisories.isEmpty) return const SizedBox.shrink();
        return SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
          child: Row(
            children: [
              for (final a in advisories)
                Padding(
                  padding: const EdgeInsets.only(right: 8),
                  child: ActionChip(
                    label: Text(a.label),
                    onPressed: () {
                      switch (a.type) {
                        case 'FILTER':
                          ref.read(pantryNotifierProvider.notifier).applySmartFilter(a.label);
                          break;
                        case 'HANDOFF_CHEF':
                          ref.read(pantryNotifierProvider.notifier).handoffToChef(a);
                          break;
                        case 'HANDOFF_COURSES':
                          ref.read(pantryNotifierProvider.notifier).handoffToCourses(a);
                          break;
                        case 'NAVIGATE':
                          ref.read(pantryNotifierProvider.notifier).navigateForAdvisory(a);
                          break;
                        // (compatibilité si l'ancien type existe encore quelque part)
                        case 'RECIPE':
                          ref.read(pantryNotifierProvider.notifier).handoffToChef(a);
                          break;
                      }
                    },
                  ),
                ),
            ],
          ),
        );
      },
      loading: () => const SizedBox(height: 4),
      error: (_, __) => const SizedBox.shrink(),
    );
  }
}


```

### chef_ia_app/lib/features/pantry/widgets/pantry_app_bar.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import '../state/pantry_provider.dart';
import '../state/household_provider.dart';

class PantryAppBar extends ConsumerWidget implements PreferredSizeWidget {
  const PantryAppBar({super.key});
  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final total = ref.watch(pantryTotalCountProvider);
    final currentHH = ref.watch(currentHouseholdIdProvider);
    return AppBar(
      title: Text('Garde-manger ($total)'),
      actions: [
        PopupMenuButton<String>(
          key: const Key('pantry_menu_btn'),
          onSelected: (v) async {
            if (v == 'switch') {
              final id = await _pickHouseholdDialog(context, ref);
              if (id != null) {
                ref.read(currentHouseholdIdProvider.notifier).state = id;
                await ref.read(pantryNotifierProvider.notifier).loadInitial();
              }
            } else if (v == 'about') {
              // TODO: Afficher dialog à propos
            }
          },
          itemBuilder: (_) => [
            const PopupMenuItem(value: 'switch', child: Text('Changer de foyer')),
            const PopupMenuItem(value: 'about', child: Text('À propos')),
          ],
        ),
        IconButton(
          key: const Key('pantry_refresh_btn'),
          icon: const Icon(Icons.refresh),
          onPressed: () => ref.read(pantryNotifierProvider.notifier).loadInitial(),
        ),
      ],
    );
  }

  Future<String?> _pickHouseholdDialog(BuildContext context, WidgetRef ref) async {
    final households = ref.read(householdsProvider);
    return showDialog<String>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Choisir un foyer'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ...households.map((h) => ListTile(
              title: Text(h.name),
              onTap: () => Navigator.pop(context, h.id),
            )),
            ListTile(
              leading: const Icon(Icons.add),
              title: const Text('Créer un nouveau foyer'),
              onTap: () async {
                Navigator.pop(context);
                final name = await _createHouseholdDialog(context);
                if (name != null) {
                  final id = 'hh_${const Uuid().v4()}';
                  ref.read(householdsProvider.notifier).createLocal(name, id);
                  Navigator.pop(context, id);
                }
              },
            ),
          ],
        ),
      ),
    );
  }

  Future<String?> _createHouseholdDialog(BuildContext context) async {
    final controller = TextEditingController();
    return showDialog<String>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Créer un foyer'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(hintText: 'Nom du foyer'),
          autofocus: true,
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Annuler')),
          FilledButton(
            onPressed: () => Navigator.pop(context, controller.text.trim()),
            child: const Text('Créer'),
          ),
        ],
      ),
    );
  }
}


```

### chef_ia_app/lib/features/pantry/widgets/pantry_effects.dart
```dart
import 'package:flutter/material.dart';
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod/riverpod.dart';
import '../state/pantry_provider.dart';
import '../advice/pantry_advisor_provider.dart';
import '../../../models/pantry_item.dart';

class PantryEffects extends ConsumerStatefulWidget {
  final Widget child;
  const PantryEffects({super.key, required this.child});
  @override
  ConsumerState<PantryEffects> createState() => _PantryEffectsState();
}

class _PantryEffectsState extends ConsumerState<PantryEffects> with WidgetsBindingObserver {
  late final ProviderSubscription<String?> _removeErrorSub;
  late final ProviderSubscription<List<PantryItem>> _removeItemsSub;
  Timer? _recalcDebounce;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    
    // ✅ OK : listenManual autorisé hors build, penser à dispose()
    _removeErrorSub = ref.listenManual<String?>(
      pantryNotifierProvider.select((s) => s.error),
      (prev, err) {
        if (err != null && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur garde-manger: $err')));
        }
      },
    );
    
    _removeItemsSub = ref.listenManual(
      pantryVisibleItemsProvider,
      (prev, next) {
        // ton effet ici (ex: debounced recompute IA)
        _scheduleRecompute();
      },
    );
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    // ✅ Nettoyage des écoutes manuelles
    _removeErrorSub.close();
    _removeItemsSub.close();
    _recalcDebounce?.cancel();
    super.dispose();
  }

  void _scheduleRecompute() {
    _recalcDebounce?.cancel();
    _recalcDebounce = Timer(const Duration(milliseconds: 300), () async {
      ref.invalidate(pantryAdvisoryProvider);
    });
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      _scheduleRecompute();
    }
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


```

### chef_ia_app/lib/features/pantry/widgets/pantry_empty_state.dart
```dart
import 'package:flutter/material.dart';

class PantryEmptyState extends StatelessWidget {
  final String title;
  final String message;
  final Widget? cta;

  const PantryEmptyState({
    super.key,
    this.title = 'Aucun produit',
    this.message = 'Ajoute tes premiers ingrédients pour commencer.',
    this.cta,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.inventory_outlined, size: 64),
            const SizedBox(height: 12),
            Text(title, style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 8),
            Text(
              message,
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            if (cta != null) ...[
              const SizedBox(height: 16),
              cta!,
            ]
          ],
        ),
      ),
    );
  }
}











```

### chef_ia_app/lib/features/pantry/widgets/pantry_fab.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../state/pantry_provider.dart';

class PantryFab extends ConsumerWidget {
  final VoidCallback? onAdd;
  const PantryFab({super.key, this.onAdd});
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return FloatingActionButton(
      key: const Key('pantry_add_item_fab'),
      onPressed: () => _showAddBottomSheet(context, ref),
      child: const Icon(Icons.add),
    );
  }

  void _showAddBottomSheet(BuildContext context, WidgetRef ref) {
    Feedback.forTap(context); // Haptique léger
    
    showModalBottomSheet(
      context: context,
      showDragHandle: true,
      useSafeArea: true,
      builder: (_) => SafeArea(
        minimum: const EdgeInsets.only(bottom: 12),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              visualDensity: VisualDensity.standard,
              leading: const Icon(Icons.qr_code_scanner_rounded),
              title: const Text('Scanner un code-barres'),
              subtitle: const Text('Utilisez l\'appareil photo pour scanner'),
              onTap: () {
                Feedback.forTap(context);
                Navigator.pop(context);
                // TODO: Implémenter le scan de code-barres
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Scan de code-barres - À implémenter')),
                );
              },
            ),
            ListTile(
              visualDensity: VisualDensity.standard,
              leading: const Icon(Icons.photo_camera_back_rounded),
              title: const Text('Photo / Reconnaissance'),
              subtitle: const Text('Reconnaissance automatique du produit'),
              onTap: () {
                Feedback.forTap(context);
                Navigator.pop(context);
                // TODO: Implémenter la reconnaissance d'image
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Reconnaissance d\'image - À implémenter')),
                );
              },
            ),
            ListTile(
              visualDensity: VisualDensity.standard,
              leading: const Icon(Icons.keyboard_rounded),
              title: const Text('Saisie manuelle'),
              subtitle: const Text('Ajouter un produit manuellement'),
              onTap: () {
                Feedback.forTap(context);
                Navigator.pop(context);
                onAdd?.call();
              },
            ),
          ],
        ),
      ),
    );
  }
}


```

### chef_ia_app/lib/features/pantry/widgets/pantry_filters_bar.dart
```dart
import 'package:flutter/material.dart';

class PantryFiltersBar extends StatelessWidget {
  final String searchText;
  final ValueChanged<String> onSearchChanged;

  /// Ex: chips actifs, tags, etc.
  final List<String> activeFilters;
  final VoidCallback? onClearFilters;
  final Widget? trailing; // ex: bouton scan / tri

  const PantryFiltersBar({
    super.key,
    required this.searchText,
    required this.onSearchChanged,
    this.activeFilters = const [],
    this.onClearFilters,
    this.trailing,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TextField(
          controller: TextEditingController(text: searchText),
          onChanged: onSearchChanged,
          decoration: const InputDecoration(
            hintText: 'Rechercher dans le garde-manger…',
            prefixIcon: Icon(Icons.search),
            border: OutlineInputBorder(),
          ),
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Row(
                  children: activeFilters
                      .map((f) => Padding(
                            padding: const EdgeInsets.only(right: 8.0),
                            child: Chip(label: Text(f)),
                          ))
                      .toList(),
                ),
              ),
            ),
            if (onClearFilters != null && activeFilters.isNotEmpty)
              TextButton.icon(
                onPressed: onClearFilters,
                icon: const Icon(Icons.clear_all),
                label: const Text('Réinitialiser'),
              ),
            if (trailing != null) trailing!,
          ],
        ),
      ],
    );
  }
}











```

### chef_ia_app/lib/features/pantry/widgets/pantry_item_tile.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:chef_ia_app/features/pantry/state/pantry_provider.dart';
import 'package:chef_ia_app/features/pantry/pantry_sender.dart';
import 'package:chef_ia_app/models/pantry_item.dart';

class PantryItemTile extends ConsumerWidget {
  final Widget? leading;
  final String title;
  final String? subtitle;
  final Widget? trailing;
  final VoidCallback? onTap;
  final VoidCallback? onLongPress;
  final PantryItem? item;

  const PantryItemTile({
    super.key,
    this.leading,
    required this.title,
    this.subtitle,
    this.trailing,
    this.onTap,
    this.onLongPress,
    this.item,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListTile(
      leading: leading,
      title: Text(title),
      subtitle: item != null ? _buildSubtitle(item!) : (subtitle != null ? Text(subtitle!) : null),
      trailing: trailing ?? (item != null ? _buildQuickActions(context, ref, item!) : null),
      onTap: onTap,
      onLongPress: onLongPress,
    );
  }

  Widget _buildSubtitle(PantryItem item) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (item.quantity != null) Text('Qté : ${item.quantity!.toInt()}'),
        if (item.expirationDate != null)
          Text('Péremption : ${item.expirationDate!.toLocal().toString().split(' ').first}'),
      ],
    );
  }

  Widget _buildQuickActions(BuildContext context, WidgetRef ref, PantryItem item) {
    return PopupMenuButton<int>(
      onSelected: (v) async {
        if (v == 1) {
          // Consommer −1
          final q = (item.quantity ?? 1.0);
          final newQ = (q > 0) ? q - 1.0 : 0.0;
          await ref.read(pantryNotifierProvider.notifier)
            .updateItem(item.copyWith(quantity: newQ));
        } else if (v == 2) {
          // Supprimer avec Undo
          final removed = item;
          await ref.read(pantryNotifierProvider.notifier).removeItem(item.id);
          if (context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('${item.name} supprimé'),
                action: SnackBarAction(
                  label: 'Annuler',
                  onPressed: () async {
                    // Tentative de restauration avec fallback
                    final store = ref.read(pantryStoreProvider);
                    if (store != null) {
                      final restored = await store.restoreItem(removed.id);
                      if (!restored) {
                        // Si purge entre temps, on re-upsert la copie locale
                        await store.upsert(removed);
                      }
                    } else {
                      // Fallback direct
                      await ref.read(pantryNotifierProvider.notifier).addItem(removed);
                    }
                  },
                ),
              ),
            );
          }
        } else if (v == 3) {
          // Envoyer vers Courses
          try {
            final payload = toPayload(item);
            await sendPantryToCourses({'items': [payload]});
            if (context.mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('${item.name} ajouté à la liste de courses')),
              );
            }
          } catch (e) {
            if (context.mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Erreur: $e')),
              );
            }
          }
        }
      },
      itemBuilder: (_) => const [
        PopupMenuItem(value: 1, child: Text('Consommer (−1)')),
        PopupMenuItem(value: 2, child: Text('Supprimer')),
        PopupMenuItem(value: 3, child: Text('Ajouter à la liste de courses')),
      ],
    );
  }
}

```

### chef_ia_app/lib/features/pantry/widgets/pantry_list_view.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'package:chef_ia_app/features/pantry/state/pantry_provider.dart';
import 'package:chef_ia_app/features/pantry/widgets/pantry_item_tile.dart';
import 'package:chef_ia_app/features/pantry/widgets/pantry_smart_empty_state.dart';
import 'package:chef_ia_app/models/pantry_item.dart';

class PantryListView extends ConsumerWidget {
  const PantryListView({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final ids = ref.watch(pantryVisibleIdsProvider);
    
    // Récupérer les items via les IDs
    final items = ids.map((id) => ref.watch(pantryItemByIdProvider(id))).where((item) => item != null).cast<PantryItem>().toList();
    
    // Tri par date de péremption ascendante (fallback: alpha)
    final sortedItems = List<PantryItem>.from(items);
    sortedItems.sort((a, b) {
      final da = a.expirationDate;
      final db = b.expirationDate;
      if (da != null && db != null) return da.compareTo(db);
      if (da != null) return -1; // ceux avec date en premier
      if (db != null) return 1;
      return a.name.toLowerCase().compareTo(b.name.toLowerCase());
    });

    // Empty state intelligent
    if (sortedItems.isEmpty) {
      return PantrySmartEmptyState(
        onScan: () {
          // TODO: Implémenter le scan
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Scan - À implémenter')),
          );
        },
        onManual: () {
          // TODO: Implémenter la saisie manuelle
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Saisie manuelle - À implémenter')),
          );
        },
        onImport: () {
          // TODO: Implémenter l'import
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Import - À implémenter')),
          );
        },
      );
    }

    return ListView.builder(
      key: const Key('pantry_list_view'),
      itemCount: sortedItems.length,
      prototypeItem: const PantryItemTile(
        title: 'Prototype Item',
        subtitle: 'Prototype subtitle',
      ),
      itemBuilder: (context, index) {
        final item = sortedItems[index];
        return PantryItemTile(
          key: ValueKey(item.id), // Optimisation: ValueKey pour éviter les rebuilds
          item: item,
          leading: _categoryIcon(item.category),
          title: item.name,
          subtitle: [
            if (item.quantity != null) '${item.quantity}',
            if (item.expiry != null) '• ${item.expiry}',
          ].where((s) => s.isNotEmpty).join(' ').isEmpty
              ? null
              : [
                  if (item.quantity != null) '${item.quantity}',
                  if (item.expiry != null) '• ${item.expiry}',
                ].join(' '),
          trailing: _itemActions(context, ref, item.id),
          onTap: () => ref.read(pantryNotifierProvider.notifier).openItem(item, (it) {
            // ton _openItem(it) si tu veux garder la navigation existante
          }),
          onLongPress: () => ref.read(pantryNotifierProvider.notifier).showItemMenu(item, (it) {
            // ton _showContextMenu(it) si besoin
          }),
        );
      },
    );
  }

  Widget _categoryIcon(String? cat) => const Icon(Icons.inventory_2_outlined);

  Widget _itemActions(BuildContext ctx, WidgetRef ref, String id) {
    // Place ton trailing/menu bouton ici si tu veux le standardiser
    return PopupMenuButton<String>(
      onSelected: (v) {
        if (v == 'delete') {
          ref.read(pantryNotifierProvider.notifier).removeItem(id);
        }
      },
      itemBuilder: (context) => const [
        PopupMenuItem(value: 'delete', child: Text('Supprimer')),
      ],
    );
  }
}


```

### chef_ia_app/lib/features/pantry/widgets/pantry_optimized_image.dart
```dart
import 'package:flutter/material.dart';

/// Widget d'image optimisé pour les items du garde-manger
/// Utilise cacheWidth et filterQuality pour de meilleures performances
class PantryOptimizedImage extends StatelessWidget {
  final String? imageUrl;
  final double? width;
  final double? height;
  final BoxFit fit;
  final Widget? placeholder;
  final Widget? errorWidget;

  const PantryOptimizedImage({
    super.key,
    this.imageUrl,
    this.width,
    this.height,
    this.fit = BoxFit.cover,
    this.placeholder,
    this.errorWidget,
  });

  @override
  Widget build(BuildContext context) {
    if (imageUrl == null || imageUrl!.isEmpty) {
      return placeholder ?? _buildPlaceholder();
    }

    return FadeInImage(
      image: NetworkImage(imageUrl!),
      placeholder: MemoryImage(
        // Placeholder transparent 1x1 pixel
        Uint8List.fromList([
          0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
          0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
          0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89, 0x00, 0x00, 0x00,
          0x0A, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00,
          0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x49,
          0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
        ]),
      ),
      imageErrorBuilder: (context, error, stackTrace) => errorWidget ?? _buildErrorWidget(),
      fit: fit,
      width: width,
      height: height,
      // Optimisations de performance
      image: NetworkImage(
        imageUrl!,
        // Cache optimisé pour les vignettes
        headers: const {'Cache-Control': 'max-age=3600'},
      ),
      // Configuration optimisée pour les performances
      fadeInDuration: const Duration(milliseconds: 200),
      fadeOutDuration: const Duration(milliseconds: 100),
    );
  }

  Widget _buildPlaceholder() {
    return Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        color: Colors.grey[200],
        borderRadius: BorderRadius.circular(8),
      ),
      child: const Icon(
        Icons.inventory_2_outlined,
        color: Colors.grey,
        size: 32,
      ),
    );
  }

  Widget _buildErrorWidget() {
    return Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        color: Colors.red[50],
        borderRadius: BorderRadius.circular(8),
      ),
      child: const Icon(
        Icons.error_outline,
        color: Colors.red,
        size: 32,
      ),
    );
  }
}

/// Extension pour optimiser les images existantes
extension ImageOptimization on Image {
  static Widget optimized({
    required String imageUrl,
    double? width,
    double? height,
    BoxFit fit = BoxFit.cover,
  }) {
    return Image.network(
      imageUrl,
      width: width,
      height: height,
      fit: fit,
      // Optimisations de performance
      cacheWidth: width?.toInt(),
      cacheHeight: height?.toInt(),
      filterQuality: FilterQuality.medium,
      // Headers pour le cache
      headers: const {'Cache-Control': 'max-age=3600'},
      // Gestion d'erreur
      errorBuilder: (context, error, stackTrace) => Container(
        width: width,
        height: height,
        decoration: BoxDecoration(
          color: Colors.grey[200],
          borderRadius: BorderRadius.circular(8),
        ),
        child: const Icon(Icons.error_outline, color: Colors.grey),
      ),
    );
  }
}


```

### chef_ia_app/lib/features/pantry/widgets/pantry_smart_empty_state.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// Empty-state intelligent et actionnable pour le garde-manger
class PantrySmartEmptyState extends StatelessWidget {
  final VoidCallback? onScan;
  final VoidCallback? onManual;
  final VoidCallback? onImport;
  final String? title;
  final String? message;

  const PantrySmartEmptyState({
    super.key,
    this.onScan,
    this.onManual,
    this.onImport,
    this.title,
    this.message,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // Icône principale
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.primaryContainer.withOpacity(0.1),
              shape: BoxShape.circle,
            ),
            child: Icon(
              Icons.inventory_2_rounded,
              size: 64,
              color: Theme.of(context).colorScheme.primary,
            ),
          ),
          
          const SizedBox(height: 24),
          
          // Titre
          Text(
            title ?? 'Votre garde-manger est vide',
            style: Theme.of(context).textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.w600,
            ),
            textAlign: TextAlign.center,
          ),
          
          const SizedBox(height: 8),
          
          // Message
          Text(
            message ?? 'Commencez par ajouter des produits en les scannant ou en saisissant les informations manuellement.',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
            textAlign: TextAlign.center,
          ),
          
          const SizedBox(height: 32),
          
          // Actions
          Wrap(
            spacing: 12,
            runSpacing: 12,
            alignment: WrapAlignment.center,
            children: [
              if (onScan != null)
                FilledButton.icon(
                  onPressed: () {
                    Feedback.forTap(context);
                    onScan!();
                  },
                  icon: const Icon(Icons.qr_code_scanner),
                  label: const Text('Scanner'),
                  style: FilledButton.styleFrom(
                    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                  ),
                ),
              
              if (onManual != null)
                OutlinedButton.icon(
                  onPressed: () {
                    Feedback.forTap(context);
                    onManual!();
                  },
                  icon: const Icon(Icons.keyboard),
                  label: const Text('Saisie manuelle'),
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                  ),
                ),
              
              if (onImport != null)
                TextButton.icon(
                  onPressed: () {
                    Feedback.forTap(context);
                    onImport!();
                  },
                  icon: const Icon(Icons.upload_file),
                  label: const Text('Importer'),
                  style: TextButton.styleFrom(
                    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                  ),
                ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Conseil IA
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.5),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Row(
              children: [
                Icon(
                  Icons.lightbulb_outline,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    'Conseil : Scannez les codes-barres pour une reconnaissance automatique des produits.',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

/// Empty-state spécialisé pour les résultats de recherche vides
class PantrySearchEmptyState extends StatelessWidget {
  final String searchQuery;
  final VoidCallback? onClearSearch;

  const PantrySearchEmptyState({
    super.key,
    required this.searchQuery,
    this.onClearSearch,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.search_off,
            size: 48,
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
          
          const SizedBox(height: 16),
          
          Text(
            'Aucun résultat pour "$searchQuery"',
            style: Theme.of(context).textTheme.titleMedium,
            textAlign: TextAlign.center,
          ),
          
          const SizedBox(height: 8),
          
          Text(
            'Essayez avec d\'autres mots-clés ou vérifiez l\'orthographe.',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
            textAlign: TextAlign.center,
          ),
          
          const SizedBox(height: 24),
          
          if (onClearSearch != null)
            FilledButton.icon(
              onPressed: () {
                Feedback.forTap(context);
                onClearSearch!();
              },
              icon: const Icon(Icons.clear),
              label: const Text('Effacer la recherche'),
            ),
        ],
      ),
    );
  }
}


```

### chef_ia_app/lib/models/household.dart
```dart
class Household {
  final String id;         // ex: "hh_<uuid>" ou "local:<deviceId>"
  final String name;       // ex: "Maison Dupont"
  final DateTime createdAt;
  final DateTime updatedAt;
  
  Household({
    required this.id,
    required this.name,
    DateTime? createdAt,
    DateTime? updatedAt,
  })  : createdAt = createdAt ?? DateTime.now(),
        updatedAt = updatedAt ?? DateTime.now();

  Household copyWith({String? id, String? name, DateTime? updatedAt}) =>
      Household(
        id: id ?? this.id, 
        name: name ?? this.name, 
        createdAt: createdAt, 
        updatedAt: updatedAt ?? this.updatedAt
      );

  Map<String, dynamic> toJson() => {
    'id': id, 
    'name': name,
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt.toIso8601String(),
  };
  
  factory Household.fromJson(Map<String, dynamic> j) => Household(
    id: j['id'] as String,
    name: j['name'] as String,
    createdAt: DateTime.parse(j['createdAt']),
    updatedAt: DateTime.parse(j['updatedAt']),
  );
}

```

### chef_ia_app/lib/models/pantry_advisory.dart
```dart
enum AdvisoryType { expireSoon, grace, restock, suggestion }

// Modèle simple pour les conseils de base
class SimplePantryAdvisory {
  final String type;   // ex: 'FILTER' | 'HANDOFF_CHEF' | 'NAVIGATE'
  final String label;  // ex: 'Bientôt périmés', 'Cuisiner: Riz au lait'
  final double? confidence; // 0..1
  final String? source;     // 'local' | 'cloud'
  final String? targetAgent; // 'chef' | 'courses' | ...

  const SimplePantryAdvisory({
    required this.type,
    required this.label,
    this.confidence,
    this.source,
    this.targetAgent,
  });

  Map<String, dynamic> toJson() => {
    'type': type,
    'label': label,
    'confidence': confidence,
    'source': source,
    'targetAgent': targetAgent,
  };

  factory SimplePantryAdvisory.fromJson(Map<String, dynamic> j) => SimplePantryAdvisory(
    type: j['type'] as String,
    label: j['label'] as String,
    confidence: (j['confidence'] as num?)?.toDouble(),
    source: j['source'] as String?,
    targetAgent: j['targetAgent'] as String?,
  );
}

class PantryAdvisoryAction {
  final String action; // e.g. "FILTER","RECIPE","NAVIGATE"
  final Map<String, dynamic> params;
  const PantryAdvisoryAction(this.action, [this.params = const {}]);
  Map<String, dynamic> toJson() => {'action': action, 'params': params};
  factory PantryAdvisoryAction.fromJson(Map<String, dynamic> j) =>
      PantryAdvisoryAction(j['action'] as String, (j['params'] as Map?)?.cast<String, dynamic>() ?? {});
}

class PantryAdvisory {
  final String id;                // unique (ex: type+itemId+date)
  final AdvisoryType type;
  final String title;             // ex: "À consommer bientôt"
  final String body;              // max 3 lignes pour la bulle
  final String? reason; // NEW: explication courte
  final List<String> itemIds;     // items concernés
  final DateTime createdAt;
  final int priority;             // 1=critique, 2=important, 3=info
  final DateTime? notifyAt;       // quand pousser une notif locale (option)
  final List<PantryAdvisoryAction> actions; // NEW: CTAs
  final double? confidence;       // 0..1 pour scoring
  final String? source;           // 'local' | 'cloud'

  const PantryAdvisory({
    required this.id,
    required this.type,
    required this.title,
    required this.body,
    this.reason,
    required this.itemIds,
    required this.createdAt,
    this.priority = 2,
    this.notifyAt,
    this.actions = const [],
    this.confidence,
    this.source,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'body': body,
    'reason': reason,
    'itemIds': itemIds,
    'priority': priority,
    'type': type.name,
    'actions': actions.map((a) => a.toJson()).toList(),
    'confidence': confidence,
    'source': source,
    'schemaVersion': 2,
  };

  factory PantryAdvisory.fromJson(Map<String, dynamic> j) => PantryAdvisory(
    id: j['id'] as String,
    title: j['title'] as String,
    body: j['body'] as String,
    reason: j['reason'] as String?,
    itemIds: (j['itemIds'] as List).map((e) => e as String).toList(),
    priority: j['priority'] as int,
    type: AdvisoryType.values.firstWhere((e) => e.name == j['type']),
    actions: (j['actions'] as List?)
        ?.map((e) => PantryAdvisoryAction.fromJson((e as Map).cast<String, dynamic>()))
        .toList() ?? const [],
    createdAt: DateTime.parse(j['createdAt'] as String),
    notifyAt: j['notifyAt'] != null ? DateTime.parse(j['notifyAt'] as String) : null,
    confidence: (j['confidence'] as num?)?.toDouble(),
    source: j['source'] as String?,
  );
}




```

### chef_ia_app/lib/models/pantry_item.dart
```dart
import 'package:chef_ia_app/core/clock.dart';
import 'package:chef_ia_app/core/grace_policy.dart';
import 'package:uuid/uuid.dart';

const _uuid = Uuid();

enum ExpiryStatus { fresh, soon, expired, grace }

class PantryItem {
  final String id;
  final DateTime createdAt;
  final DateTime updatedAt;
  String name;
  double? quantity;
  String? unit;
  String category;       // "Épicerie", "Frais", "Surgelé", "Boissons", "Autre"
  DateTime? expiry;      // DLC
  String? barcode;       // EAN
  final List<String> photos; // NEW: plusieurs photos
  final List<String> tags;   // NEW
  final String? note;        // NEW
  double? price;
  // Gestion récurrence & péremption
  bool recurring;        // produit racheté souvent (ex: yaourt)
  int?  graceDays;       // jours de tolérance après DLC
  DateTime? lastUpdate;  // dernière synchro/édition
  // Soft delete
  DateTime? deletedAt;   // null = actif, non-null = supprimé
  // NEW: Source tracking
  final String? source;     // ex: "chefia", "courses", "scan"
  final String? householdId; // null => local (appareil seul)
  final DateTime? expirationDate; // date de péremption (nullable)

  PantryItem copyWith({
    String? id,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? name,
    double? quantity,
    String? unit,
    String? category,
    DateTime? expiry,
    String? barcode,
    List<String>? photos,
    List<String>? tags,
    String? note,
    double? price,
    bool? recurring,
    int? graceDays,
    DateTime? lastUpdate,
    DateTime? deletedAt,
    String? source,
    String? householdId,
    DateTime? expirationDate,
  }) {
    return PantryItem(
      id: id ?? this.id,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      name: name ?? this.name,
      quantity: quantity ?? this.quantity,
      unit: unit ?? this.unit,
      category: category ?? this.category,
      expiry: expiry ?? this.expiry,
      barcode: barcode ?? this.barcode,
      photos: photos ?? this.photos,
      tags: tags ?? this.tags,
      note: note ?? this.note,
      price: price ?? this.price,
      recurring: recurring ?? this.recurring,
      graceDays: graceDays ?? this.graceDays,
      lastUpdate: lastUpdate ?? this.lastUpdate,
      deletedAt: deletedAt ?? this.deletedAt,
      source: source ?? this.source,
      householdId: householdId ?? this.householdId,
      expirationDate: expirationDate ?? this.expirationDate,
    );
  }

  factory PantryItem.fromName(String name) => PantryItem(
    id: _uuid.v4(),
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    name: name,
  );

  PantryItem({
    required this.id,
    required this.createdAt,
    required this.updatedAt,
    required this.name,
    this.quantity,
    this.unit,
    this.category = 'Autre',
    this.expiry,
    this.barcode,
    this.photos = const [],
    this.tags = const [],
    this.note,
    this.price,
    this.recurring = false,
    this.graceDays,
    this.lastUpdate,
    this.deletedAt,
    this.source,
    this.householdId,
    this.expirationDate,
  });

  factory PantryItem.fromJson(Map<String, dynamic> json) {
    return PantryItem(
      id: json['id'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      name: json['name'] as String,
      quantity: (json['quantity'] as num?)?.toDouble(),
      unit: json['unit'] as String?,
      category: json['category'] as String? ?? 'Autre',
      expiry: json['expiry'] != null ? DateTime.parse(json['expiry'] as String) : null,
      barcode: json['barcode'] as String?,
      photos: (json['photos'] as List?)?.map((e) => e as String).toList() ?? const [],
      tags: (json['tags'] as List?)?.map((e) => e as String).toList() ?? const [],
      note: json['note'] as String?,
      price: (json['price'] as num?)?.toDouble(),
      recurring: json['recurring'] as bool? ?? false,
      graceDays: json['graceDays'] as int?,
      lastUpdate: json['lastUpdate'] != null ? DateTime.parse(json['lastUpdate'] as String) : null,
      deletedAt: json['deletedAt'] != null ? DateTime.parse(json['deletedAt'] as String) : null,
      source: json['source'] as String?,
      householdId: json['householdId'] as String?,
      expirationDate: json['expirationDate'] != null ? DateTime.parse(json['expirationDate']) : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
      'name': name,
      'quantity': quantity,
      'unit': unit,
      'category': category,
      'expiry': expiry?.toIso8601String(),
      'barcode': barcode,
      'photos': photos,
      'tags': tags,
      'note': note,
      'price': price,
      'recurring': recurring,
      'graceDays': graceDays,
      'lastUpdate': lastUpdate?.toIso8601String(),
      'deletedAt': deletedAt?.toIso8601String(),
      'source': source,
      'householdId': householdId,
      'expirationDate': expirationDate?.toIso8601String(),
      'schemaVersion': 3, // NEW: versionning avec soft delete
    };
  }

  /// Calcule le statut via Clock + GracePolicy (pas d'appel direct à DateTime.now()).
  ExpiryStatus statusWith(Clock clock, GracePolicy policy) {
    if (expiry == null) return ExpiryStatus.fresh;
    final now = clock.now();
    // déjà expiré → vérifier période de grâce
    if (expiry!.isBefore(now)) {
      final daysAfter = now.difference(expiry!).inDays;
      final grace = policy.graceFor(category);
      return daysAfter <= grace ? ExpiryStatus.grace : ExpiryStatus.expired;
    }
    final daysLeft = expiry!.difference(now).inDays;
    if (daysLeft <= 3) return ExpiryStatus.soon;
    return ExpiryStatus.fresh;
  }

  // Méthode pour créer un ID unique
  static String generateId() {
    return DateTime.now().millisecondsSinceEpoch.toString();
  }

  /// Vérifie si l'item est actif (non supprimé)
  bool get isActive => deletedAt == null;

  /// Marque l'item comme supprimé (soft delete)
  PantryItem markAsDeleted() {
    return copyWith(deletedAt: DateTime.now());
  }

  /// Restaure l'item (annule la suppression)
  PantryItem restore() {
    return copyWith(deletedAt: null);
  }


  // Méthodes de conversion pour compatibilité avec l'ancien modèle domain
  factory PantryItem.fromDomainModel(dynamic domainItem) {
    // Si c'est un PantryItem de domain/models/pantry_item.dart
    if (domainItem.runtimeType.toString().contains('PantryItem')) {
      try {
        final product = domainItem.product;
        return PantryItem(
          id: product.id,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
          name: product.name,
          quantity: product.quantity,
          unit: product.unit,
          category: product.tags.isNotEmpty ? product.tags.first : 'Autre',
          expiry: domainItem.expiry,
          barcode: product.id,
          lastUpdate: DateTime.now(),
        );
      } catch (e) {
        // Fallback si la structure est différente
        return PantryItem(
          id: PantryItem.generateId(),
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
          name: 'Produit importé',
          category: 'Autre',
          lastUpdate: DateTime.now(),
        );
      }
    }
    // Fallback par défaut
    return PantryItem(
      id: PantryItem.generateId(),
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      name: 'Produit inconnu',
      category: 'Autre',
      lastUpdate: DateTime.now(),
    );
  }

  // Conversion vers l'ancien modèle domain (si nécessaire)
  Map<String, dynamic> toDomainModel() {
    return {
      'product': {
        'id': barcode ?? id,
        'name': name,
        'brand': null,
        'quantity': quantity,
        'unit': unit,
        'tags': [category],
      },
      'expiry': expiry?.toIso8601String(),
      'allergens': [],
      'ingredients': [],
      'stock': 1,
    };
  }

}

```

### chef_ia_app/lib/models/recipe_option.dart
```dart
// lib/models/recipe_option.dart
class RecipeOption {
  final String id;
  final String title;
  final String style; // simple | raffiné | gastronomique
  final int estTimeMin;
  final String summary;
  final List<String> topIngredients;
  final List<String> sampleSteps;

  RecipeOption({
    required this.id,
    required this.title,
    required this.style,
    required this.estTimeMin,
    required this.summary,
    required this.topIngredients,
    required this.sampleSteps,
  });

  factory RecipeOption.fromJson(Map<String, dynamic> m) {
    return RecipeOption(
      id: (m['id'] ?? '').toString(),
      title: (m['title'] ?? '').toString(),
      style: (m['style'] ?? '').toString(),
      estTimeMin: (m['est_time_min'] ?? 0) is int ? m['est_time_min'] as int : 0,
      summary: (m['summary'] ?? '').toString(),
      topIngredients: (m['top_ingredients'] as List?)?.map((e) => e.toString()).toList() ?? const [],
      sampleSteps: (m['sample_steps'] as List?)?.map((e) => e.toString()).toList() ?? const [],
    );
  }
}

```

### chef_ia_app/lib/models/mappers/shopping_item_mapper.dart
```dart
import 'package:shared_models/shared_models.dart';
import '../shopping_item.dart'; // adapte vers ton entity Isar réelle

extension ShoppingItemMapper on ShoppingItem {
  ShoppingItemDto toDto() => ShoppingItemDto(
    id: id,
    name: name,
    quantity: quantity,
    done: done,
    pantryLinkBarcode: pantryLinkBarcode,
  );
}

extension ShoppingItemDtoMapper on ShoppingItemDto {
  ShoppingItem toIsar() => ShoppingItem(
    id: id,
    name: name,
    quantity: quantity,
    done: done,
    pantryLinkBarcode: pantryLinkBarcode,
  );
}





```

### chef_ia_app/lib/providers/grace_policy_provider.dart
```dart
// lib/providers/grace_policy_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:chef_ia_app/core/grace_policy.dart';

final gracePolicyProvider =
    NotifierProvider<GracePolicyNotifier, GracePolicy>(GracePolicyNotifier.new);

class GracePolicyNotifier extends Notifier<GracePolicy> {
  @override
  GracePolicy build() => const GracePolicy();

  void setGraceByCategory(Map<String, int> map) {
    state = GracePolicy(graceByCategory: Map.of(map), defaultGraceDays: state.defaultGraceDays);
  }

  void setDefault(int days) {
    state = GracePolicy(graceByCategory: state.graceByCategory, defaultGraceDays: days);
  }
}












```

### chef_ia_app/lib/providers/pantry_prefs_provider.dart
```dart
// lib/providers/pantry_prefs_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

class PantryPrefs {
  final bool useCloud;
  final bool privacyCloud;
  final int topK;
  final Map<String, int> graceByCategory;

  const PantryPrefs({
    required this.useCloud,
    required this.privacyCloud,
    required this.topK,
    required this.graceByCategory,
  });

  PantryPrefs copyWith({
    bool? useCloud,
    bool? privacyCloud,
    int? topK,
    Map<String, int>? graceByCategory,
  }) {
    return PantryPrefs(
      useCloud: useCloud ?? this.useCloud,
      privacyCloud: privacyCloud ?? this.privacyCloud,
      topK: topK ?? this.topK,
      graceByCategory: graceByCategory ?? this.graceByCategory,
    );
  }

  Map<String, Object?> toMap() => {
        'useCloud': useCloud,
        'privacyCloud': privacyCloud,
        'topK': topK,
        'graceByCategory': graceByCategory,
      };

  static PantryPrefs fromMap(Map<String, Object?> m) => PantryPrefs(
        useCloud: m['useCloud'] as bool? ?? true,
        privacyCloud: m['privacyCloud'] as bool? ?? true,
        topK: m['topK'] as int? ?? 10,
        graceByCategory: (m['graceByCategory'] as Map?)?.cast<String, int>() ??
            const {
              'frais': 2,
              'charcuterie': 0,
              'viande': 0,
              'poisson': 0,
              'épicerie': 7,
              'boissons': 7,
              'surgelé': 30,
            },
      );
}

final pantryPrefsProvider =
    NotifierProvider<PantryPrefsNotifier, PantryPrefs>(PantryPrefsNotifier.new);

class PantryPrefsNotifier extends Notifier<PantryPrefs> {
  static const _kUseCloud = 'pantry.useCloud';
  static const _kPrivacy = 'pantry.privacyCloud';
  static const _kTopK = 'pantry.topK';
  static const _kGrace = 'pantry.graceByCategory';

  late SharedPreferences _sp;

  @override
  PantryPrefs build() {
    // Valeurs par défaut synchrones (seront écrasées après load async)
    final defaults = PantryPrefs.fromMap(const {});
    _load();
    return defaults;
  }

  Future<void> _load() async {
    _sp = await SharedPreferences.getInstance();
    final useCloud = _sp.getBool(_kUseCloud) ?? true;
    final privacy = _sp.getBool(_kPrivacy) ?? true;
    final topK = _sp.getInt(_kTopK) ?? 10;

    final graceRaw = _sp.getStringList(_kGrace);
    Map<String, int> graceByCat;
    if (graceRaw == null) {
      graceByCat = PantryPrefs.fromMap(const {}).graceByCategory;
    } else {
      graceByCat = {
        for (final e in graceRaw)
          e.split('=').first: int.tryParse(e.split('=').last) ?? 0
      };
    }
    state = PantryPrefs(
      useCloud: useCloud,
      privacyCloud: privacy,
      topK: topK,
      graceByCategory: graceByCat,
    );
  }

  Future<void> updateFromMap(Map<String, dynamic> m) async {
    final next = state.copyWith(
      useCloud: m['useCloud'] as bool?,
      privacyCloud: m['privacyCloud'] as bool?,
      topK: m['topK'] as int?,
      graceByCategory: (m['graceByCategory'] as Map?)?.cast<String, int>(),
    );
    state = next;
    await _persist(next);
  }

  Future<void> _persist(PantryPrefs p) async {
    await _sp.setBool(_kUseCloud, p.useCloud);
    await _sp.setBool(_kPrivacy, p.privacyCloud);
    await _sp.setInt(_kTopK, p.topK);
    await _sp.setStringList(
      _kGrace,
      p.graceByCategory.entries.map((e) => '${e.key}=${e.value}').toList(),
    );
  }
}












```

### chef_ia_app/lib/providers/pantry_silent_agent_provider.dart
```dart
// lib/providers/pantry_silent_agent_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:chef_ia_app/agents/pantry_silent_agent.dart';
import 'package:chef_ia_app/core/grace_policy.dart';
import 'package:chef_ia_app/services/ai/pantry_advisor_v2.dart';
import 'package:chef_ia_app/services/ai/local_pantry_advisor_v2.dart';
import 'package:chef_ia_app/services/ai/cloud_pantry_advisor_v2.dart';
import 'package:chef_ia_app/services/ai/cloud_client.dart';
import 'package:chef_ia_app/core/clock.dart';

/// Client cloud factice pour démarrer (à remplacer par ton vrai client)
class DummyCloudClient implements PantryCloudClient {
  @override
  Future<List<Map<String, dynamic>>> advise(Map<String, dynamic> payload, {Duration timeout = const Duration(seconds: 2)}) async {
    // Simule un échec pour exercer le fallback local en dev
    throw Exception('dummy cloud not implemented');
  }
}

final pantrySilentAgentProvider = Provider<PantrySilentAgent>((ref) {
  final grace = const GracePolicy();
  final local = LocalPantryAdvisor(clock: const SystemClock(), policy: grace, topK: 10);
  final cloud = CloudPantryAdvisorV2(client: DummyCloudClient(), fallback: local);
  final agent = PantrySilentAgent(local: local, cloud: cloud, grace: grace);
  agent.start();
  ref.onDispose(agent.stop);
  return agent;
});












```

### chef_ia_app/lib/screens/home_screen.dart
```dart
// lib/home_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';

import '../ui/widgets/bottom_gutter.dart';
import '../ui/responsive.dart';
import '../router.dart';

import '../ui/screens/pantry_screen.dart';
import '../equipment_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  bool _navigating = false;

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      onWillPop: () async {
        final canPop = GoRouter.of(context).canPop();
        // Si on est à la racine → ne pas fermer l'app
        if (!canPop) {
          // Option: afficher un toast ou rester sur l'écran
          return false;
        }
        return true;
      },
      child: Scaffold(
        // plus d'AppBar, on laisse le header s'occuper du titre
        bottomNavigationBar: const BottomGutter(),
        body: SafeArea(
          child: SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
            physics: const BouncingScrollPhysics(),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                _welcomeHeader(),
                const SizedBox(height: 24),
                _quickActionsSection(),
                const SizedBox(height: 12),
                _settingsSection(),
              ],
            ),
          ),
        ),
      ),
    );
  }

  /// En-tête de bienvenue
  Widget _welcomeHeader() {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.primaryContainer.withValues(alpha: 0.28),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Theme.of(context).colorScheme.shadow.withValues(alpha: 0.08),
            blurRadius: 12,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.restaurant, size: 28, color: Theme.of(context).colorScheme.primary),
          const SizedBox(height: 8),
          Text(
            'Bienvenue chez ChefIA !',
            style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.w700,
                  color: Theme.of(context).colorScheme.onPrimaryContainer,
                ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 4),
          Text(
            'Votre assistant culinaire personnel',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onPrimaryContainer.withValues(alpha: 0.85),
                ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  /// Section des actions rapides
  Widget _quickActionsSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Actions rapides',
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.w700,
          ),
        ),
        const SizedBox(height: 16),
        GridView.count(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          crossAxisCount: 2,
          mainAxisSpacing: 16,
          crossAxisSpacing: 16,
          childAspectRatio: 1.1,
          children: [
            _buildActionTile(
              context,
              icon: Icons.restaurant_menu_rounded,
              label: 'Créer une recette\nChat cuisine',
              key: const Key('btn_home_create_recipe'),
              onTap: () {
                // trace pour l'explorateur/logcat
                // ignore: avoid_print
                print('[NAV] -> /create');
                context.push('/create');
              },
            ),
            _buildActionTile(
              context,
              icon: Icons.inventory_2_rounded,
              label: 'Garde-manger',
              key: const Key('btn_home_pantry'),
              onTap: () {
                print('[NAV] -> /pantry');
                context.push('/pantry');
              },
            ),
            _buildActionTile(
              context,
              icon: Icons.bookmark_rounded,
              label: 'Recettes archivées',
              key: const Key('btn_home_archives'),
              onTap: () {
                print('[NAV] -> /archives');
                context.push('/archives');
              },
            ),
            _buildActionTile(
              context,
              icon: Icons.kitchen_rounded,
              label: 'Mon matériel',
              key: const Key('btn_home_equipment'),
              onTap: () {
                print('[NAV] -> /equipment');
                context.push('/equipment');
              },
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildActionTile(
    BuildContext context, {
    required IconData icon,
    required String label,
    required VoidCallback onTap,
    Key? key,
  }) {
    return Semantics(
      button: true,
      label: label.replaceAll('\n', ' '),
      child: Card(
        key: key,
        color: Theme.of(context).colorScheme.surface,
        surfaceTintColor: Theme.of(context).colorScheme.primary,
        elevation: 2,
        shadowColor: Theme.of(context).shadowColor,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        clipBehavior: Clip.antiAlias,
        child: InkWell(
          borderRadius: BorderRadius.circular(16),
          mouseCursor: SystemMouseCursors.click,
          overlayColor: MaterialStateProperty.resolveWith((states) {
            final c = Theme.of(context).colorScheme.primary;
            if (states.contains(MaterialState.pressed)) return c.withValues(alpha: 0.14);
            if (states.contains(MaterialState.hovered)) return c.withValues(alpha: 0.08);
            if (states.contains(MaterialState.focused)) return c.withValues(alpha: 0.12);
            return null;
          }),
          onTap: () {
            HapticFeedback.selectionClick(); // petit retour haptique
            onTap();
          },
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 14),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(icon, size: 26, color: Theme.of(context).colorScheme.primary),
                const SizedBox(height: 10),
                Text(
                  label,
                  textAlign: TextAlign.center,
                  style: Theme.of(context).textTheme.titleSmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurface,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  /// Section des paramètres
  Widget _settingsSection() {
    return Card(
      elevation: 1,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.settings, size: 20, color: Theme.of(context).colorScheme.primary),
                const SizedBox(width: 8),
                Text("Paramètres & Cuisine",
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Text("Préférences utilisateur\nStyle, régime, allergies, budget, temps…"),
            Divider(height: 24, color: Theme.of(context).colorScheme.outlineVariant),
            Text("Matériel & garde-manger\nUstensiles disponibles + ingrédients de base"),
          ],
        ),
      ),
    );
  }
}






// Test 09/14/2025 15:30:54

```

### chef_ia_app/lib/screens/user_prefs_screen.dart
```dart
import 'package:flutter/material.dart';
import '../data/user_prefs_store.dart';
import '../core/prompt/prompt_builder.dart';
import '../ui/screens/logs_screen.dart';
import '../core/dev_logger.dart';
import '../core/theme/theme_controller.dart';
import '../ui/widgets/bottom_gutter.dart';

class UserPrefsScreen extends StatefulWidget {
  const UserPrefsScreen({super.key});

  @override
  State<UserPrefsScreen> createState() => _UserPrefsScreenState();
}

class _UserPrefsScreenState extends State<UserPrefsScreen> {
  UserPrefs _prefs = const UserPrefs();
  bool _loading = true;

  final _dietCtrl = TextEditingController();
  final _servingsCtrl = TextEditingController();
  final _timeCtrl = TextEditingController();
  final _allergenCtrl = TextEditingController();
  final _dislikeCtrl = TextEditingController();

  @override
  void initState() {
    super.initState();
    _load();
  }

  @override
  void dispose() {
    _dietCtrl.dispose();
    _servingsCtrl.dispose();
    _timeCtrl.dispose();
    _allergenCtrl.dispose();
    _dislikeCtrl.dispose();
    super.dispose();
  }

  Future<void> _load() async {
    final p = await UserPrefsStore.load();
    setState(() {
      _prefs = p;
      _loading = false;
      _dietCtrl.text = p.diet ?? '';
      _servingsCtrl.text = p.servings?.toString() ?? '';
      _timeCtrl.text = p.timeLimitMin?.toString() ?? '';
    });
  }

  Future<void> _save(UserPrefs p) async {
    setState(() => _prefs = p);
    await UserPrefsStore.save(p);
  }

  void _addToList(TextEditingController ctrl, List<String> list, bool isAllergen) {
    final v = ctrl.text.trim();
    if (v.isEmpty) return;
    final newList = [...list, v];
    ctrl.clear();
    _save(_prefs.copyWith(
      avoidAllergens: isAllergen ? newList : _prefs.avoidAllergens,
      dislikes: isAllergen ? _prefs.dislikes : newList,
    ));
  }

  void _removeFromList(int i, bool isAllergen) {
    final list = isAllergen ? _prefs.avoidAllergens : _prefs.dislikes;
    final newList = [...list]..removeAt(i);
    _save(_prefs.copyWith(
      avoidAllergens: isAllergen ? newList : _prefs.avoidAllergens,
      dislikes: isAllergen ? _prefs.dislikes : newList,
    ));
  }

  @override
  Widget build(BuildContext context) {
    if (_loading) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }

    return Scaffold(
      appBar: AppBar(title: const Text('Préférences utilisateur')),
      bottomNavigationBar: const BottomGutter(),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          _Card(
            title: 'Général',
            child: Column(
              children: [
                _RowInput(
                  label: 'Langue',
                  child: DropdownButton<String>(
                    value: _prefs.language,
                    items: const [
                      DropdownMenuItem(value: 'fr', child: Text('Français')),
                      DropdownMenuItem(value: 'en', child: Text('English')),
                    ],
                    onChanged: (v) {
                      if (v == null) return;
                      _save(_prefs.copyWith(language: v));
                    },
                  ),
                ),
                const SizedBox(height: 8),
                _RowInput(
                  label: 'Personnes (défaut)',
                  child: SizedBox(
                    width: 120,
                    child: TextField(
                      controller: _servingsCtrl,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(hintText: 'ex: 2'),
                      onChanged: (v) => _save(_prefs.copyWith(
                        servings: int.tryParse(v),
                      )),
                    ),
                  ),
                ),
                const SizedBox(height: 8),
                _RowInput(
                  label: 'Temps max (min)',
                  child: SizedBox(
                    width: 120,
                    child: TextField(
                      controller: _timeCtrl,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(hintText: 'ex: 30'),
                      onChanged: (v) => _save(_prefs.copyWith(
                        timeLimitMin: int.tryParse(v),
                      )),
                    ),
                  ),
                ),
                const SizedBox(height: 8),
                _RowInput(
                  label: 'Budget',
                  child: DropdownButton<String>(
                    value: _prefs.budget,
                    items: const [
                      DropdownMenuItem(value: 'bas', child: Text('Bas')),
                      DropdownMenuItem(value: 'moyen', child: Text('Moyen')),
                      DropdownMenuItem(value: 'élevé', child: Text('Élevé')),
                    ],
                    onChanged: (v) {
                      if (v == null) return;
                      _save(_prefs.copyWith(budget: v));
                    },
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          _Card(
            title: 'Accessibilité',
            child: Column(
              children: [
                // Contraste élevé (daltonien-friendly)
                SwitchListTile(
                  title: const Text('Contraste élevé (daltonien)'),
                  subtitle: const Text('Couleurs sûres + lisibilité renforcée'),
                  value: ThemeController.instance.highContrast,
                  onChanged: (v) => ThemeController.instance.setHighContrast(v),
                ),
                
                // Taille du texte
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text('Taille du texte'),
                    Slider(
                      value: ThemeController.instance.textScale,
                      min: 1.0, max: 1.6, divisions: 6,
                      label: '${(ThemeController.instance.textScale * 100).round()}%',
                      onChanged: (v) => ThemeController.instance.setTextScale(v),
                    ),
                  ],
                ),
                
                // Réduire les animations (prévention malaise visuel, TDA/H)
                SwitchListTile(
                  title: const Text('Réduire les animations'),
                  subtitle: const Text('Transitions simplifiées'),
                  value: ThemeController.instance.reduceMotion,
                  onChanged: (v) => ThemeController.instance.setReduceMotion(v),
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          _Card(
            title: 'Paramètres & Cuisine',
            child: Column(
              children: [
                _RowInput(
                  label: 'Style de plats',
                  child: Wrap(
                    spacing: 8,
                    children: [
                      for (final s in ['simple','raffiné','gastronomique','mixte'])
                        ChoiceChip(
                          label: Text(s),
                          selected: _prefs.style == s,
                          onSelected: (_) => _save(_prefs.copyWith(style: s)),
                        ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          _Card(
            title: 'Régime / Allergies / Dislikes',
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _RowInput(
                  label: 'Régime',
                  child: SizedBox(
                    width: 240,
                    child: TextField(
                      controller: _dietCtrl,
                      decoration: const InputDecoration(hintText: 'ex: végétarien, halal, sans gluten'),
                      onChanged: (v) => _save(_prefs.copyWith(diet: v.isEmpty ? null : v)),
                    ),
                  ),
                ),
                const SizedBox(height: 12),
                Text('Allergènes à éviter'),
                const SizedBox(height: 6),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    for (int i = 0; i < _prefs.avoidAllergens.length; i++)
                      Chip(
                        label: Text(_prefs.avoidAllergens[i]),
                        onDeleted: () => _removeFromList(i, true),
                      ),
                    SizedBox(
                      width: 240,
                      child: TextField(
                        controller: _allergenCtrl,
                        decoration: const InputDecoration(hintText: 'Ajouter un allergène'),
                        onSubmitted: (_) => _addToList(_allergenCtrl, _prefs.avoidAllergens, true),
                      ),
                    )
                  ],
                ),
                const SizedBox(height: 12),
                Text('Ingrédients non aimés'),
                const SizedBox(height: 6),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    for (int i = 0; i < _prefs.dislikes.length; i++)
                      Chip(
                        label: Text(_prefs.dislikes[i]),
                        onDeleted: () => _removeFromList(i, false),
                      ),
                    SizedBox(
                      width: 240,
                      child: TextField(
                        controller: _dislikeCtrl,
                        decoration: const InputDecoration(hintText: 'Ajouter un ingrédient'),
                        onSubmitted: (_) => _addToList(_dislikeCtrl, _prefs.dislikes, false),
                      ),
                    )
                  ],
                ),
              ],
            ),
          ),
          const SizedBox(height: 20),
          _Card(
            title: 'Développement',
            child: Column(
              children: [
                SwitchListTile(
                  title: const Text("Mode bêta-test"),
                  subtitle: const Text("Active le logging étendu pour les tests"),
                  value: DevLogger.betaMode,
                  onChanged: (val) {
                    DevLogger.betaMode = val;
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text(val
                            ? "Mode bêta-test activé ✅"
                            : "Mode bêta-test désactivé ❌"),
                      ),
                    );
                    setState(() {}); // refresh visuel
                  },
                ),
                ListTile(
                  leading: const Icon(Icons.bug_report),
                  title: const Text("Journal technique"),
                  subtitle: const Text("Voir / partager les logs, envoyer un retour"),
                  onTap: () => Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => const LogsScreen()),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _RowInput extends StatelessWidget {
  final String label;
  final Widget child;
  const _RowInput({required this.label, required this.child});

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        SizedBox(width: 160, child: Text(label)),
        const SizedBox(width: 12),
        child,
      ],
    );
  }
}

class _Card extends StatelessWidget {
  final String title;
  final Widget child;
  const _Card({required this.title, required this.child});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(14),
      decoration: BoxDecoration(
        border: Border.all(color: Theme.of(context).dividerColor.withOpacity(0.4)),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
        Text(title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
        const SizedBox(height: 8),
        child,
      ]),
    );
  }
}

extension on UserPrefs {
  UserPrefs copyWith({
    String? language,
    int? servings,
    String? diet,
    List<String>? avoidAllergens,
    List<String>? dislikes,
    String? style,
    int? timeLimitMin,
    String? budget,
  }) {
    return UserPrefs(
      language: language ?? this.language,
      servings: servings ?? this.servings,
      diet: diet ?? this.diet,
      avoidAllergens: avoidAllergens ?? this.avoidAllergens,
      dislikes: dislikes ?? this.dislikes,
      style: style ?? this.style,
      timeLimitMin: timeLimitMin ?? this.timeLimitMin,
      budget: budget ?? this.budget,
    );
  }
}

```

### chef_ia_app/lib/screens/user_profile_screen.dart
```dart
import 'package:flutter/material.dart';
import '../core/models/user_models.dart';
import '../data/user_profile_store.dart';

class UserProfileScreen extends StatefulWidget {
  const UserProfileScreen({super.key});

  @override
  State<UserProfileScreen> createState() => _UserProfileScreenState();
}

class _UserProfileScreenState extends State<UserProfileScreen> {
  UserProfile? _currentProfile;
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _loadCurrentUser();
  }

  Future<void> _loadCurrentUser() async {
    final profile = await UserProfileStore.getCurrentUser();
    setState(() {
      _currentProfile = profile;
      _loading = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_loading) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    if (_currentProfile == null) {
      return _buildCreateUserScreen();
    }

    return _buildProfileScreen();
  }

  Widget _buildCreateUserScreen() {
    final nameController = TextEditingController();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Créer un profil'),
        backgroundColor: Theme.of(context).colorScheme.primaryContainer,
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text(
              'Bienvenue dans ChefIA !',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            const Text(
              'Créons votre profil personnalisé pour des recettes adaptées à vos goûts et besoins.',
              style: TextStyle(fontSize: 16),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            TextField(
              controller: nameController,
              decoration: const InputDecoration(
                labelText: 'Votre prénom (optionnel)',
                border: OutlineInputBorder(),
                hintText: 'Ex: Marie, Thomas...',
              ),
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () async {
                final profile = await UserProfileStore.createUser(
                  displayName: nameController.text.trim().isEmpty 
                      ? null 
                      : nameController.text.trim(),
                );
                setState(() {
                  _currentProfile = profile;
                });
              },
                             style: ElevatedButton.styleFrom(
                 backgroundColor: Theme.of(context).colorScheme.primary,
                 foregroundColor: Theme.of(context).colorScheme.onPrimary,
                 padding: const EdgeInsets.symmetric(vertical: 16),
               ),
              child: const Text(
                'Créer mon profil',
                style: TextStyle(fontSize: 18),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildProfileScreen() {
    return Scaffold(
             appBar: AppBar(
         title: Text('Profil de ${_currentProfile!.displayName ?? 'Chef'}'),
         backgroundColor: Theme.of(context).colorScheme.primaryContainer,
         actions: [
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () => _showSettingsDialog(),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildProfileHeader(),
            const SizedBox(height: 24),
            _buildFoodPreferencesSection(),
            const SizedBox(height: 24),
            _buildHealthConstraintsSection(),
            const SizedBox(height: 24),
            _buildStyleSection(),
            const SizedBox(height: 24),
            _buildConsentsSection(),
            const SizedBox(height: 32),
            _buildActionsSection(),
          ],
        ),
      ),
    );
  }

  Widget _buildProfileHeader() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          children: [
                         CircleAvatar(
               radius: 30,
               backgroundColor: Theme.of(context).colorScheme.primaryContainer,
               child: Text(
                (_currentProfile!.displayName ?? 'C').substring(0, 1).toUpperCase(),
                style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    _currentProfile!.displayName ?? 'Chef',
                    style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                  ),
                                     Text(
                     'Membre depuis ${_formatDate(_currentProfile!.createdAt)}',
                     style: TextStyle(color: Theme.of(context).colorScheme.onSurfaceVariant),
                   ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFoodPreferencesSection() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                                 Icon(Icons.restaurant, color: Theme.of(context).colorScheme.primary),
                const SizedBox(width: 8),
                const Text(
                  'Préférences culinaires',
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.edit),
                  onPressed: () => _showFoodPreferencesDialog(),
                ),
              ],
            ),
            const SizedBox(height: 16),
            _buildLikesDislikes(),
            const SizedBox(height: 16),
            _buildStyleSliders(),
            const SizedBox(height: 16),
            _buildGoals(),
          ],
        ),
      ),
    );
  }

  Widget _buildLikesDislikes() {
    return Row(
      children: [
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text('J\'aime', style: TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                children: _currentProfile!.foodPrefs.likes.map((like) => 
                    Chip(label: Text(like), backgroundColor: Theme.of(context).colorScheme.primaryContainer))
                    .toList(),
              ),
            ],
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text('Je n\'aime pas', style: TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                               children: _currentProfile!.foodPrefs.dislikes.map((dislike) => 
                   Chip(label: Text(dislike), backgroundColor: Theme.of(context).colorScheme.errorContainer))
                   .toList(),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildStyleSliders() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('Style culinaire', style: TextStyle(fontWeight: FontWeight.bold)),
        const SizedBox(height: 8),
        _buildSlider('Épices', _currentProfile!.foodPrefs.styleSliders['epice'] ?? 1, (value) {
          _updateStyleSlider('epice', value.round());
        }),
        _buildSlider('Acidité', _currentProfile!.foodPrefs.styleSliders['acidite'] ?? 1, (value) {
          _updateStyleSlider('acidite', value.round());
        }),
        _buildSlider('Gras', _currentProfile!.foodPrefs.styleSliders['gras'] ?? 1, (value) {
          _updateStyleSlider('gras', value.round());
        }),
        _buildSlider('Croquant', _currentProfile!.foodPrefs.styleSliders['croquant'] ?? 1, (value) {
          _updateStyleSlider('croquant', value.round());
        }),
      ],
    );
  }

  Widget _buildSlider(String label, int value, ValueChanged<double> onChanged) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        children: [
          SizedBox(width: 80, child: Text(label)),
          Expanded(
            child: Slider(
              value: value.toDouble(),
              min: 0,
              max: 3,
              divisions: 3,
              onChanged: onChanged,
            ),
          ),
          SizedBox(width: 30, child: Text('$value')),
        ],
      ),
    );
  }

  Widget _buildGoals() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('Objectifs', style: TextStyle(fontWeight: FontWeight.bold)),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
                         children: _currentProfile!.foodPrefs.goals.map((goal) => 
                   Chip(label: Text(goal), backgroundColor: Theme.of(context).colorScheme.secondaryContainer))
                   .toList(),
        ),
      ],
    );
  }

  Widget _buildHealthConstraintsSection() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.health_and_safety, color: Theme.of(context).colorScheme.primary),
                const SizedBox(width: 8),
                const Text(
                  'Contraintes de santé',
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.edit),
                  onPressed: () => _showHealthConstraintsDialog(),
                ),
              ],
            ),
            const SizedBox(height: 16),
            if (_currentProfile!.health.allergens.isNotEmpty) ...[
              const Text('Allergènes', style: TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                               children: _currentProfile!.health.allergens.map((allergen) => 
                   Chip(label: Text(allergen), backgroundColor: Theme.of(context).colorScheme.errorContainer))
                   .toList(),
              ),
              const SizedBox(height: 16),
            ],
            if (_currentProfile!.health.healthFlags.isNotEmpty) ...[
              const Text('Conditions santé', style: TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                               children: _currentProfile!.health.healthFlags.map((flag) => 
                   Chip(label: Text(flag), backgroundColor: Theme.of(context).colorScheme.primaryContainer))
                   .toList(),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildStyleSection() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                                 Icon(Icons.person, color: Theme.of(context).colorScheme.primary),
                const SizedBox(width: 8),
                const Text(
                  'Style de communication',
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.edit),
                  onPressed: () => _showStyleDialog(),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Text('Pronoms: ${_currentProfile!.style.preferredPronouns == 'tu' ? 'Tu' : 'Vous'}'),
            const SizedBox(height: 8),
            Text('Emojis: ${_currentProfile!.style.useEmojis ? 'Activés' : 'Désactivés'}'),
            const SizedBox(height: 8),
            Text('Style: ${_currentProfile!.style.greetingStyle}'),
          ],
        ),
      ),
    );
  }

  Widget _buildConsentsSection() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                                 Icon(Icons.privacy_tip, color: Theme.of(context).colorScheme.primary),
                const SizedBox(width: 8),
                const Text(
                  'Confidentialité',
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.edit),
                  onPressed: () => _showConsentsDialog(),
                ),
              ],
            ),
            const SizedBox(height: 16),
            _buildConsentItem('Nom dans le cloud', _currentProfile!.consents.allowNameInCloud),
            _buildConsentItem('Style dans le cloud', _currentProfile!.consents.allowStyleHintInCloud),
            _buildConsentItem('Données santé', _currentProfile!.consents.allowHealthDataInCloud),
            _buildConsentItem('Apprentissage', _currentProfile!.consents.allowLearningFromFeedback),
          ],
        ),
      ),
    );
  }

  Widget _buildConsentItem(String label, bool value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        children: [
          Expanded(child: Text(label)),
          Switch(
            value: value,
            onChanged: (newValue) => _updateConsent(label, newValue),
          ),
        ],
      ),
    );
  }

  Widget _buildActionsSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        ElevatedButton(
          onPressed: () => _showUserSwitcher(),
                     style: ElevatedButton.styleFrom(
             backgroundColor: Theme.of(context).colorScheme.secondary,
             foregroundColor: Theme.of(context).colorScheme.onSecondary,
             padding: const EdgeInsets.symmetric(vertical: 16),
           ),
          child: const Text('Changer d\'utilisateur'),
        ),
        const SizedBox(height: 8),
        OutlinedButton(
          onPressed: () => _showDeleteConfirmation(),
                     style: OutlinedButton.styleFrom(
             foregroundColor: Theme.of(context).colorScheme.error,
             padding: const EdgeInsets.symmetric(vertical: 16),
           ),
          child: const Text('Supprimer ce profil'),
        ),
      ],
    );
  }

  // Méthodes utilitaires
  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }

  void _updateStyleSlider(String key, int value) {
    if (_currentProfile == null) return;

    final updatedSliders = Map<String, int>.from(_currentProfile!.foodPrefs.styleSliders);
    updatedSliders[key] = value;

    final updatedPrefs = _currentProfile!.foodPrefs.copyWith(styleSliders: updatedSliders);
    final updatedProfile = _currentProfile!.copyWith(foodPrefs: updatedPrefs);

    setState(() {
      _currentProfile = updatedProfile;
    });

    UserProfileStore.updateFoodPreferences(updatedProfile.userId, updatedPrefs);
  }

  void _updateConsent(String label, bool value) {
    if (_currentProfile == null) return;

    UserConsents updatedConsents;
    switch (label) {
      case 'Nom dans le cloud':
        updatedConsents = _currentProfile!.consents.copyWith(allowNameInCloud: value);
        break;
      case 'Style dans le cloud':
        updatedConsents = _currentProfile!.consents.copyWith(allowStyleHintInCloud: value);
        break;
      case 'Données santé':
        updatedConsents = _currentProfile!.consents.copyWith(allowHealthDataInCloud: value);
        break;
      case 'Apprentissage':
        updatedConsents = _currentProfile!.consents.copyWith(allowLearningFromFeedback: value);
        break;
      default:
        return;
    }

    final updatedProfile = _currentProfile!.copyWith(consents: updatedConsents);
    setState(() {
      _currentProfile = updatedProfile;
    });

    UserProfileStore.updateConsents(updatedProfile.userId, updatedConsents);
  }

  // Dialogs (simplifiés pour l'exemple)
  void _showSettingsDialog() {
    // Implémenter les paramètres avancés
  }

  void _showFoodPreferencesDialog() {
    // Implémenter l'édition des préférences alimentaires
  }

  void _showHealthConstraintsDialog() {
    // Implémenter l'édition des contraintes de santé
  }

  void _showStyleDialog() {
    // Implémenter l'édition du style
  }

  void _showConsentsDialog() {
    // Implémenter l'édition des consentements
  }

  void _showUserSwitcher() async {
    final users = await UserProfileStore.getAllUsers();
    if (users.length <= 1) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Aucun autre utilisateur disponible')),
      );
      return;
    }

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Changer d\'utilisateur'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: users.map((user) => ListTile(
            title: Text(user.displayName ?? 'Chef'),
            subtitle: Text('Dernière activité: ${_formatDate(user.lastActive)}'),
            onTap: () {
              Navigator.pop(context);
              UserProfileStore.switchUser(user.userId);
              _loadCurrentUser();
            },
          )).toList(),
        ),
      ),
    );
  }

  void _showDeleteConfirmation() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Supprimer le profil'),
        content: const Text('Êtes-vous sûr de vouloir supprimer ce profil ? Cette action est irréversible.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Annuler'),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              UserProfileStore.deleteUser(_currentProfile!.userId);
              setState(() {
                _currentProfile = null;
              });
            },
                         style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: const Text('Supprimer'),
          ),
        ],
      ),
    );
  }
}

```

### chef_ia_app/lib/services/ai_service.dart
```dart
import 'dart:convert';
import 'package:google_generative_ai/google_generative_ai.dart';

class AiException implements Exception {
  final String message;
  AiException(this.message);
  
  @override
  String toString() => message;
}

class AiService {
  // Récupérée via --dart-define=GEMINI_API_KEY=xxx (évite de commit la clé)
  static const _apiKey =
      String.fromEnvironment('GEMINI_API_KEY', defaultValue: '');

  final _model = GenerativeModel(
    model: 'gemini-1.5-pro',
    apiKey: _apiKey,
  );

  // Construit un petit contexte depuis les derniers messages du chat
  String _historyToContext(List<Map<String, String>> history) {
    // history: [{'role':'user'|'assistant','text':'...'}]
    final buf = StringBuffer();
    for (final m in history.take(12)) {
      buf.writeln('${m['role']}: ${m['text']}');
    }
    return buf.toString();
  }

  Future<List<RecipeSuggestionDto>> suggestRecipes({
    required String userQuery,
    required List<Map<String, String>> chatHistory,
  }) async {
    final sys =
        'Tu es ChefIA, assistant culinaire FR. Tu ne traites QUE la cuisine. '
        'À partir de la demande utilisateur + contexte, propose 3 à 5 idées de plats '
        'en JSON STRICT (PAS de texte autour). Tu DOIS respecter les ingrédients/contraintes mentionnés '
        '(ex: "poulet et riz", "lait de coco", "rapide", "végétarien").';

    final schema = {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "title": {"type": "string"},
          "time_minutes": {"type": "integer"},
          "mains": {
            "type": "array",
            "items": {"type": "string"}
          },
          "difficulty": {"type": "string"}
        },
        "required": ["title", "time_minutes", "mains", "difficulty"]
      }
    };

    final ctx = _historyToContext(chatHistory);

    final prompt = '''
$sys

Contexte récent:
$ctx

Demande utilisateur: "$userQuery"

Réponds uniquement en JSON valide, conforme au schema suivant:
${jsonEncode(schema)}
''';

    final resp = await _model.generateContent([Content.text(prompt)]);
    final raw = resp.text?.trim() ?? '[]';

    final jsonStr = _extractJson(raw);
    final data = jsonDecode(jsonStr) as List<dynamic>;
    return data.map((e) => RecipeSuggestionDto.fromJson(e)).toList();
  }

  Future<RecipeFullDto> getRecipeDetails({
    required String title,
    required List<String> mains,
    required List<Map<String, String>> chatHistory,
  }) async {
    final sys =
        'Tu es ChefIA. Donne une recette FR complète en JSON STRICT (aucun texte autour). '
        'La recette doit respecter le plat demandé et les ingrédients clés.';

    final schema = {
      "type": "object",
      "properties": {
        "title": {"type": "string"},
        "time": {"type": "string"},
        "ingredients": {
          "type": "array",
          "items": {"type": "string"}
        },
        "equipment": {
          "type": "array",
          "items": {"type": "string"}
        },
        "steps": {
          "type": "array",
          "items": {"type": "string"}
        }
      },
      "required": ["title", "time", "ingredients", "equipment", "steps"]
    };

    final ctx = _historyToContext(chatHistory);
    final prompt = '''
$sys

Contexte récent:
$ctx

Plat choisi: "$title"
Ingrédients clés à respecter: ${mains.join(', ')}

Réponds uniquement en JSON valide, conforme au schema suivant:
${jsonEncode(schema)}
''';

    final resp = await _model.generateContent([Content.text(prompt)]);
    final raw = resp.text?.trim() ?? '{}';
    final jsonStr = _extractJson(raw);
    final data = jsonDecode(jsonStr) as Map<String, dynamic>;
    return RecipeFullDto.fromJson(data);
  }

  Future<List<RecipeSummaryDto>> proposeSummaries({
    required String userQuery,
    required List<Map<String, String>> chatHistory,
  }) async {
    if (_apiKey.isEmpty) throw AiException("Clé API manquante (GEMINI_API_KEY).");

    final ctx = _historyToContext(chatHistory);
    final sys =
        'Tu es ChefIA (FR). Produis 3 propositions de plats COHÉRENTES avec la demande. '
        'Réponds UNIQUEMENT en JSON strict. Pas de texte autour. '
        'Limite ingrédients à 6–10 éléments utiles, matériel 3–6. '
        'Formate le temps total comme "30 min".';

    final schema = {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "title": {"type": "string"},
          "ingredients": {"type": "array","items": {"type": "string"}},
          "equipment": {"type": "array","items": {"type": "string"}},
          "difficulty": {"type": "string"},
          "total_time": {"type": "string"},
          "resume": {"type": "string"}
        },
        "required": ["title","ingredients","equipment","difficulty","total_time","resume"]
      }
    };

    final prompt = '''
$sys

Contexte:
$ctx

Demande: "$userQuery"

JSON attendu selon ce schéma:
${jsonEncode(schema)}
''';

    final resp = await _model
        .generateContent([Content.text(prompt)])
        .timeout(const Duration(seconds: 25));

    final raw = resp.text?.trim();
    if (raw == null || raw.isEmpty) throw AiException("Réponse vide du modèle.");

    final jsonStr = _extractJson(raw);
    final data = jsonDecode(jsonStr) as List<dynamic>;
    return data.map((e) => RecipeSummaryDto.fromJson(e)).toList();
  }

  // Nettoie un éventuel bloc ```json ... ```
  String _extractJson(String s) {
    final codeBlock = RegExp(r'```(?:json)?\s*([\s\S]*?)\s*```');
    final m = codeBlock.firstMatch(s);
    if (m != null) return m.group(1)!.trim();
    return s;
  }
}

class RecipeSuggestionDto {
  final String title;
  final int timeMinutes;
  final List<String> mains;
  final String difficulty;

  RecipeSuggestionDto({
    required this.title,
    required this.timeMinutes,
    required this.mains,
    required this.difficulty,
  });

  factory RecipeSuggestionDto.fromJson(Map<String, dynamic> j) {
    return RecipeSuggestionDto(
      title: j['title'] as String,
      timeMinutes: (j['time_minutes'] as num).toInt(),
      mains: (j['mains'] as List).map((e) => e.toString()).toList(),
      difficulty: j['difficulty'] as String,
    );
  }
}

class RecipeFullDto {
  final String title;
  final String time;
  final List<String> ingredients;
  final List<String> equipment;
  final List<String> steps;

  RecipeFullDto({
    required this.title,
    required this.time,
    required this.ingredients,
    required this.equipment,
    required this.steps,
  });

  factory RecipeFullDto.fromJson(Map<String, dynamic> j) {
    return RecipeFullDto(
      title: j['title'] as String,
      time: j['time'] as String,
      ingredients: (j['ingredients'] as List).map((e) => e.toString()).toList(),
      equipment: (j['equipment'] as List).map((e) => e.toString()).toList(),
      steps: (j['steps'] as List).map((e) => e.toString()).toList(),
    );
  }
}

class RecipeSummaryDto {
  final String title;
  final List<String> ingredients; // 6–10 max
  final List<String> equipment;   // 3–6
  final String difficulty;        // Facile / Moyenne / Difficile
  final String totalTime;         // "30 min"
  final String resume;            // 1–2 phrases

  RecipeSummaryDto({
    required this.title,
    required this.ingredients,
    required this.equipment,
    required this.difficulty,
    required this.totalTime,
    required this.resume,
  });

  factory RecipeSummaryDto.fromJson(Map<String, dynamic> j) {
    return RecipeSummaryDto(
      title: j['title'] as String,
      ingredients: (j['ingredients'] as List).map((e) => e.toString()).toList(),
      equipment: (j['equipment'] as List).map((e) => e.toString()).toList(),
      difficulty: j['difficulty'] as String,
      totalTime: j['total_time'] as String,
      resume: j['resume'] as String,
    );
  }
}

```

### chef_ia_app/lib/services/ai/advisory_engine.dart
```dart
import 'package:intl/intl.dart';
import '../../models/pantry_item.dart';
import '../../models/pantry_advisory.dart';
import 'pantry_advisor_v2.dart';

class AdvisoryEngine {
  final PantryAdvisor advisor;
  AdvisoryEngine(this.advisor);

  DateTime _nextAllowed(DateTime t, {int quietStart = 22, int quietEnd = 8}) {
    final inQuiet = (t.hour >= quietStart) || (t.hour < quietEnd);
    if (!inQuiet) return t;
    final day = t.hour >= quietStart ? t.add(const Duration(days: 1)) : t;
    return DateTime(day.year, day.month, day.day, quietEnd);
  }

  List<PantryAdvisory> build(List<PantryItem> items, {DateTime? now}) {
    final t = now ?? DateTime.now();
    final df = DateFormat('dd/MM');

    final out = <PantryAdvisory>[];

    // 1) Bientôt périmé (J-0..J-3)
    final soon = advisor.getExpiringSoon(items, withinDays: 3);
    if (soon.isNotEmpty) {
      final lines = soon.take(3).map((e) {
        final j = e.expiry == null ? '—' : 'J-${e.expiry!.difference(t).inDays}';
        return '• ${e.name} — $j';
      }).join('\n');
      out.add(PantryAdvisory(
        id: 'soon_${t.millisecondsSinceEpoch}',
        type: AdvisoryType.expireSoon,
        title: 'À consommer bientôt',
        body: lines,
        itemIds: soon.map((e) => e.id).toList(),
        createdAt: t,
        priority: 1,
        notifyAt: _nextAllowed(t), // respecte les heures silencieuses
      ));
    }

    // 2) Période de grâce
    final grace = items.where((e) {
      final ev = advisor.evaluate(e, now: t);
      return ev.status == ExpiryStatus.grace;
    }).toList();
    if (grace.isNotEmpty) {
      final lines = grace.take(3).map((e) {
        final d = e.expiry == null ? '' : df.format(e.expiry!);
        return '• ${e.name} — $d (tolérance)';
      }).join('\n');
      out.add(PantryAdvisory(
        id: 'grace_${t.millisecondsSinceEpoch}',
        type: AdvisoryType.grace,
        title: 'Tolérance courte : consommer vite',
        body: lines,
        itemIds: grace.map((e) => e.id).toList(),
        createdAt: t,
        priority: 1,
        notifyAt: _nextAllowed(t),
      ));
    }

    // 3) Reco anti-gaspillage (petite idée)
    if (soon.isNotEmpty) {
      final top = soon.first.name;
      out.add(PantryAdvisory(
        id: 'sugg_${t.millisecondsSinceEpoch}',
        type: AdvisoryType.suggestion,
        title: 'Idée rapide anti-gaspillage',
        body: 'Et si on cuisinait ${top} ce soir ?\nTouchez pour voir des recettes.',
        itemIds: [soon.first.id],
        createdAt: t,
        priority: 3,
        notifyAt: null,
      ));
    }

    // 4) (option) Restock pour produits récurrents
    final lowRecurring = items.where((e) => e.recurring && (e.quantity ?? 0) <= 0);
    if (lowRecurring.isNotEmpty) {
      out.add(PantryAdvisory(
        id: 'restock_${t.millisecondsSinceEpoch}',
        type: AdvisoryType.restock,
        title: 'À racheter bientôt',
        body: '• ${lowRecurring.take(3).map((e) => e.name).join('\n• ')}',
        itemIds: lowRecurring.map((e) => e.id).toList(),
        createdAt: t,
        priority: 2,
        notifyAt: _nextAllowed(t.add(const Duration(hours: 2))),
      ));
    }

    return out;
  }
}

```

### chef_ia_app/lib/services/ai/advisor_factory.dart
```dart
import 'pantry_advisor_v2.dart';
import 'local_pantry_advisor_v2.dart';
import 'cloud_pantry_advisor_v2.dart';

PantryAdvisor getPantryAdvisor({bool preferCloud = false}) {
  if (preferCloud) return CloudPantryAdvisor();
  return LocalPantryAdvisor();
}





```

### chef_ia_app/lib/services/ai/cloud_client.dart
```dart
// lib/services/ai/cloud_client.dart
typedef Json = Map<String, dynamic>;

abstract class PantryCloudClient {
  Future<List<Json>> advise(Json payload, {Duration timeout});
}












```

### chef_ia_app/lib/services/ai/cloud_pantry_advisor_v2.dart
```dart
// lib/services/ai/cloud_pantry_advisor_v2.dart
import 'package:chef_ia_app/services/ai/pantry_advisor_v2.dart';
import 'package:chef_ia_app/services/ai/cloud_client.dart';
import 'package:chef_ia_app/core/logging.dart';
import 'package:chef_ia_app/models/pantry_advisory.dart';

class CloudPantryAdvisorV2 implements PantryAdvisor {
  final PantryCloudClient client;
  final PantryAdvisor fallback;

  const CloudPantryAdvisorV2({required this.client, required this.fallback});

  @override
  List<PantryAdvisory> advise(PantryState state, PantryUserPrefs prefs) {
    final payload = _buildPayload(state, prefs);
    try {
      final t0 = DateTime.now();
      // NOTE: dans un vrai flux, fais cette méthode async.
      // Ici on garde la même signature sync → le client devra être mocké en test.
      throw UnimplementedError('Use async advise in real impl');
    } catch (e) {
      logEvent(module: 'advisor.cloud', event: 'cloud_failed_fallback', fields: {
        'error': e.toString(),
        'items': state.items.length,
        'topK': prefs.topK,
      }, level: 'WARN');
      return fallback.advise(state, prefs);
    }
  }

  Map<String, dynamic> _buildPayload(PantryState state, PantryUserPrefs prefs) {
    final items = state.items.map((i) => {
      'id': i.id,
      'category': i.category,
      'expiry': i.expiry?.toIso8601String(),
    }).toList();

    return {
      'schemaVersion': 1,
      'prefs': {'topK': prefs.topK, 'privacyCloud': prefs.privacyCloud},
      'items': items,
    };
  }
}

```

### chef_ia_app/lib/services/ai/local_pantry_advisor_v2.dart
```dart
import 'package:chef_ia_app/core/clock.dart';
import 'package:chef_ia_app/core/grace_policy.dart';
import 'package:chef_ia_app/core/logging.dart';
import 'package:chef_ia_app/models/pantry_item.dart';
import 'package:chef_ia_app/models/pantry_advisory.dart';
import 'pantry_advisor_v2.dart';

class LocalPantryAdvisor implements PantryAdvisor {
  final Clock clock;
  final GracePolicy policy;
  final int topK;
  
  const LocalPantryAdvisor({
    this.clock = const SystemClock(),
    this.policy = const GracePolicy(),
    this.topK = 10,
  });

  @override
  List<PantryAdvisory> advise(PantryState state, PantryUserPrefs prefs) {
    final t0 = DateTime.now();
    final items = state.items;
    
    // Classement par urgence: expired > grace > soon > fresh
    int score(PantryItem item) {
      final s = item.statusWith(clock, policy);
      return switch (s) {
        ExpiryStatus.expired => 100,
        ExpiryStatus.grace => 80,
        ExpiryStatus.soon => 50,
        _ => 0,
      };
    }
    
    final sorted = [...items]..sort((a, b) => score(b).compareTo(score(a)));
    final focus = sorted.take(topK).toList();
    
    final advisories = <PantryAdvisory>[];
    
    // Grouper par statut
    final expired = focus.where((i) => i.statusWith(clock, policy) == ExpiryStatus.expired).toList();
    final grace = focus.where((i) => i.statusWith(clock, policy) == ExpiryStatus.grace).toList();
    final soon = focus.where((i) => i.statusWith(clock, policy) == ExpiryStatus.soon).toList();
    
    if (expired.isNotEmpty) {
      advisories.add(PantryAdvisory(
        id: 'expired_${DateTime.now().millisecondsSinceEpoch}',
        type: AdvisoryType.expireSoon,
        title: 'Produits expirés',
        body: '${expired.length} produit(s) expiré(s) à jeter',
        reason: 'Ces produits ont dépassé leur date de péremption',
        itemIds: expired.map((e) => e.id).toList(),
        priority: 1,
        createdAt: clock.now(),
        actions: [
          PantryAdvisoryAction('FILTER', {'status': 'expired'}),
          PantryAdvisoryAction('RECIPE', {'items': expired.map((e) => e.id).toList()}),
        ],
      ));
    }
    
    if (grace.isNotEmpty) {
      advisories.add(PantryAdvisory(
        id: 'grace_${DateTime.now().millisecondsSinceEpoch}',
        type: AdvisoryType.grace,
        title: 'Période de grâce',
        body: '${grace.length} produit(s) en période de grâce',
        reason: 'Ces produits sont expirés mais encore consommables',
        itemIds: grace.map((e) => e.id).toList(),
        priority: 2,
        createdAt: clock.now(),
        actions: [
          PantryAdvisoryAction('FILTER', {'status': 'grace'}),
          PantryAdvisoryAction('RECIPE', {'items': grace.map((e) => e.id).toList()}),
        ],
      ));
    }
    
    if (soon.isNotEmpty) {
      advisories.add(PantryAdvisory(
        id: 'soon_${DateTime.now().millisecondsSinceEpoch}',
        type: AdvisoryType.expireSoon,
        title: 'Bientôt périmés',
        body: '${soon.length} produit(s) à consommer rapidement',
        reason: 'Ces produits expirent dans les 3 prochains jours',
        itemIds: soon.map((e) => e.id).toList(),
        priority: 3,
        createdAt: clock.now(),
        actions: [
          PantryAdvisoryAction('FILTER', {'status': 'soon'}),
          PantryAdvisoryAction('RECIPE', {'items': soon.map((e) => e.id).toList()}),
        ],
      ));
    }
    
    final dt = DateTime.now().difference(t0).inMilliseconds;
    logEvent(module: 'advisor.local', event: 'advise_done', fields: {
      'topK': prefs.topK,
      'items': state.items.length,
      'advisories': advisories.length,
      'ms': dt,
    });
    
    return advisories;
  }
}

```

### chef_ia_app/lib/services/ai/pantry_advisor_v2.dart
```dart
import '../../models/pantry_item.dart';
import '../../models/pantry_advisory.dart';

class PantryState {
  final List<PantryItem> items;
  const PantryState({required this.items});
}

class PantryUserPrefs {
  final bool useCloud;
  final bool privacyCloud;
  final int topK;
  const PantryUserPrefs({
    this.useCloud = true,
    this.privacyCloud = true,
    this.topK = 10,
  });
}

abstract class PantryAdvisor {
  List<PantryAdvisory> advise(PantryState state, PantryUserPrefs prefs);
}












```

### chef_ia_app/lib/services/chat/pantry_chat.dart
```dart
import 'dart:convert';
import 'package:flutter/material.dart';
import '../../models/pantry_item.dart';
import '../ai/local_pantry_advisor_v2.dart'; // pour petite logique si cloud KO
import 'package:http/http.dart' as http;

class PantryUserPrefs {
  final bool glutenFree, lactoseFree;
  final double? budgetPerMeal;
  final bool useCloud;
  final bool privacyCloud;
  final int topK;
  const PantryUserPrefs({
    this.glutenFree=false, 
    this.lactoseFree=false, 
    this.budgetPerMeal,
    this.useCloud = true,
    this.privacyCloud = true,
    this.topK = 10,
  });
}

class PantryChatContext {
  final List<PantryItem> items;
  final List<String> nearExpiryIds;
  final DateTime now;
  final bool locationAllowed;
  final String? locationApprox; // ex: "Paris, FR"
  final double? temperatureC;
  final PantryUserPrefs userPrefs;

  PantryChatContext({
    required this.items,
    required this.nearExpiryIds,
    required this.now,
    required this.locationAllowed,
    required this.locationApprox,
    required this.temperatureC,
    required this.userPrefs,
  });

  factory PantryChatContext.fromNow({
    required List<PantryItem> items,
    required List<String> nearExpiryIds,
    required bool locationAllowed,
    String? locationApprox,
    double? temperatureC,
    PantryUserPrefs userPrefs = const PantryUserPrefs(),
  }) => PantryChatContext(
        items: items,
        nearExpiryIds: nearExpiryIds,
        now: DateTime.now(),
        locationAllowed: locationAllowed,
        locationApprox: locationApprox,
        temperatureC: temperatureC,
        userPrefs: userPrefs,
      );

  Map<String, dynamic> toJson() => {
    'now': now.toIso8601String(),
    'nearExpiryIds': nearExpiryIds,
    'locationAllowed': locationAllowed,
    'locationApprox': locationApprox,
    'temperatureC': temperatureC,
    'userPrefs': {
      'glutenFree': userPrefs.glutenFree,
      'lactoseFree': userPrefs.lactoseFree,
      'budgetPerMeal': userPrefs.budgetPerMeal,
    },
    'pantry': items.map((e) => {
      'id': e.id,
      'name': e.name,
      'qty': e.quantity,
      'unit': e.unit,
      'category': e.category,
      'expiryISO': e.expiry?.toIso8601String(),
      'barcode': e.barcode,
    }).toList(),
  };
}

class PantryChat {
  // Sélection naïve top-K par similarité texte (peut être remplacée par embeddings)
  List<PantryItem> pickTopK(List<PantryItem> items, String query, {int k = 20}) {
    final q = query.toLowerCase();
    final scored = items.map((e) {
      final hay = '${e.name} ${e.category} ${e.barcode ?? ''}'.toLowerCase();
      final score = hay.contains(q) ? 2 : 0 + (e.name.toLowerCase().startsWith(q) ? 1 : 0);
      return (e: e, s: score);
    }).toList()
      ..sort((a, b) => b.s.compareTo(a.s));
    return scored.take(k).map((x) => x.e).toList();
  }

  Future<Map<String, dynamic>> askCloud(String query, PantryChatContext ctx, {Duration? timeout}) async {
    try {
      final resp = await http.post(
        Uri.parse('https://your-backend.example.com/pantry/chat'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'query': query,
          'context': ctx.toJson(),
        }),
      ).timeout(timeout ?? const Duration(seconds: 10));
      if (resp.statusCode == 200) {
        return jsonDecode(resp.body) as Map<String, dynamic>;
      }
    } catch (_) {/* ignore */}
    // Fallback local minimal
    final local = LocalPantryAdvisor();
    final soon = ctx.items.where((x) {
      final st = local.evaluate(x);
      return st.status == ExpiryStatus.soon || st.status == ExpiryStatus.grace;
    }).toList();
    return {
      'answer': soon.isNotEmpty
          ? "Pense à utiliser : ${soon.map((e)=>e.name).take(3).join(', ')} (bientôt périmés)."
          : "Je n'ai rien vu d'urgent. Que veux-tu cuisiner ?",
      'suggestions': [
        "Idées avec ${soon.isNotEmpty ? soon.first.name : 'tes produits courants'}",
        "Recettes < 30 min",
        "Sans gaspillage",
      ],
      'actions': [],
      'debug': {'fallback':'local'}
    };
  }

  Map<String, dynamic> askCloudFallback(String query, PantryChatContext ctx) {
    final local = LocalPantryAdvisor();
    final soon = ctx.items.where((x) {
      final st = local.evaluate(x);
      return st.status == ExpiryStatus.soon || st.status == ExpiryStatus.grace;
    }).toList();
    return {
      'answer': soon.isNotEmpty
          ? "Pense à utiliser : ${soon.map((e)=>e.name).take(3).join(', ')} (bientôt périmés)."
          : "Je n'ai rien vu d'urgent. Que veux-tu cuisiner ?",
      'suggestions': [
        "Idées avec ${soon.isNotEmpty ? soon.first.name : 'tes produits courants'}",
        "Recettes < 30 min",
        "Sans gaspillage",
      ],
      'actions': [],
      'debug': {'fallback':'local'}
    };
  }

  String? localHint(List<PantryItem> top, List<String> near) {
    if (near.isEmpty) return null;
    final nearItems = top.where((e) => near.contains(e.id)).take(3).toList();
    if (nearItems.isEmpty) return null;
    return "💡 Pense à utiliser : ${nearItems.map((e) => e.name).join(', ')} (bientôt périmés)";
  }

  String render(Map<String, dynamic> json) {
    final ans = json['answer'] ?? '';
    final sugg = (json['suggestions'] as List?)?.cast<String>() ?? const [];
    if (sugg.isEmpty) return ans;
    return "$ans\n\n• ${sugg.join('\n• ')}";
  }

  void runActions(Map<String, dynamic> json, BuildContext ctx) {
    final acts = (json['actions'] as List?)?.cast<Map<String, dynamic>>() ?? const [];
    for (final a in acts) {
      switch (a['type']) {
        case 'open_recipe_prompt':
          final ids = (a['items'] as List).cast<String>();
          Navigator.pushNamed(ctx, '/chat', arguments: {
            'prompt': "Propose 3 recettes avec : ${ids.join(', ')}"
          });
          break;
        case 'mark_shopping':
          // TODO: ajouter à la liste de courses
          break;
      }
    }
  }
}

```

### chef_ia_app/lib/services/notify/ai_notifier.dart
```dart
import 'dart:async';
// import 'package:flutter/material.dart'; // Temporairement inutilisé
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:timezone/data/latest.dart' as tz;
import 'package:timezone/timezone.dart' as tz;

import '../../models/pantry_advisory.dart';

class AiNotifier {
  AiNotifier._();
  static final AiNotifier I = AiNotifier._();

  final _plugin = FlutterLocalNotificationsPlugin();
  final _stream = StreamController<PantryAdvisory>.broadcast();
  Stream<PantryAdvisory> get stream => _stream.stream;

  // mémoriser les advisories par id pour les retrouver depuis la notif
  final _byId = <String, PantryAdvisory>{};

  // callbacks fournis par l'écran
  void Function(List<String> itemIds)? onOpenRecipe;
  void Function(List<String> itemIds)? onMarkConsumed;
  void Function(PantryAdvisory adv)? onTapNotif;

  final _muted = <String>{};                  // itemId mutés
  final _snoozedUntil = <String, DateTime>{}; // adv.id → date

  bool _inited = false;

  Future<void> init() async {
    if (_inited) return;
    tz.initializeTimeZones();

    const android = AndroidInitializationSettings('@mipmap/ic_launcher');
    final ios = DarwinInitializationSettings(
      requestAlertPermission: true, 
      requestBadgePermission: true, 
      requestSoundPermission: true,
      notificationCategories: [
        DarwinNotificationCategory(
          'pantry_actions',
          actions: [
            DarwinNotificationAction.plain('open_recipe', 'Recette'),
            DarwinNotificationAction.plain('snooze', 'Rappeler demain'),
            DarwinNotificationAction.plain('mark_consumed', 'Marqué consommé'),
          ],
        ),
      ],
    );
    await _plugin.initialize(
      InitializationSettings(android: android, iOS: ios),
      onDidReceiveNotificationResponse: (resp) async {
        final adv = _byId[resp.payload ?? ''];
        if (adv == null) return;
        switch (resp.actionId) {
          case 'open_recipe':
            onOpenRecipe?.call(adv.itemIds);
            break;
          case 'snooze':
            await snooze(adv, const Duration(hours: 24));
            break;
          case 'mark_consumed':
            onMarkConsumed?.call(adv.itemIds);
            break;
          default: // tap sur la notif
            onTapNotif?.call(adv);
        }
      },
    );
    // Channels
    const chAlert = AndroidNotificationChannel('pantry_alerts', 'Alertes garde-manger', importance: Importance.high);
    const chInfo  = AndroidNotificationChannel('pantry_suggestions', 'Suggestions garde-manger', importance: Importance.defaultImportance);
    await _plugin
        .resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>()
        ?.createNotificationChannel(chAlert);
    await _plugin
        .resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>()
        ?.createNotificationChannel(chInfo);
    
    // Actions sur les notifications gérées via onDidReceiveNotificationResponse
    
    _inited = true;
  }

  Future<void> pushInApp(PantryAdvisory adv) async {
    _byId[adv.id] = adv;
    _stream.add(adv);
  }

  bool isMuted(PantryAdvisory adv) => adv.itemIds.any(_muted.contains);

  Future<void> snooze(PantryAdvisory adv, Duration d) async {
    _snoozedUntil[adv.id] = DateTime.now().add(d);
  }

  bool isSnoozed(PantryAdvisory adv) {
    final t = _snoozedUntil[adv.id];
    return t != null && DateTime.now().isBefore(t);
  }

  void muteItem(String itemId) {
    _muted.add(itemId);
  }

  void unmuteItem(String itemId) {
    _muted.remove(itemId);
  }

  Future<void> schedulePhoneNotif(PantryAdvisory adv) async {
    _byId[adv.id] = adv;
    if (adv.notifyAt == null) return;
    if (isMuted(adv) || isSnoozed(adv)) return;
    final id = adv.id.hashCode & 0x7fffffff;
    final tzTime = tz.TZDateTime.from(adv.notifyAt!, tz.local);

    final details = NotificationDetails(
      android: AndroidNotificationDetails(
        adv.priority == 1 ? 'pantry_alerts' : 'pantry_suggestions',
        adv.title,
        channelDescription: 'Notifications IA du garde-manger',
        priority: adv.priority == 1 ? Priority.high : Priority.defaultPriority,
        importance: adv.priority == 1 ? Importance.high : Importance.defaultImportance,
        category: AndroidNotificationCategory.recommendation,
        actions: const [
          AndroidNotificationAction('open_recipe', 'Recette'),
          AndroidNotificationAction('snooze', 'Rappeler demain'),
          AndroidNotificationAction('mark_consumed', 'Marqué consommé'),
        ],
      ),
      iOS: const DarwinNotificationDetails(categoryIdentifier: 'pantry_actions'),
    );

    await _plugin.zonedSchedule(
      id, adv.title, adv.body, tzTime, details,
      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
      uiLocalNotificationDateInterpretation: UILocalNotificationDateInterpretation.absoluteTime,
      payload: adv.id,
    );
  }


}

```

### chef_ia_app/lib/services/notify/bg_tasks.dart
```dart
// TODO: Réactiver workmanager plus tard
// import 'package:workmanager/workmanager.dart';
import 'package:chef_ia_app/core/event_bus.dart';
import '../notify/ai_notifier.dart';
import '../ai/advisory_engine.dart';
import '../../models/pantry_item.dart';
import '../storage/pantry_store.dart';
import '../ai/local_pantry_advisor_v2.dart';

const taskId = 'pantry_check';

// TODO: Réactiver workmanager plus tard
Future<void> registerPantryTask() async {
  // await Workmanager().initialize(callbackDispatcher, isInDebugMode: false);
  // await Workmanager().registerPeriodicTask(taskId, taskId, frequency: const Duration(hours: 6));
}

Future<void> runDailyExpiryCheck() async {
  // ... ta logique existante (scan, etc.)
  // Publie un tick pour déclencher l'agent silencieux (recalcul des conseils)
  EventBus().emit('pantry.expiry.tick', {'reason': 'daily'});
}

// @pragma('vm:entry-point')
// void callbackDispatcher() {
//   Workmanager().executeTask((task, input) async {
//     final store = PantryStore();
//     final items = await store.load(); // charge local
//     final engine = AdvisoryEngine(LocalPantryAdvisor());
//     final events = engine.build(items);
//     final notif = AiNotifier.I;
//     await notif.init();
//     for (final e in events) {
//       await notif.schedulePhoneNotif(e);
//     }
//     return true;
//   });
// }

```

### chef_ia_app/lib/services/storage/pantry_store.dart
```dart
import 'dart:async';
import 'dart:convert';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:chef_ia_app/core/event_bus.dart';
import 'package:chef_ia_app/core/events.dart';
import 'package:uuid/uuid.dart';
import '../../models/pantry_item.dart';

class PantryStore {
  static const _kKeyV2 = 'pantry_items_v2';
  static const _kKeyV1 = 'pantry_items'; // fallback éventuel
  static const _kSchemaKey = 'pantry_schema_version';

  // Coalescing des événements pour éviter les rebuild storms
  Timer? _emitTimer;
  bool _emitPending = false;
  
  // Cache mémoire pour fallback si SP échoue
  List<PantryItem>? _inMemoryCache;
  
  void _emitCoalesced() {
    if (_emitTimer != null) { 
      _emitPending = true; 
      return; 
    }
    _emitTimer = Timer(const Duration(milliseconds: 16), () {
      _emitTimer = null;
      EventBus().publish({'type': AppEvents.pantryItemsChanged});
      if (_emitPending) { 
        _emitPending = false; 
        _emitCoalesced(); 
      }
    });
  }

  String _normalizeName(String s) {
    final trimmed = s.toLowerCase().trim();
    if (trimmed.isEmpty) return '';
    
    // Normalisation des accents (NFD + suppression des diacritiques)
    final noDiacritics = trimmed
        .replaceAll('à', 'a').replaceAll('á', 'a').replaceAll('â', 'a').replaceAll('ã', 'a').replaceAll('ä', 'a')
        .replaceAll('è', 'e').replaceAll('é', 'e').replaceAll('ê', 'e').replaceAll('ë', 'e')
        .replaceAll('ì', 'i').replaceAll('í', 'i').replaceAll('î', 'i').replaceAll('ï', 'i')
        .replaceAll('ò', 'o').replaceAll('ó', 'o').replaceAll('ô', 'o').replaceAll('õ', 'o').replaceAll('ö', 'o')
        .replaceAll('ù', 'u').replaceAll('ú', 'u').replaceAll('û', 'u').replaceAll('ü', 'u')
        .replaceAll('ç', 'c').replaceAll('ñ', 'n');
    
    // Suppression des caractères non-alphanumériques + espaces multiples
    return noDiacritics
        .replaceAll(RegExp(r"[^a-z0-9 ]", caseSensitive: false), ' ')
        .replaceAll(RegExp(r"\s+"), ' ')
        .trim();
  }

  bool _isLikelyDuplicate(PantryItem a, PantryItem b) {
    final na = _normalizeName(a.name);
    final nb = _normalizeName(b.name);
    if (na == nb) return true;
    // Égalité stricte uniquement pour éviter les faux positifs
    return false; // Exiger égalité stricte du nom normalisé
  }

  Future<List<PantryItem>> load() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final raw = prefs.getString(_kKeyV2) ?? prefs.getString(_kKeyV1);
      if (raw == null || raw.isEmpty) return _inMemoryCache ?? [];
      
      final items = _decodeSafe(raw);
      // Filtrer les items actifs (non supprimés)
      final activeItems = items.where((item) => item.isActive).toList();
      _inMemoryCache = activeItems;
      return activeItems;
    } catch (e, st) {
      if (kDebugMode) {
        print('PantryStore: load() error: $e');
      }
      return _inMemoryCache ?? [];
    }
  }

  /// Décodage JSON tolérant (ne crash pas sur JSON partiel)
  List<PantryItem> _decodeSafe(String raw) {
    try {
      final list = (jsonDecode(raw) as List).cast<Map<String, dynamic>>();
      return list.map((m) => PantryItem.fromJson(m)).toList();
    } catch (_) {
      // Tentative de récupération minimale
      try {
        final dynamic parsed = jsonDecode(raw);
        if (parsed is List) {
          return parsed.map((e) {
            try { 
              return PantryItem.fromJson(e as Map<String, dynamic>); 
            } catch (_) { 
              return null; 
            }
          }).whereType<PantryItem>().toList(growable: false);
        }
      } catch (_) {
        // JSON complètement corrompu
      }
      return [];
    }
  }

  Future<List<PantryItem>> loadByHousehold(String householdId) async {
    final all = await load();
    return all.where((e) => e.householdId == householdId).toList();
  }

  /// Charge tous les items (y compris supprimés) pour l'export
  Future<List<PantryItem>> loadAll() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_kKeyV2) ?? prefs.getString(_kKeyV1);
    if (raw == null || raw.isEmpty) return [];
    try {
      final list = (jsonDecode(raw) as List).cast<Map<String, dynamic>>();
      return list.map((m) => PantryItem.fromJson(m)).toList();
    } catch (_) {
      return [];
    }
  }

  Future<void> save(List<PantryItem> items) async {
    final data = items.map((e) => e.toJson()).toList();
    final jsonStr = jsonEncode(data);
    
    try {
      final prefs = await SharedPreferences.getInstance();
      final ok = await prefs.setString(_kKeyV2, jsonStr);
      if (!ok) {
        if (kDebugMode) {
          print('PantryStore: SharedPreferences write failed, keeping process cache');
        }
        _inMemoryCache = items; // fallback
      } else {
        _inMemoryCache = items;
      }
    } catch (e, st) {
      if (kDebugMode) {
        print('PantryStore: save() error → fallback memory: $e');
      }
      _inMemoryCache = items;
    }
  }

  Future<void> saveAllItems(List<PantryItem> items, {required int schemaVersion}) async {
    final prefs = await SharedPreferences.getInstance();
    final data = items.map((e) => e.toJson()).toList();
    await prefs.setString(_kKeyV2, jsonEncode(data));
    await prefs.setInt(_kSchemaKey, schemaVersion);
  }

  Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_kKeyV2);
  }

  Future<void> upsert(PantryItem incoming) async {
    final now = DateTime.now();
    final inc = incoming.copyWith(updatedAt: now);
    final all = await load();

    // 1) match par id
    final idx = all.indexWhere((e) => e.id == inc.id);
    if (idx >= 0) {
      if (inc.updatedAt.isAfter(all[idx].updatedAt)) {
        all[idx] = inc; // plus récent l'emporte
      }
      await _save(all);
      _emitCoalesced();
      return;
    }

    // 2) dédup par nom normalisé
    final dupIdx = all.indexWhere((e) => _isLikelyDuplicate(e, inc));
    if (dupIdx >= 0) {
      // stratégie: garder l'id existant, fusionner les champs utiles
      final base = all[dupIdx];
      all[dupIdx] = base.copyWith(
        name: base.name.length >= inc.name.length ? base.name : inc.name,
        updatedAt: now.isAfter(base.updatedAt) ? now : base.updatedAt,
        // ajoutez ici d'éventuelles fusions de quantité/catégorie
      );
      await _save(all);
      _emitCoalesced();
      return;
    }

    // 3) nouvel item
    all.add(inc);
    await _save(all);
    EventBus().publish({'type':'pantry.storage.upserted','payload':{'id': inc.id}});
  }

  Future<void> _save(List<PantryItem> items) async {
    await save(items);
  }

  /// Upsert local sans I/O (pour batch processing)
  void _upsertLocal(List<PantryItem> items, PantryItem incoming) {
    final now = DateTime.now();
    final inc = incoming.copyWith(updatedAt: now);

    // 1) match par id
    final idx = items.indexWhere((e) => e.id == inc.id);
    if (idx >= 0) {
      if (inc.updatedAt.isAfter(items[idx].updatedAt)) {
        items[idx] = inc; // plus récent l'emporte
      }
      return;
    }

    // 2) dédup par nom normalisé
    final dupIdx = items.indexWhere((e) => _isLikelyDuplicate(e, inc));
    if (dupIdx >= 0) {
      final base = items[dupIdx];
      items[dupIdx] = base.copyWith(
        name: base.name.length >= inc.name.length ? base.name : inc.name,
        updatedAt: now.isAfter(base.updatedAt) ? now : base.updatedAt,
      );
      return;
    }

    // 3) nouvel item
    items.add(inc);
  }

  Future<void> addItem(PantryItem item) async {
    await upsert(item);
    
    _emitCoalesced();
  }

  Future<void> updateItem(PantryItem item) async {
    await upsert(item);
    
    _emitCoalesced();
  }

  Future<void> deleteItem(String id, {bool soft = true}) async {
    if (soft) {
      // Soft delete : marque comme supprimé
      final allItems = await loadAll();
      final updatedItems = allItems.map((item) {
        if (item.id == id) {
          return item.markAsDeleted();
        }
        return item;
      }).toList();
      await save(updatedItems); // Sauvegarde l'état mis à jour (soft-deleted)
      
      _emitCoalesced();
    } else {
      // Hard delete : supprime définitivement
      final allItems = await loadAll();
      allItems.removeWhere((i) => i.id == id);
      await save(allItems);
      
      _emitCoalesced();
    }
  }

  /// Restaure un item supprimé
  Future<bool> restoreItem(String id) async {
    try {
      final allItems = await loadAll();
      final itemToRestore = allItems.firstWhere(
        (item) => item.id == id,
        orElse: () => PantryItem.fromName(''), // Item vide si non trouvé
      );
      
      if (itemToRestore.name.isEmpty) {
        // Item non trouvé (peut-être purgé)
        return false;
      }
      
      final updatedItems = allItems.map((item) {
        if (item.id == id) {
          return item.restore();
        }
        return item;
      }).toList();
      await save(updatedItems);
      
      _emitCoalesced();
      return true;
    } catch (e) {
      if (kDebugMode) {
        print('PantryStore: restoreItem() error: $e');
      }
      return false;
    }
  }

  /// Purge les items supprimés depuis plus de 30 jours
  Future<void> purgeDeletedItems({int daysOld = 30}) async {
    final cutoff = DateTime.now().subtract(Duration(days: daysOld));
    final allItems = await loadAll();
    final activeItems = allItems.where((item) {
      if (item.deletedAt == null) return true; // Item actif
      return item.deletedAt!.isAfter(cutoff); // Item supprimé récemment
    }).toList();
    
    if (activeItems.length != allItems.length) {
      await save(activeItems);
      _emitCoalesced();
      
      // Métriques debug
      assert(() {
        if (kDebugMode) {
          print('PantryStore purge: removed ${allItems.length - activeItems.length} items');
        }
        return true;
      }());
    }
  }

  /// Exporte tous les items (actifs + supprimés) en JSON
  Future<String> exportAsJson() async {
    final allItems = await loadAll();
    final export = {
      'schemaVersion': 3,
      'exportedAt': DateTime.now().toIso8601String(),
      'items': allItems.map((item) => item.toJson()).toList(),
    };
    return jsonEncode(export);
  }

  /// Importe des items depuis un JSON avec déduplication
  Future<Map<String, int>> importFromJson(String jsonData) async {
    try {
      final data = jsonDecode(jsonData) as Map<String, dynamic>;
      final importedItems = (data['items'] as List)
          .map((m) => PantryItem.fromJson(m.cast<String, dynamic>()))
          .toList();
      
      final existingItems = await loadAll();
      final existingIds = existingItems.map((e) => e.id).toSet();
      final existingBarcodes = existingItems
          .where((e) => e.barcode != null)
          .map((e) => e.barcode!)
          .toSet();
      
      int added = 0;
      int updated = 0;
      int skipped = 0;
      
      // Batch processing : éviter N writes
      final updatedState = List<PantryItem>.from(existingItems);
      
      for (final item in importedItems) {
        final isDup = existingIds.contains(item.id) ||
                     (item.barcode != null && existingBarcodes.contains(item.barcode!));
        if (isDup) { 
          updated++; 
        } else { 
          added++; 
        }
        _upsertLocal(updatedState, item);
      }
      
      // Un seul write pour tous les items
      await save(updatedState);
      
      _emitCoalesced();
      
      // Métriques debug
      assert(() {
        if (kDebugMode) {
          print('PantryStore import: added=$added updated=$updated skipped=$skipped');
        }
        return true;
      }());
      
      return {'added': added, 'updated': updated, 'skipped': skipped};
    } catch (e) {
      throw Exception('Erreur lors de l\'import: $e');
    }
  }
}





```

### chef_ia_app/lib/ui/responsive.dart
```dart
import 'package:flutter/material.dart';

enum DeviceSize { phoneSmall, phone, phoneLarge, tablet, desktop }

class Responsive {
  static DeviceSize deviceSizeOf(BuildContext context) {
    final w = MediaQuery.of(context).size.width;
    if (w < 340) return DeviceSize.phoneSmall;   // ex: iPhone SE, petits Android
    if (w < 400) return DeviceSize.phone;        // téléphones "classiques"
    if (w < 600) return DeviceSize.phoneLarge;   // grands téléphones
    if (w < 1024) return DeviceSize.tablet;      // tablettes 7–11"
    return DeviceSize.desktop;                   // très larges (Dex, iPad Pro +)
  }

  /// Largeur max du contenu au centre (évite l'effet "plein écran" sur tablette/desktop)
  static double maxContentWidth(BuildContext context) {
    final w = MediaQuery.of(context).size.width;
    final size = deviceSizeOf(context);
    // Sur téléphone → on utilise quasi toute la largeur (pas de gouttières énormes)
    if (size == DeviceSize.phoneSmall ||
        size == DeviceSize.phone ||
        size == DeviceSize.phoneLarge) {
      return w; // largeur dispo (le padding de page s'applique déjà ailleurs)
    }
    // Tablettes / desktop → on borne pour un rendu plus pro
    if (size == DeviceSize.tablet) return 900;
    return 1100; // desktop large
  }

  /// Taille des tuiles d'action (min/max) selon l'appareil
  static BoxConstraints homeTileConstraints(BuildContext context) {
    switch (deviceSizeOf(context)) {
          case DeviceSize.phoneSmall:
      return const BoxConstraints(minWidth: 150, maxWidth: 200, minHeight: 96);
          case DeviceSize.phone:
      return const BoxConstraints(minWidth: 150, maxWidth: 210, minHeight: 100);
    case DeviceSize.phoneLarge:
      return const BoxConstraints(minWidth: 160, maxWidth: 220, minHeight: 104);
      case DeviceSize.tablet:
        return const BoxConstraints(minWidth: 200, maxWidth: 260, minHeight: 130);
      case DeviceSize.desktop:
        return const BoxConstraints(minWidth: 220, maxWidth: 280, minHeight: 140);
    }
  }

  /// Padding horizontal global
  static EdgeInsets pagePadding(BuildContext context) {
    final size = deviceSizeOf(context);
    if (size == DeviceSize.tablet || size == DeviceSize.desktop) {
      return const EdgeInsets.symmetric(horizontal: 24, vertical: 12);
    }
    return const EdgeInsets.symmetric(horizontal: 10, vertical: 12);
  }

  /// Espacements entre tuiles
  static double wrapSpacing(BuildContext context) {
    switch (deviceSizeOf(context)) {
      case DeviceSize.phoneSmall: return 8;
      case DeviceSize.phone:      return 10;
      default:                    return 12;
    }
  }

  /// Largeur maxi des tuiles d'action (pour SliverGridDelegateWithMaxCrossAxisExtent)
  static double homeTileMaxExtent(BuildContext context) {
    switch (deviceSizeOf(context)) {
      case DeviceSize.phoneSmall: return 160; // tuile plus étroite
      case DeviceSize.phone:      return 180;
      case DeviceSize.phoneLarge: return 200;
      case DeviceSize.tablet:     return 220;
      case DeviceSize.desktop:    return 240;
    }
  }
}

```

### chef_ia_app/lib/ui/a11y/a11y_semantics.dart
```dart
import 'package:flutter/material.dart';

/// Tuile/bouton accessible : fusionne icône+titres en un seul élément lisible.
/// - label  : ce que le lecteur dit en premier (court).
/// - hint   : aide contextuelle (ce que ça fait).
/// - enabled: état activé/désactivé.
/// - onTap  : action.
class A11yTileButton extends StatelessWidget {
  final String label;
  final String? hint;
  final bool enabled;
  final VoidCallback? onTap;
  final Widget child;

  const A11yTileButton({
    super.key,
    required this.label,
    this.hint,
    this.enabled = true,
    required this.onTap,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    return Semantics(
      button: true,
      enabled: enabled,
      label: label,
      hint: hint,
      child: ExcludeSemantics( // évite de relire les Text internes
        child: InkWell(
          onTap: enabled ? onTap : null,
          child: child,
        ),
      ),
    );
  }
}

/// Bouton iconique accessible (ex. suivant/précédent).
class A11yIconButton extends StatelessWidget {
  final String label;
  final String? hint;
  final bool enabled;
  final VoidCallback? onPressed;
  final IconData icon;
  final double size;

  const A11yIconButton({
    super.key,
    required this.label,
    this.hint,
    this.enabled = true,
    required this.onPressed,
    required this.icon,
    this.size = 28,
  });

  @override
  Widget build(BuildContext context) {
    return Semantics(
      button: true,
      enabled: enabled,
      label: label,
      hint: hint,
      child: ExcludeSemantics(
        child: IconButton(
          onPressed: enabled ? onPressed : null,
          icon: Icon(icon, size: size),
        ),
      ),
    );
  }
}

/// Image avec description (pour TalkBack/VoiceOver).
class A11yImage extends StatelessWidget {
  final ImageProvider image;
  final String semanticsLabel;
  final BoxFit fit;
  final double? width;
  final double? height;

  const A11yImage({
    super.key,
    required this.image,
    required this.semanticsLabel,
    this.fit = BoxFit.cover,
    this.width,
    this.height,
  });

  @override
  Widget build(BuildContext context) {
    return Semantics(
      image: true,
      label: semanticsLabel,
      child: ExcludeSemantics(
        child: Image(
          image: image,
          width: width,
          height: height,
          fit: fit,
        ),
      ),
    );
  }
}

```

### chef_ia_app/lib/ui/layout/containers.dart
```dart
import 'package:flutter/material.dart';
import '../responsive.dart';

/// Pour pages "statiques" (sections, cartes, boutons)
class StaticPageContainer extends StatelessWidget {
  final List<Widget> children;
  const StaticPageContainer({super.key, required this.children});

  @override
  Widget build(BuildContext context) {
    final pad = Responsive.pagePadding(context);
    final maxW = Responsive.maxContentWidth(context);
    return LayoutBuilder(
      builder: (_, constraints) {
        return SafeArea(
          child: SingleChildScrollView(
            padding: pad,
            child: Center(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: maxW, minHeight: constraints.maxHeight),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: children,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

/// Pour pages "liste" (chat, catalogues…)
class ListPageContainer extends StatelessWidget {
  final Widget sliversOrList; // ListView OU CustomScrollView
  const ListPageContainer({super.key, required this.sliversOrList});

  @override
  Widget build(BuildContext context) {
    final pad = Responsive.pagePadding(context);
    final maxW = Responsive.maxContentWidth(context);
    return SafeArea(
      child: Padding(
        padding: pad,
        child: Center(
          child: ConstrainedBox(
            constraints: BoxConstraints(maxWidth: maxW),
            child: sliversOrList,
          ),
        ),
      ),
    );
  }
}

```

### chef_ia_app/lib/ui/screens/barcode_scan_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import '../../data/kitchen_store.dart';
import '../../models/pantry_item.dart' as new_model;
import '../../core/prompt/prompt_builder.dart';


class BarcodeScanScreen extends StatefulWidget {
  const BarcodeScanScreen({super.key});
  @override
  State<BarcodeScanScreen> createState() => _BarcodeScanScreenState();
}

class _BarcodeScanScreenState extends State<BarcodeScanScreen> {
  bool _lock = false;
  String? _last;

  Future<void> _handleBarcode(String code) async {
    if (_lock || code == _last) return;
    _lock = true; _last = code;
    try {
      // Pour l'instant, on ajoute un produit générique
      // TODO: Implémenter un vrai service de produits
      final item = new_model.PantryItem(
        id: new_model.PantryItem.generateId(),
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        name: 'Produit $code',
        quantity: 1,
        unit: 'pièce',
        category: 'Autre',
      );
      await KitchenStore.addPantryItem(item);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Ajouté: Produit $code')),
        );
        Navigator.pop(context, {'added': item});
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Erreur: $e')),
        );
      }
    } finally {
      _lock = false;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Scanner un code‑barres')),
      body: Stack(
        children: [
          MobileScanner(
            onDetect: (capture) {
              final barcodes = capture.barcodes;
              if (barcodes.isEmpty) return;
              final raw = barcodes.first.rawValue ?? '';
              if (raw.isNotEmpty) _handleBarcode(raw);
            },
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: Container(
              color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.54),
              padding: const EdgeInsets.all(12),
              child: Text('Cadrez le code‑barres…', style: TextStyle(color: Theme.of(context).colorScheme.onPrimary)),
            ),
          )
        ],
      ),
    );
  }
}


```

### chef_ia_app/lib/ui/screens/logs_screen.dart
```dart
import 'package:flutter/material.dart';
import '../../core/dev_logger.dart';
import 'tester_feedback_screen.dart';

class LogsScreen extends StatefulWidget {
  const LogsScreen({super.key});

  @override
  State<LogsScreen> createState() => _LogsScreenState();
}

class _LogsScreenState extends State<LogsScreen> {
  String _filter = "ALL";

  @override
  Widget build(BuildContext context) {
    final logs = DevLogger.getLogs()
        .where((log) => _filter == "ALL" || log.level == _filter)
        .toList()
        .reversed
        .toList();

    return Scaffold(
      appBar: AppBar(
        title: const Text("Journal technique"),
        actions: [
          IconButton(
            tooltip: "Partager (JSON)",
            icon: const Icon(Icons.ios_share),
            onPressed: () async {
              await DevLogger.shareLogs(asJson: true);
              DevLogger.info("Logs", "Partage logs demandé (JSON)");
              
              // Log bêta détaillé
              DevLogger.info("Logs", "Partage JSON - ${DevLogger.getLogs().length} entrées, taille estimée: ${DevLogger.getLogs().length * 200} chars", betaOnly: true);
            },
          ),
          IconButton(
            tooltip: "Partager (TXT)",
            icon: const Icon(Icons.share),
            onPressed: () async {
              await DevLogger.shareLogs(asJson: false);
              DevLogger.info("Logs", "Partage logs demandé (TXT)");
              
              // Log bêta détaillé
              DevLogger.info("Logs", "Partage TXT - ${DevLogger.getLogs().length} entrées, format lisible", betaOnly: true);
            },
          ),
          IconButton(
            tooltip: "Effacer",
            icon: const Icon(Icons.delete_forever),
            onPressed: () {
              DevLogger.clear();
              setState(() {});
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text("Logs effacés")),
              );
            },
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => Navigator.push(
          context,
          MaterialPageRoute(builder: (_) => const TesterFeedbackScreen()),
        ),
        icon: const Icon(Icons.add_comment),
        label: const Text("Ajouter un retour"),
      ),
      body: Column(
        children: [
          // 🔎 Filtres
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Wrap(
              spacing: 8,
              children: [
                _buildFilterChip("ALL"),
                _buildFilterChip("INFO"),
                _buildFilterChip("WARN"),
                _buildFilterChip("ERROR"),
              ],
            ),
          ),
          // 📊 Stats
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Card(
              child: ListTile(
                leading: const Icon(Icons.analytics),
                title: const Text("Statistiques"),
                subtitle: Text(
                  "Erreurs: ${DevLogger.getLogs().where((l) => l.level == "ERROR").length} | "
                  "Avertissements: ${DevLogger.getLogs().where((l) => l.level == "WARN").length} | "
                  "Total: ${DevLogger.getLogs().length}",
                ),
              ),
            ),
          ),
          // 📋 Liste
          Expanded(
            child: logs.isEmpty
                ? const Center(child: Text("Aucun log pour l'instant ✅"))
                : ListView.separated(
                    itemCount: logs.length,
                    separatorBuilder: (_, __) => const Divider(height: 1),
                    itemBuilder: (_, i) {
                      final e = logs[i];
                      return ListTile(
                        leading: Icon(
                          e.level == "ERROR" 
                              ? Icons.error 
                              : e.level == "WARN" 
                                  ? Icons.warning_amber 
                                  : Icons.info_outline,
                          color: e.level == "ERROR"
                              ? Colors.red
                              : e.level == "WARN" 
                                  ? Colors.orange 
                                  : Theme.of(context).colorScheme.primary,
                        ),
                        title: Text("[${e.level}] ${e.tag}"),
                        subtitle: Text(e.toString(), maxLines: 6, overflow: TextOverflow.ellipsis),
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }

  Widget _buildFilterChip(String level) {
    final isSelected = _filter == level;
    final count = level == "ALL" 
        ? DevLogger.getLogs().length 
        : DevLogger.getLogs().where((l) => l.level == level).length;
    
    return ChoiceChip(
      label: Text("$level ($count)"),
      selected: isSelected,
      onSelected: (_) {
        setState(() {
          _filter = level;
        });
      },
    );
  }
}

```

### chef_ia_app/lib/ui/screens/onboarding_intro_screen.dart
```dart
import 'package:flutter/material.dart';
import '../../data/user_profile_store.dart';
import 'onboarding_questionnaire_screen.dart';
import '../../ui/responsive.dart';
import '../../ui/layout/containers.dart';

class OnboardingIntroScreen extends StatefulWidget {
  const OnboardingIntroScreen({super.key});
  @override
  State<OnboardingIntroScreen> createState() => _OnboardingIntroScreenState();
}

class _OnboardingIntroScreenState extends State<OnboardingIntroScreen> {
  final _controller = PageController();

  @override
  Widget build(BuildContext context) {
    final pages = [
      _Slide(icon: Icons.restaurant_menu, title: "Bienvenue dans ChefIA", subtitle: "Assistant culinaire intelligent."),
      _Slide(icon: Icons.auto_awesome,     title: "Recettes sur mesure",   subtitle: "Adaptées à tes goûts et à ton matériel."),
      _Slide(icon: Icons.tips_and_updates, title: "Conseils en temps réel",subtitle: "IA, timers et mode mains libres."),
    ];

    return Scaffold(
      body: StaticPageContainer(
        children: [
          Expanded(
            child: PageView.builder(
              controller: _controller,
              itemCount: pages.length,
              itemBuilder: (_, i) => pages[i],
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(16),
            child: FilledButton.icon(
              icon: const Icon(Icons.arrow_forward),
              label: const Text("Commencer"),
              onPressed: () async {
                await UserProfileStore.setSeenOnboarding();
                if (!mounted) return;
                Navigator.pushReplacement(
                  context,
                  MaterialPageRoute(builder: (_) => const OnboardingQuestionnaireScreen()),
                );
              },
            ),
          )
        ],
      ),
    );
  }
}

class _Slide extends StatelessWidget {
  final IconData icon; final String title; final String subtitle;
  const _Slide({required this.icon, required this.title, required this.subtitle});
  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 96, color: cs.primary),
          const SizedBox(height: 16),
          Text(title, style: Theme.of(context).textTheme.headlineMedium),
          const SizedBox(height: 8),
          Text(subtitle, style: Theme.of(context).textTheme.bodyLarge, textAlign: TextAlign.center),
        ],
      ),
    );
  }
}

```

### chef_ia_app/lib/ui/screens/onboarding_questionnaire_screen.dart
```dart
import 'package:flutter/material.dart';
import '../../core/models/user_models.dart';
import '../../data/user_profile_store.dart';
import '../../screens/home_screen.dart';

class OnboardingQuestionnaireScreen extends StatefulWidget {
  const OnboardingQuestionnaireScreen({super.key});
  @override
  State<OnboardingQuestionnaireScreen> createState() => _OnboardingQuestionnaireScreenState();
}

class _OnboardingQuestionnaireScreenState extends State<OnboardingQuestionnaireScreen> {
  final _form = GlobalKey<FormState>();
  final _name = TextEditingController();
  final _age  = TextEditingController();
  String _level = "debutant";
  final Set<String> _prefs = {};
  final Set<String> _allergies = {};

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Ton profil")),
      body: Form(
        key: _form,
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            TextFormField(
              controller: _name,
              decoration: const InputDecoration(labelText: "Prénom"),
              validator: (v) => (v==null || v.trim().isEmpty) ? "Obligatoire" : null,
            ),
            const SizedBox(height: 8),
            TextFormField(
              controller: _age,
              decoration: const InputDecoration(labelText: "Âge (optionnel)"),
              keyboardType: TextInputType.number,
            ),
            const SizedBox(height: 16),
            Text("Niveau de cuisine", style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            Wrap(
              spacing: 8,
              children: [
                _levelChip("Débutant", "debutant"),
                _levelChip("Intermédiaire", "intermediaire"),
                _levelChip("Expert", "expert"),
              ],
            ),
            const SizedBox(height: 16),
            Text("Préférences", style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            _multiChips(_prefs, ["rapide","gourmet","healthy","économique","végétarien"]),
            const SizedBox(height: 16),
            Text("Allergies", style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            _multiChips(_allergies, ["gluten","arachides","lactose","œuf","soja","sésame"]),
            const SizedBox(height: 20),
            FilledButton.icon(
              icon: const Icon(Icons.check),
              label: const Text("Enregistrer"),
              onPressed: () async {
                if (!_form.currentState!.validate()) return;
                final age = int.tryParse(_age.text.trim());
                                 final profile = UserProfile(
                   userId: DateTime.now().millisecondsSinceEpoch.toString(),
                   displayName: _name.text.trim(),
                   style: UserStyle(
                     styleNotes: 'Niveau: $_level',
                   ),
                   foodPrefs: FoodPreferences(
                     likes: _prefs.toList(),
                     dislikes: [],
                   ),
                   health: HealthConstraints(
                     allergens: _allergies.toList(),
                   ),
                   consents: const UserConsents(),
                   createdAt: DateTime.now(),
                   lastActive: DateTime.now(),
                 );
                await UserProfileStore.save(profile);
                if (!mounted) return;
                Navigator.pushAndRemoveUntil(
                  context,
                  MaterialPageRoute(builder: (_) => const HomeScreen()),
                  (r) => false,
                );
              },
            )
          ],
        ),
      ),
    );
  }

  Widget _levelChip(String label, String value) {
    final selected = _level == value;
    return ChoiceChip(
      label: Text(label),
      selected: selected,
      onSelected: (_) => setState(() => _level = value),
    );
  }

  Widget _multiChips(Set<String> set, List<String> values) {
    return Wrap(
      spacing: 8,
      children: values.map((v) {
        final selected = set.contains(v);
        return FilterChip(
          label: Text(v),
          selected: selected,
          onSelected: (s) => setState(() { s ? set.add(v) : set.remove(v); }),
        );
      }).toList(),
    );
  }
}

```

### chef_ia_app/lib/ui/screens/pantry_chat_screen.dart
```dart
import 'package:flutter/material.dart';
import '../../models/pantry_item.dart';
import '../../services/ai/advisor_factory.dart';
import '../../services/chat/pantry_chat.dart';

class PantryChatScreen extends StatefulWidget {
  const PantryChatScreen({super.key});
  @override
  State<PantryChatScreen> createState() => _PantryChatScreenState();
}

class _PantryChatScreenState extends State<PantryChatScreen> {
  final _ctrl = TextEditingController();
  final _msgs = <({bool me, String text})>[];
  final _chat = PantryChat(); // stub HTTP
  final _advisor = getPantryAdvisor(preferCloud: false); // local pour RAG

  // TODO: injecte ta source réelle de produits (via InheritedWidget/provider)
  List<PantryItem> _items = [];

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Récupère la liste passée en arguments si dispo
    final args = ModalRoute.of(context)?.settings.arguments;
    if (args is List<PantryItem>) _items = args;
  }

  Future<void> _send() async {
    final q = _ctrl.text.trim();
    if (q.isEmpty) return;
    setState(() {
      _msgs.add((me: true, text: q));
      _ctrl.clear();
    });

    // RAG local : top-K + nearExpiry
    final top = _chat.pickTopK(_items, q, k: 20);
    final near = _advisor.getExpiringSoon(_items, withinDays: 3).map((e) => e.id).toList();

    final ctx = PantryChatContext.fromNow(
      items: top,
      nearExpiryIds: near,
      // Ici, branche plus tard la localisation/météo selon les préférences utilisateur
      locationAllowed: false,
      locationApprox: null,
      temperatureC: null,
      userPrefs: const PantryUserPrefs(), // à remplir
    );

    final json = await _chat.askCloud(q, ctx); // HTTP → JSON
    final text = _chat.render(json);          // transforme JSON → message lisible

    if (!mounted) return;
    setState(() => _msgs.add((me: false, text: text)));
    _chat.runActions(json, context); // ex: ouvrir recette / ajouter aux courses
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Assistant garde-manger')),
      body: Column(
        children: [
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.all(12),
              itemCount: _msgs.length,
              itemBuilder: (_, i) {
                final m = _msgs[i];
                return Align(
                  alignment: m.me ? Alignment.centerRight : Alignment.centerLeft,
                  child: Container(
                    margin: const EdgeInsets.symmetric(vertical: 4),
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: m.me
                          ? Theme.of(context).colorScheme.primaryContainer
                          : Theme.of(context).colorScheme.surfaceContainerHighest,
                      borderRadius: BorderRadius.circular(14),
                    ),
                    child: Text(m.text),
                  ),
                );
              },
            ),
          ),
          SafeArea(
            top: false,
            child: Padding(
              padding: const EdgeInsets.fromLTRB(12, 8, 12, 12),
              child: Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: _ctrl,
                      decoration: const InputDecoration(
                        hintText: 'Pose une question (ex: "idées sans gluten ce soir ?")',
                        border: OutlineInputBorder(),
                      ),
                      onSubmitted: (_) => _send(),
                    ),
                  ),
                  const SizedBox(width: 8),
                  FilledButton.icon(
                    onPressed: _send,
                    icon: const Icon(Icons.send_rounded),
                    label: const Text('Envoyer'),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

### chef_ia_app/lib/ui/screens/pantry_export_import.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../../services/storage/pantry_store.dart';

/// Mixin pour ajouter les fonctionnalités d'export/import au PantryScreen
mixin PantryExportImportMixin {
  PantryStore get pantryStore;
  Future<void> Function() get reloadPantry;
  void Function(String) get showToast;

  /// Exporte le garde-manger en JSON
  Future<void> exportPantry() async {
    try {
      final json = await pantryStore.exportAsJson();
      
      // Copier dans le presse-papiers
      await Clipboard.setData(ClipboardData(text: json));
      
      showToast("Garde-manger exporté dans le presse-papiers !");
      
      // Optionnel : sauvegarder dans un fichier
      // TODO: implémenter la sauvegarde de fichier si nécessaire
    } catch (e) {
      showToast("Erreur lors de l'export: $e");
    }
  }

  /// Importe un garde-manger depuis le presse-papiers
  Future<void> importPantry(BuildContext context) async {
    try {
      final clipboardData = await Clipboard.getData('text/plain');
      if (clipboardData?.text == null || clipboardData!.text!.isEmpty) {
        showToast("Aucune donnée dans le presse-papiers");
        return;
      }

      // Demander confirmation
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: const Text('Importer un garde-manger'),
          content: const Text(
            'Cela va ajouter les articles du presse-papiers à votre garde-manger actuel. '
            'Les doublons seront mis à jour automatiquement.\n\n'
            'Continuer ?'
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: const Text('Annuler'),
            ),
            FilledButton(
              onPressed: () => Navigator.of(ctx).pop(true),
              child: const Text('Importer'),
            ),
          ],
        ),
      );

      if (confirmed != true) return;

      // Importer
      final result = await pantryStore.importFromJson(clipboardData.text!);
      
      showToast(
        "Import terminé: ${result['added']} ajoutés, "
        "${result['updated']} mis à jour, "
        "${result['skipped']} ignorés"
      );

      // Recharger la liste
      await reloadPantry();
    } catch (e) {
      showToast("Erreur lors de l'import: $e");
    }
  }
}











```

### chef_ia_app/lib/ui/screens/pantry_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:chef_ia_app/features/pantry/widgets/pantry_app_bar.dart';
import 'package:chef_ia_app/features/pantry/widgets/pantry_fab.dart';
import 'package:chef_ia_app/features/pantry/widgets/pantry_effects.dart';
import 'package:chef_ia_app/features/pantry/screens/pantry_body.dart';
import 'package:chef_ia_app/features/pantry/state/pantry_provider.dart';
import 'package:chef_ia_app/models/pantry_item.dart';

class PantryScreen extends ConsumerStatefulWidget {
  const PantryScreen({super.key});
  
  @override
  ConsumerState<PantryScreen> createState() => _PantryScreenState();
}

class _PantryScreenState extends ConsumerState<PantryScreen> {
  Future<void> _quickAdd() async {
    final controller = TextEditingController();
    final name = await showDialog<String>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Ajouter un produit'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(hintText: 'Nom du produit'),
          autofocus: true,
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Annuler')),
          FilledButton(onPressed: () => Navigator.pop(context, controller.text.trim()), child: const Text('Ajouter')),
        ],
      ),
    );
    if (name == null || name.isEmpty) return;
    final id = const Uuid().v4();
    await ref.read(pantryNotifierProvider.notifier).addItem(
      PantryItem(
        id: id,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        name: name,
      ),
    );
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('"$name" ajouté')));
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Semantics(
      label: 'SCREEN:/pantry',
      child: Scaffold(
        appBar: AppBar(title: const Text('Écran Garde-manger  •  /pantry')),
      body: Semantics(
        label: 'SCREEN:/pantry',
        child: const PantryEffects(child: PantryBody()),
      ),
      floatingActionButton: PantryFab(onAdd: _quickAdd      ),
    ),
    );
  }
}

```

### chef_ia_app/lib/ui/screens/pantry_settings_screen.dart
```dart
// lib/ui/screens/pantry_settings_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:chef_ia_app/providers/pantry_prefs_provider.dart';
import 'package:chef_ia_app/providers/grace_policy_provider.dart';
import 'package:chef_ia_app/core/grace_policy.dart';

class PantrySettingsScreen extends ConsumerStatefulWidget {
  const PantrySettingsScreen({super.key});
  @override
  ConsumerState<PantrySettingsScreen> createState() => _PantrySettingsScreenState();
}

class _PantrySettingsScreenState extends ConsumerState<PantrySettingsScreen> {
  final _controllerTopK = TextEditingController(text: '10');
  Map<String, int>? _grace; // nullable → pas de LateInitializationError
  bool _useCloud = true;
  bool _privacyCloud = true;

  @override
  void dispose() {
    _controllerTopK.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final prefs = ref.watch(pantryPrefsProvider);
    // init paresseuse une seule fois
    _grace ??= Map<String, int>.from(prefs.graceByCategory);
    _useCloud = prefs.useCloud;
    _privacyCloud = prefs.privacyCloud;
    // évite de réécrire le texte à chaque build (saut du curseur) :
    if (_controllerTopK.text != prefs.topK.toString()) {
      _controllerTopK.text = prefs.topK.toString();
    }
    final graceMap = _grace!;             // désormais non-null ici
    final cats = graceMap.keys.toList()..sort();
    return Scaffold(
      appBar: AppBar(title: const Text('Réglages Garde-manger')),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          SwitchListTile(
            title: const Text('Utiliser l\'IA Cloud'),
            value: _useCloud,
            onChanged: (v) => setState(() => _useCloud = v),
          ),
          SwitchListTile(
            title: const Text('Anonymiser avant envoi Cloud'),
            value: _privacyCloud,
            onChanged: (v) => setState(() => _privacyCloud = v),
          ),
          TextField(
            controller: _controllerTopK,
            keyboardType: TextInputType.number,
            decoration: const InputDecoration(labelText: 'Top-K (produits concernés)'),
          ),
          const SizedBox(height: 12),
          const Text('Périodes de grâce (jours) par catégorie', style: TextStyle(fontWeight: FontWeight.bold)),
          const SizedBox(height: 8),
          for (final c in cats)
            Row(
              children: [
                Expanded(child: Text(c)),
                SizedBox(
                  width: 80,
                  child: TextFormField(
                    initialValue: graceMap[c].toString(),
                    keyboardType: TextInputType.number,
                    onChanged: (v) => setState(() {
                      graceMap[c] = int.tryParse(v) ?? graceMap[c]!;
                    }),
                  ),
                ),
              ],
            ),
          const SizedBox(height: 24),
          FilledButton(
            onPressed: () {
              final topK = int.tryParse(_controllerTopK.text) ?? 10;
              final mapToSave = Map<String,int>.from(_grace!);
              ref.read(pantryPrefsProvider.notifier).updateFromMap({
                'useCloud': _useCloud,
                'privacyCloud': _privacyCloud,
                'topK': topK,
                'graceByCategory': mapToSave,
              });
              // sync GracePolicy globale (utilisée par LocalPantryAdvisorV2)
              ref.read(gracePolicyProvider.notifier).setGraceByCategory(mapToSave);
              Navigator.pop(context);
            },
            child: const Text('Enregistrer'),
          ),
        ],
      ),
    );
  }
}

```

### chef_ia_app/lib/ui/screens/recipe_detail_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:chef_ia_app/services/ai_service.dart'; // pour RecipeFullDto

class RecipeDetailScreen extends StatelessWidget {
  final RecipeFullDto recipe;
  const RecipeDetailScreen({super.key, required this.recipe});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;

    Widget section(String title, List<String> items) {
      return Container(
        margin: const EdgeInsets.only(bottom: 16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(title, style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            ...items.map((e) => Padding(
                  padding: const EdgeInsets.only(bottom: 6),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text('• '),
                      Expanded(child: Text(e)),
                    ],
                  ),
                )),
          ],
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Recette'),
        centerTitle: true,
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // Titre + temps
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: cs.surface,
              borderRadius: BorderRadius.circular(16),
              border: Border.all(color: cs.outlineVariant.withValues(alpha: 0.6)),
            ),
            child: Row(
              children: [
                Expanded(
                  child: Text(
                    recipe.title,
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                ),
                const Icon(Icons.timer, size: 18),
                const SizedBox(width: 6),
                Text(recipe.time),
              ],
            ),
          ),
          const SizedBox(height: 16),

          section('Ingrédients', recipe.ingredients),
          section('Matériel requis', recipe.equipment),
          section('Étapes', recipe.steps),

          const SizedBox(height: 8),
          FilledButton.icon(
            onPressed: () {
              // TODO: branchement sur ton mode pas-à-pas
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Démarrage du mode pas à pas…')),
              );
            },
            icon: const Icon(Icons.play_arrow_rounded),
            label: const Text('Commencer la recette'),
          ),
        ],
      ),
    );
  }
}


```

### chef_ia_app/lib/ui/screens/recipe_runner_screen.dart
```dart
import 'package:flutter/material.dart';
import 'dart:async';
import 'package:speech_to_text/speech_to_text.dart' as stt;
import '../../core/event_bus.dart';
import '../../core/events.dart';
import '../../core/tips_engine.dart';
import '../../core/models/recipe_step_vis.dart';

import '../a11y/a11y_semantics.dart';
import '../widgets/bottom_gutter.dart';

class RecipeRunnerScreen extends StatefulWidget {
  final List<RecipeStepVis> steps;


  const RecipeRunnerScreen({super.key, required this.steps});

  @override
  State<RecipeRunnerScreen> createState() => _RecipeRunnerScreenState();
}

class _RecipeRunnerScreenState extends State<RecipeRunnerScreen> {
  int _currentStep = 0;
  final TipsEngine _tipsEngine = TipsEngine();
  
  // Timer et commandes vocales
  Timer? _timer;
  int _remaining = 0;
  final stt.SpeechToText _stt = stt.SpeechToText();
  bool _sttReady = false;

  // TODO: Implémenter TTS plus tard
  bool _handsFree = false;   // toggle mains libres
  bool _mute = false;        // couper la voix si besoin

  // Mapping icônes par type d'étape (basique pour l'instant)
  IconData _getStepIcon(RecipeStepVis step) {
    final instruction = step.instruction.toLowerCase();
    if (instruction.contains("coupe") || instruction.contains("découpe")) return Icons.restaurant;
    if (instruction.contains("four") || instruction.contains("cuisson") || instruction.contains("chauffer")) return Icons.local_fire_department;
    if (instruction.contains("mélange") || instruction.contains("fouetter")) return Icons.soup_kitchen;
    if (instruction.contains("repos")) return Icons.timer;
    return Icons.circle; // par défaut
  }

  @override
  void initState() {
    super.initState();
    _initSTT();
    _startTimerIfAny();
    // TODO: Implémenter TTS plus tard

    // Écoute les conseils et affiche en toast
    EventBus().on('advice.event').listen((event) {
      if (event is AdviceEvent && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(event.message ?? 'Conseil'),
            duration: const Duration(seconds: 4),
            behavior: SnackBarBehavior.floating,
            backgroundColor: Theme.of(context).colorScheme.primary,
          ),
        );
      }
    });

    // Lancer un premier conseil
    _tipsEngine.onStepStarted(widget.steps[_currentStep].instruction);
  }

  @override
  void dispose() {
    _timer?.cancel();
    // TODO: Implémenter TTS plus tard
    super.dispose();
  }

  Future<void> _initSTT() async {
    _sttReady = await _stt.initialize();
    setState(() {});
  }

  Future<void> _speakCurrentStep() async {
    // TODO: Implémenter TTS plus tard
    if (_handsFree) {
      // on attend un peu puis on écoute
      Future.delayed(const Duration(milliseconds: 600), _listenOnce);
    }
  }

  void _startTimerIfAny() {
    _timer?.cancel();
    final step = widget.steps[_currentStep];
    if (step.timerSec != null && step.timerSec! > 0) {
      _remaining = step.timerSec!;
      _timer = Timer.periodic(const Duration(seconds: 1), (t) {
        setState(() => _remaining--);
        if (_remaining <= 0) {
          t.cancel();
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text("⏰ Chrono terminé pour cette étape.")),
          );
          // TODO: Implémenter TTS plus tard
        }
      });
    } else {
      _remaining = 0;
    }
  }

  void _goto(int index) {
    if (index < 0 || index >= widget.steps.length) return;
    setState(() {
      _currentStep = index;
    });
    _startTimerIfAny();
    // TODO: Implémenter TTS plus tard
    _tipsEngine.onStepStarted(widget.steps[_currentStep].instruction);
  }

  void _nextStep() => _goto(_currentStep + 1);
  void _prevStep() => _goto(_currentStep - 1);

  Widget buildAnalysisPanel(ThemeData theme) {
    final cs = theme.colorScheme;
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Analyse IA', style: theme.textTheme.titleMedium),
            const SizedBox(height: 8),
            Text('Difficulté: Moyenne'),
            Text('Temps estimé: ${widget.steps.length * 5} min'),
            Text('Techniques: Cuisson, préparation'),
            Text('Risques: Aucun'),
            const SizedBox(height: 8),
            Text('Conseils:', style: theme.textTheme.titleSmall),
            const Text('• Suivez les étapes dans l\'ordre'),
            const Text('• Préparez tous les ingrédients à l\'avance'),
          ],
        ),
      ),
    );
  }

  Future<void> _listenOnce() async {
    if (!_sttReady) return;
    await _stt.listen(
      localeId: 'fr_FR',
      onResult: (r) {
        final txt = r.recognizedWords.toLowerCase();
        if (txt.contains("suivant") || txt.contains("continue")) _nextStep();
        else if (txt.contains("précédent") || txt.contains("retour")) _prevStep();
        else if (txt.contains("répète") || txt.contains("répéter")) {
          _speakCurrentStep();
        } else if (txt.contains("muet") || txt.contains("coupe le son")) {
          setState(() => _mute = true);
        } else if (txt.contains("son") || txt.contains("parle")) {
          setState(() => _mute = false);
          // TODO: Implémenter TTS plus tard
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text("Commande non reconnue: $txt")),
          );
        }
        _stt.stop();
        // si mains libres, on relance l'écoute après un petit délai (boucle douce)
        if (_handsFree) {
          Future.delayed(const Duration(milliseconds: 800), _listenOnce);
        }
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final step = widget.steps[_currentStep];
    final stepText = step.instruction;
    final pos = "${_currentStep + 1} sur ${widget.steps.length}";

    return Scaffold(
      appBar: AppBar(
        title: Text(step.title.isNotEmpty ? step.title : 'Recette en cours'),
                  backgroundColor: Theme.of(context).colorScheme.primary,
                     foregroundColor: Theme.of(context).colorScheme.onPrimary,
      ),
      bottomNavigationBar: const BottomGutter(),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            // Étape courante (annoncée comme en-tête)
            Semantics(
              header: true,
              label: "Étape $pos",
              child: ExcludeSemantics(
                child: Align(
                  alignment: Alignment.centerLeft,
                  child: Text(
                    "Étape $pos",
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                ),
              ),
            ),
            const SizedBox(height: 12),

            // Texte de l'étape (lu comme paragraphe)
            Semantics(
              label: "Instruction",
              hint: "Lis attentivement puis utilise les boutons en bas",
              child: ExcludeSemantics(
                child: Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: Theme.of(context).cardColor,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    stepText,
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                ),
              ),
            ),
            const Spacer(),

            // Contrôles
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                A11yIconButton(
                  label: "Étape précédente",
                  hint: "Revenir à l'étape ${_currentStep > 0 ? _currentStep : _currentStep + 1}",
                  enabled: _currentStep > 0,
                  onPressed: _currentStep > 0 ? _prevStep : null,
                  icon: Icons.arrow_back,
                ),
                A11yIconButton(
                  label: "Répéter l'étape",
                  hint: "Répéter l'instruction actuelle avec la synthèse vocale",
                  onPressed: _speakCurrentStep,
                  icon: Icons.volume_up,
                ),
                A11yIconButton(
                  label: "Étape suivante",
                  hint: "Passer à l'étape ${_currentStep + 2 <= widget.steps.length ? _currentStep + 2 : widget.steps.length}",
                  enabled: _currentStep + 1 < widget.steps.length,
                  onPressed: _currentStep + 1 < widget.steps.length ? _nextStep : null,
                  icon: Icons.arrow_forward,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}


```

### chef_ia_app/lib/ui/screens/tester_feedback_screen.dart
```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import '../../core/dev_logger.dart';

class TesterFeedbackScreen extends StatefulWidget {
  const TesterFeedbackScreen({super.key});

  @override
  State<TesterFeedbackScreen> createState() => _TesterFeedbackScreenState();
}

class _TesterFeedbackScreenState extends State<TesterFeedbackScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleCtrl = TextEditingController();
  final _descCtrl = TextEditingController();
  File? _image;
  bool _sending = false;

  Future<void> _pickImage(bool fromCamera) async {
    final picker = ImagePicker();
    final x = await picker.pickImage(source: fromCamera ? ImageSource.camera : ImageSource.gallery, imageQuality: 85);
    if (x != null) setState(() => _image = File(x.path));
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;
    setState(() => _sending = true);

    // 1) Log local (lisible)
    DevLogger.info("Feedback",
        "Titre='${_titleCtrl.text.trim()}', Desc='${_titleCtrl.text.trim()}', Image=${_image != null ? _image!.path : 'none'}");
    
    // 2) Log bêta détaillé
    DevLogger.info("Feedback", "Soumission feedback - longueur titre: ${_titleCtrl.text.trim().length}, longueur desc: ${_descCtrl.text.trim().length}, taille image: ${_image != null ? _image!.lengthSync() : 0} bytes", betaOnly: true);

    // 2) Partage des logs (l'utilisateur choisira le canal : mail, WhatsApp…)
    await DevLogger.shareLogs(asJson: true);

    setState(() => _sending = false);
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Merci pour le retour !")));
      Navigator.pop(context);
    }
  }

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Scaffold(
      appBar: AppBar(title: const Text("Retour testeur")),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              TextFormField(
                controller: _titleCtrl,
                decoration: const InputDecoration(
                  labelText: "Titre (bug, idée, amélioration…)",
                ),
                validator: (v) => (v == null || v.trim().isEmpty) ? "Obligatoire" : null,
              ),
              const SizedBox(height: 12),
              TextFormField(
                controller: _descCtrl,
                maxLines: 4,
                decoration: const InputDecoration(
                  labelText: "Description (ce qui s'est passé / attendu)",
                ),
                validator: (v) => (v == null || v.trim().isEmpty) ? "Obligatoire" : null,
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  ElevatedButton.icon(
                    onPressed: () => _pickImage(true),
                    icon: const Icon(Icons.photo_camera),
                    label: const Text("Photo"),
                  ),
                  const SizedBox(width: 8),
                  OutlinedButton.icon(
                    onPressed: () => _pickImage(false),
                    icon: const Icon(Icons.photo_library),
                    label: const Text("Galerie"),
                  ),
                ],
              ),
              if (_image != null) ...[
                const SizedBox(height: 12),
                ClipRRect(
                  borderRadius: BorderRadius.circular(12),
                  child: Image.file(_image!, height: 160, fit: BoxFit.cover),
                ),
              ],
              const SizedBox(height: 20),
              FilledButton.icon(
                onPressed: _sending ? null : _submit,
                icon: _sending ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)) : const Icon(Icons.send),
                label: Text(_sending ? "Envoi..." : "Envoyer le retour"),
                style: FilledButton.styleFrom(
                  backgroundColor: cs.primary,
                  foregroundColor: cs.onPrimary,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

### chef_ia_app/lib/ui/widgets/bottom_gutter.dart
```dart
import 'dart:math';
import 'package:flutter/material.dart';

class BottomGutter extends StatelessWidget {
  const BottomGutter({super.key});

  @override
  Widget build(BuildContext context) {
    final inset = MediaQuery.viewPaddingOf(context).bottom; // hauteur barre système
    final h = max(inset, 14.0); // mini 14px même si pas de gestuelle

    return Container(
      height: h,
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        border: Border(
          top: BorderSide(
            color: Theme.of(context).colorScheme.outlineVariant.withValues(alpha: 0.5),
          ),
        ),
      ),
    );
  }
}

```

### chef_ia_app/lib/ui/widgets/input_bar.dart
```dart
import 'package:flutter/material.dart';

class InputBar extends StatefulWidget {
  final Future<void> Function(String text) onSend;
  final bool loading;
  final String hintText;

  const InputBar({
    super.key,
    required this.onSend,
    required this.loading,
    this.hintText = "Décris ce que tu veux cuisiner...",
  });

  @override
  State<InputBar> createState() => _InputBarState();
}

class _InputBarState extends State<InputBar> {
  final _controller = TextEditingController();
  final _focus = FocusNode();

  @override
  void dispose() {
    _controller.dispose();
    _focus.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    final text = _controller.text.trim();
    if (text.isEmpty || widget.loading) return;
    _controller.clear();
    await widget.onSend(text);
    _focus.requestFocus();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return SafeArea(
      top: false,
      child: Padding(
        padding: const EdgeInsets.fromLTRB(12, 8, 12, 12),
        child: Row(
          children: [
            Expanded(
              child: TextField(
                focusNode: _focus,
                controller: _controller,
                onSubmitted: (_) => _submit(),
                textInputAction: TextInputAction.send,
                decoration: InputDecoration(
                  hintText: widget.hintText,
                  border: const OutlineInputBorder(),
                  isDense: true,
                  contentPadding: const EdgeInsets.symmetric(
                    vertical: 12, horizontal: 12,
                  ),
                ),
              ),
            ),
            const SizedBox(width: 8),
            Tooltip(
              message: "Envoyer",
              child: ElevatedButton.icon(
                onPressed: widget.loading ? null : _submit,
                icon: widget.loading
                    ? const SizedBox(
                        width: 18, height: 18,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Icon(Icons.send_rounded, size: 18),
                label: Text(widget.loading ? "..." : "Envoyer"),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                  textStyle: theme.textTheme.labelLarge,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

### chef_ia_app/lib/ui/widgets/message_bubble.dart
```dart
import 'package:flutter/material.dart';
import '../../core/stores/assistant_state.dart';

class MessageBubble extends StatelessWidget {
  final ChatMessage message;
  const MessageBubble({super.key, required this.message});

  @override
  Widget build(BuildContext context) {
    final isAi = message.isAi;
    final theme = Theme.of(context);

    return Align(
      alignment: isAi ? Alignment.centerLeft : Alignment.centerRight,
      child: Container(
        constraints: const BoxConstraints(maxWidth: 720),
        margin: const EdgeInsets.symmetric(vertical: 6, horizontal: 12),
        padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 14),
        decoration: BoxDecoration(
          color: isAi
              ? theme.colorScheme.surface
              : theme.colorScheme.primary.withValues(alpha: 0.12),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(
            color: theme.colorScheme.outlineVariant.withValues(alpha: 0.5),
          ),
        ),
        child: SelectableText(
          message.text,
          style: theme.textTheme.bodyMedium,
        ),
      ),
    );
  }
}

```

### chef_ia_app/lib/ui/widgets/pantry_advice_chips.dart
```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:chef_ia_app/core/event_bus.dart';
import 'package:chef_ia_app/models/pantry_advisory.dart';

class PantryAdviceChips extends StatefulWidget {
  const PantryAdviceChips({super.key});
  @override
  State<PantryAdviceChips> createState() => _PantryAdviceChipsState();
}

class _PantryAdviceChipsState extends State<PantryAdviceChips> {
  StreamSubscription? _sub;
  List<PantryAdvisory> _advisories = const [];

  @override
  void initState() {
    super.initState();
    // Écoute les conseils silencieux
    _sub = EventBus()
        .on('pantry.advisory.ready')
        .listen((e) => _onAdvisoriesEvent(e as Map<String, dynamic>));
    // Option : demande immédiate au démarrage de l'écran
    EventBus().emit('pantry.chat.requested', {'reason': 'screen_open'});
  }

  void _onAdvisoriesEvent(Map<String, dynamic> e) {
    final pay = (e['payload'] as Map?)?.cast<String, dynamic>() ?? {};
    final list = (pay['advisories'] as List?) ?? const [];
    final parsed = list
        .whereType<Map>()
        .map((m) => PantryAdvisory.fromJson(m.cast<String, dynamic>()))
        .toList();
    // Décale le setState après frame pour éviter les conflits
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      setState(() => _advisories = parsed);
    });
  }

  @override
  void dispose() {
    _sub?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (_advisories.isEmpty) {
      return Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        child: Wrap(
          spacing: 8,
          runSpacing: 8,
          children: const [
            Chip(label: Text('Rien d\'urgent')),
            Chip(label: Text('Idées < 30 min')),
          ],
        ),
      );
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Wrap(
        spacing: 8,
        runSpacing: 8,
        children: _advisories.take(6).map((a) {
          final label = a.title.isNotEmpty ? a.title : (a.reason ?? 'Conseil');
          return ActionChip(
            label: Text(label, overflow: TextOverflow.ellipsis),
            onPressed: () => _runFirstAction(context, a),
          );
        }).toList(),
      ),
    );
  }

  void _runFirstAction(BuildContext context, PantryAdvisory a) {
    if (a.actions.isEmpty) return;

    // On gère quelques actions standards : FILTER / RECIPE / NAVIGATE
    final act = a.actions.first;
    switch (act.action) {
      case 'FILTER':
        // act.params ex: {'status':'soon'} ou {'category':'frais'}
        EventBus().emit('pantry.ui.apply_filter', act.params);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Filtre appliqué : ${act.params}')),
        );
        break;
      case 'RECIPE':
        // act.params ex: {'with':['lait','oeufs']}
        EventBus().emit('recipes.requested', act.params);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Ouverture des idées de recettes…')),
        );
        break;
      case 'NAVIGATE':
        // act.params ex: {'route':'/pantry', 'args': {'tab':'soon'}}
        final route = act.params['route'] as String? ?? '/pantry';
        final args  = act.params['args'];
        Navigator.of(context).pushNamed(route, arguments: args);
        break;
      default:
        // fallback : rien
        break;
    }
  }
}


```

### chef_ia_app/lib/ui/widgets/pantry_chat_bubble.dart
```dart
import 'package:flutter/material.dart';
import '../../services/ai/pantry_advisor_v2.dart';
import '../../services/chat/pantry_chat.dart';
import '../../models/pantry_item.dart' as new_model;

class PantryChatBubble extends StatefulWidget {
  final List<new_model.PantryItem> items;
  final PantryAdvisor advisor;
  final void Function(List<String> itemIds) onOpenRecipe;
  final String? initialQuery;

  const PantryChatBubble({
    super.key,
    required this.items,
    required this.advisor,
    required this.onOpenRecipe,
    this.initialQuery,
  });

  @override
  State<PantryChatBubble> createState() => _PantryChatBubbleState();
}

class _PantryChatBubbleState extends State<PantryChatBubble> {
  final _ctrl = TextEditingController();
  final _chat = PantryChat();
  final _msgs = <({bool me, String text})>[];
  bool _cloudBusy = false;
  int _reqToken = 0;

  Future<void> _send() async {
    final q = _ctrl.text.trim();
    if (q.isEmpty) return;
    setState(() {
      _msgs.add((me: true, text: q));
      _ctrl.clear();
    });

    // RAG local → top-K + near-expiry
    final top = _chat.pickTopK(widget.items, q, k: 20);
    final near = widget.advisor.getExpiringSoon(widget.items, withinDays: 3).map((e) => e.id).toList();
    final ctx = PantryChatContext.fromNow(
      items: top,
      nearExpiryIds: near,
      locationAllowed: false,  // à brancher selon les préférences globales
      locationApprox: null,
      temperatureC: null,
      userPrefs: const PantryUserPrefs(),
    );

    // hint local immédiat
    final hint = _chat.localHint(top, near);
    if (hint != null) setState(() => _msgs.add((me: false, text: hint)));

    setState(() => _cloudBusy = true);
    final myToken = ++_reqToken;

    Map<String, dynamic> json;
    try {
      json = await _chat.askCloud(q, ctx, timeout: const Duration(seconds: 6));
    } catch (_) {
      json = _chat.askCloudFallback(q, ctx);
    }
    if (!mounted || _reqToken != myToken) return;

    setState(() {
      _msgs.add((me: false, text: _chat.render(json)));
      _cloudBusy = false;
    });

    // Exécuter actions (ouvrir recettes, etc.)
    _chat.runActions(json, context);
  }

  @override
  void initState() {
    super.initState();
    if (widget.initialQuery != null && widget.initialQuery!.isNotEmpty) {
      _ctrl.text = widget.initialQuery!;
      // Optionnel : envoi automatique
      // WidgetsBinding.instance.addPostFrameCallback((_) => _send());
    }
  }

  @override
  void dispose() {
    _ctrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final sheet = DraggableScrollableSheet(
      initialChildSize: 0.88,
      minChildSize: 0.6,
      maxChildSize: 0.96,
      builder: (_, controller) {
        return Material(
          color: Theme.of(context).colorScheme.surface,
          elevation: 8,
          borderRadius: const BorderRadius.vertical(top: Radius.circular(28)),
          child: Column(
            children: [
              const SizedBox(height: 8),
              Container(
                width: 40, height: 4,
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.outlineVariant,
                  borderRadius: BorderRadius.circular(999),
                ),
              ),
              Padding(
                padding: const EdgeInsets.fromLTRB(16, 12, 8, 0),
                child: Row(
                  children: [
                    Text('Assistant garde-manger',
                        style: Theme.of(context).textTheme.titleMedium),
                    const Spacer(),
                    if (_cloudBusy)
                      SizedBox(width: 16, height: 16,
                        child: CircularProgressIndicator(strokeWidth: 2)),
                    IconButton(
                      tooltip: 'Fermer',
                      icon: const Icon(Icons.close_rounded),
                      onPressed: () => Navigator.pop(context),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 4),
              Expanded(
                child: ListView.builder(
                  controller: controller,
                  padding: const EdgeInsets.fromLTRB(12, 8, 12, 8),
                  itemCount: _msgs.length,
                  itemBuilder: (_, i) {
                    final m = _msgs[i];
                    return Align(
                      alignment: m.me ? Alignment.centerRight : Alignment.centerLeft,
                      child: Container(
                        margin: const EdgeInsets.symmetric(vertical: 4),
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: m.me
                              ? Theme.of(context).colorScheme.primaryContainer
                              : Theme.of(context).colorScheme.surfaceContainerHighest,
                          borderRadius: BorderRadius.circular(14),
                        ),
                        child: Text(m.text),
                      ),
                    );
                  },
                ),
              ),
              SafeArea(
                top: false,
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(12, 8, 12, 12),
                  child: Row(
                    children: [
                      Expanded(
                        child: TextField(
                          controller: _ctrl,
                          decoration: const InputDecoration(
                            hintText: 'Pose une question ou cherche un produit…',
                            border: OutlineInputBorder(),
                          ),
                          onSubmitted: (_) => _send(),
                        ),
                      ),
                      const SizedBox(width: 8),
                      FilledButton.icon(
                        onPressed: _send,
                        icon: const Icon(Icons.send_rounded),
                        label: const Text('Envoyer'),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );

    return GestureDetector(
      onTap: () {}, // laisse passer les gestures au sheet
      child: sheet,
    );
  }
}

```

### chef_ia_app/lib/ui/widgets/recipe_card.dart
```dart
import 'package:flutter/material.dart';
import 'package:chef_ia_app/ui/a11y/a11y_semantics.dart';

class RecipeCard extends StatelessWidget {
  final String title;
  final String subtitle; // ex: "40 min • 4 pers"
  final String? imageUrl;
  final VoidCallback onOpen;

  const RecipeCard({
    super.key,
    required this.title,
    required this.subtitle,
    this.imageUrl,
    required this.onOpen,
  });

  @override
  Widget build(BuildContext context) {
    return A11yTileButton(
      label: title,
      hint: "Ouvre la recette : $title. $subtitle",
      onTap: onOpen,
      child: Card(
        clipBehavior: Clip.antiAlias,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (imageUrl != null)
              A11yImage(
                image: NetworkImage(imageUrl!),
                semanticsLabel: "Photo de la recette $title",
                height: 140,
                fit: BoxFit.cover,
              ),
            Padding(
              padding: const EdgeInsets.all(12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Les Text internes ne seront pas lus grâce à ExcludeSemantics parent
                  Text(title, style: Theme.of(context).textTheme.titleMedium),
                  const SizedBox(height: 4),
                  Text(subtitle, style: Theme.of(context).textTheme.bodyMedium),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

### chef_ia_app/lib/utils/recipe_parser.dart
```dart
// lib/utils/recipe_parser.dart
import 'dart:convert';
import '../core/models/recipe.dart'; // pour convertir vers le modèle unifié

/// -----------------------
/// Modèle normalisé (interne)
/// -----------------------

class ParsedRecipe {
  final String version;
  final Metadata metadata;
  final String title;
  final List<String> equipment;
  final List<IngredientItem> ingredients;
  final List<StepItem> steps;
  final List<String> allergens;
  final List<String> notes;

  ParsedRecipe({
    required this.version,
    required this.metadata,
    required this.title,
    required this.equipment,
    required this.ingredients,
    required this.steps,
    required this.allergens,
    required this.notes,
  });

  factory ParsedRecipe.fromJson(Map<String, dynamic> json) {
    return ParsedRecipe(
      version: (json['version'] ?? 'chefia.v1').toString(),
      metadata: Metadata.fromJson(_asMap(json['metadata'])),
      title: _asString(json['title']),
      equipment: _asStringList(json['equipment']),
      ingredients: _asList(json['ingredients'])
          .map((e) => IngredientItem.fromJson(_asMap(e)))
          .toList(),
      steps: _asList(json['steps']).map((e) => StepItem.fromJson(_asMap(e))).toList(),
      allergens: _asStringList(json['allergens']),
      notes: _asStringList(json['notes']),
    );
  }

  Map<String, dynamic> toJson() => {
        'version': version,
        'metadata': metadata.toJson(),
        'title': title,
        'equipment': equipment,
        'ingredients': ingredients.map((e) => e.toJson()).toList(),
        'steps': steps.map((e) => e.toJson()).toList(),
        'allergens': allergens,
        'notes': notes,
      };

  /// Conversion vers ton modèle `Recipe` existant (title/ingredients/steps/equipmentNeeded/missingEquipment).
  /// On reconstruit `equipmentNeeded` à partir des étapes/ingrédients si absent, et `missingEquipment` vide ici.
  Recipe toLegacyRecipe({List<String> userEquipment = const []}) {
    final needed = equipment.isNotEmpty ? equipment : _inferEquipmentFromSteps(steps);
    return Recipe(
      id: title.toLowerCase().replaceAll(' ', '_'),
      title: title,
      type: RecipeType.everyday,
      prepMinutes: 0,
      cookMinutes: 0,
      ingredients: ingredients.map((i) => Ingredient(
        name: i.item,
        quantity: i.quantity,
        unit: i.unit,
      )).toList(),
      steps: steps.asMap().entries.map((entry) => InstructionStep(
        index: entry.key,
        text: entry.value.text,
      )).toList(),
    );
  }

  static List<String> _inferEquipmentFromSteps(List<StepItem> steps) {
    final hits = <String>{};
    for (final s in steps) {
      final t = s.text.toLowerCase();
      if (t.contains('four')) hits.add('four');
      if (t.contains('poêle') || t.contains('poele')) hits.add('poêle');
      if (t.contains('casserole')) hits.add('casserole');
      if (t.contains('mixeur') || t.contains('blender')) hits.add('mixeur');
      if (t.contains('robot')) hits.add('robot');
      if (t.contains('batteur')) hits.add('batteur');
      if (t.contains('moule')) hits.add('moule');
      if (t.contains('plaque')) hits.add('plaque');
    }
    return hits.toList();
  }
}

class Metadata {
  final String language;
  final int servings;
  final TimeBlock time;
  final String difficulty; // conservé pour compat schéma (style est géré dans le prompt)

  Metadata({
    required this.language,
    required this.servings,
    required this.time,
    required this.difficulty,
  });

  factory Metadata.fromJson(Map<String, dynamic> json) {
    return Metadata(
      language: _asString(json['language'], fallback: 'fr'),
      servings: _asInt(json['servings'], fallback: 2),
      time: TimeBlock.fromJson(_asMap(json['time'])),
      difficulty: _asString(json['difficulty'], fallback: 'facile'),
    );
  }

  Map<String, dynamic> toJson() => {
        'language': language,
        'servings': servings,
        'time': time.toJson(),
        'difficulty': difficulty,
      };
}

class TimeBlock {
  final int prepMin;
  final int cookMin;
  final int restMin;

  TimeBlock({required this.prepMin, required this.cookMin, required this.restMin});

  factory TimeBlock.fromJson(Map<String, dynamic> json) {
    return TimeBlock(
      prepMin: _asInt(json['prep_min']),
      cookMin: _asInt(json['cook_min']),
      restMin: _asInt(json['rest_min']),
    );
  }

  Map<String, dynamic> toJson() => {
        'prep_min': prepMin,
        'cook_min': cookMin,
        'rest_min': restMin,
      };
}

class IngredientItem {
  final String item;
  final double? quantity;
  final String? unit;
  final String? notes;

  IngredientItem({
    required this.item,
    this.quantity,
    this.unit,
    this.notes,
  });

  factory IngredientItem.fromJson(Map<String, dynamic> json) {
    return IngredientItem(
      item: _normalizeItem(_asString(json['item'])),
      quantity: _asDoubleOrNull(json['quantity']),
      unit: _normalizeUnit(_asString(json['unit'])),
      notes: _asString(json['notes']),
    );
  }

  Map<String, dynamic> toJson() => {
        'item': item,
        'quantity': quantity,
        'unit': unit,
        'notes': notes,
      };
}

class StepItem {
  final int n;
  final String text;
  final int? timerMin;
  final String tips;

  StepItem({
    required this.n,
    required this.text,
    required this.timerMin,
    required this.tips,
  });

  factory StepItem.fromJson(Map<String, dynamic> json) {
    final nVal = _asInt(json['n'], fallback: 0);
    final textVal = _cleanSentence(_asString(json['text']));
    final timer = json['timer_min'] == null ? null : _asInt(json['timer_min']);
    return StepItem(
      n: nVal > 0 ? nVal : 1,
      text: textVal,
      timerMin: timer,
      tips: _asString(json['tips']),
    );
  }

  Map<String, dynamic> toJson() => {
        'n': n,
        'text': text,
        'timer_min': timerMin,
        'tips': tips,
      };
}

/// -----------------------
/// Résultat du parseur
/// -----------------------

class RecipeParserResult {
  final ParsedRecipe? recipe; // recette normalisée
  final List<String> errors;  // erreurs de validation
  final String? normalizedJson; // JSON corrigé/normalisé

  RecipeParserResult({
    required this.recipe,
    required this.errors,
    required this.normalizedJson,
  });

  bool get isOk => errors.isEmpty && recipe != null;

  /// Conversion pratique vers ton ancien modèle `Recipe`.
  Recipe? toLegacy({List<String> userEquipment = const []}) {
    if (recipe == null) return null;
    return recipe!.toLegacyRecipe(userEquipment: userEquipment);
  }
}

/// -----------------------
/// API publique
/// -----------------------

/// Analyse du texte renvoyé par l'IA :
/// - si c'est déjà du JSON, parse + normalise + valide
/// - si c'est du texte libre avec un bloc { ... }, on extrait et on traite
RecipeParserResult parseAndValidateRecipe(String raw) {
  final errors = <String>[];

  String? jsonText = _extractJson(raw);
  if (jsonText == null) {
    errors.add('Aucun JSON détecté dans la réponse IA.');
    return RecipeParserResult(recipe: null, errors: errors, normalizedJson: null);
    }

  Map<String, dynamic>? map;
  try {
    map = json.decode(jsonText) as Map<String, dynamic>;
  } catch (e) {
    errors.add('JSON invalide: ${e.toString()}');
    return RecipeParserResult(recipe: null, errors: errors, normalizedJson: null);
  }

  // Normalisations minimales du schéma
  map['version'] ??= 'chefia.v1';

  final meta = _asMap(map['metadata']);
  map['metadata'] = meta;
  meta['language'] = _asString(meta['language'], fallback: 'fr');
  meta['servings'] = _asInt(meta['servings'], fallback: 2);

  final time = _asMap(meta['time']);
  meta['time'] = time;
  time['prep_min'] = _asInt(time['prep_min']);
  time['cook_min'] = _asInt(time['cook_min']);
  time['rest_min'] = _asInt(time['rest_min']);

  meta['difficulty'] = _asString(meta['difficulty'], fallback: 'facile');

  map['title'] = _asString(map['title']);
  map['equipment'] = _asStringList(map['equipment']);

  // Ingrédients normalisés
  final ingList = _asList(map['ingredients']).map((e) {
    final m = Map<String, dynamic>.from(_asMap(e));
    m['item'] = _normalizeItem(_asString(m['item']));
    m['quantity'] = _asDoubleOrNull(m['quantity']);
    m['unit'] = _normalizeUnit(_asString(m['unit']));
    m['notes'] = _asString(m['notes']);
    return m;
  }).toList();
  map['ingredients'] = ingList;

  // Étapes normalisées + renumérotation 1..N
  final steps = _asList(map['steps']).map((e) {
    final m = Map<String, dynamic>.from(_asMap(e));
    m['n'] = _asInt(m['n'], fallback: 0);
    if ((m['n'] as int) <= 0) m['n'] = 1;
    m['text'] = _cleanSentence(_asString(m['text']));
    m['timer_min'] = m['timer_min'] == null ? null : _asInt(m['timer_min']);
    m['tips'] = _asString(m['tips']);
    return m;
  }).toList();
  for (int i = 0; i < steps.length; i++) {
    final m = steps[i];
    m['n'] = i + 1;
  }
  map['steps'] = steps;

  map['allergens'] = _asStringList(map['allergens']);
  map['notes'] = _asStringList(map['notes']);

  // Validation finale
  _require(map['title'], 'title', errors);
  _requireListNonEmpty(map['ingredients'], 'ingredients', errors);
  _requireListNonEmpty(map['steps'], 'steps', errors);

  final normalized = json.encode(map);
  if (errors.isNotEmpty) {
    return RecipeParserResult(recipe: null, errors: errors, normalizedJson: normalized);
  }

  final parsed = ParsedRecipe.fromJson(map);
  return RecipeParserResult(recipe: parsed, errors: const [], normalizedJson: normalized);
}

/// -----------------------
/// Helpers
/// -----------------------

String? _extractJson(String raw) {
  final trimmed = raw.trim();
  if (trimmed.startsWith('{') && trimmed.endsWith('}')) return trimmed;
  final start = raw.indexOf('{');
  final end = raw.lastIndexOf('}');
  if (start >= 0 && end > start) {
    return raw.substring(start, end + 1);
  }
  return null;
}

Map<String, dynamic> _asMap(dynamic v) {
  if (v is Map<String, dynamic>) return v;
  if (v is Map) return Map<String, dynamic>.from(v);
  return <String, dynamic>{};
}

String _asString(dynamic v, {String fallback = ''}) {
  if (v == null) return fallback;
  return '$v'.trim();
}

int _asInt(dynamic v, {int fallback = 0}) {
  if (v == null) return fallback;
  if (v is int) return v;
  if (v is double) return v.round();
  final s = '$v'.replaceAll(RegExp(r'[^0-9\-]'), '');
  if (s.isEmpty) return fallback;
  return int.tryParse(s) ?? fallback;
}

double? _asDoubleOrNull(dynamic v) {
  if (v == null) return null;
  if (v is double) return v;
  if (v is int) return v.toDouble();
  var s = '$v'.toLowerCase().trim().replaceAll(',', '.');
  if (s.contains('/')) {
    final parts = s.split(' ');
    if (parts.length == 2 && parts[1].contains('/')) {
      final base = double.tryParse(parts[0]) ?? 0.0;
      final fracParts = parts[1].split('/');
      final num = double.tryParse(fracParts[0]) ?? 0.0;
      final den = double.tryParse(fracParts[1]) ?? 1.0;
      return base + (den == 0 ? 0.0 : num / den);
    }
  }
  return double.tryParse(s.replaceAll(RegExp(r'[^0-9\.\-]'), ''));
}

List _asList(dynamic v) {
  if (v is List) return v;
  return const [];
}

List<String> _asStringList(dynamic v) {
  if (v is List) {
    return v.map((e) => _asString(e)).where((e) => e.isNotEmpty).toList();
  }
  return const [];
}

String _normalizeUnit(String u) {
  final s = u.toLowerCase().trim();
  switch (s) {
    case 'grammes':
    case 'grams':
    case 'g.':
      return 'g';
    case 'millilitres':
    case 'ml.':
      return 'ml';
    case 'cuillère à soupe':
    case 'cas':
    case 'càs':
      return 'c.à.s';
    case 'cuillère à café':
    case 'cac':
    case 'càc':
      return 'c.à.c';
    case 'piece':
    case 'pièces':
    case 'pcs':
      return 'pièce';
    default:
      return s.isEmpty ? '' : s;
  }
}

String _normalizeItem(String s) {
  final t = s.trim();
  if (t.isEmpty) return '';
  final first = t[0].toUpperCase();
  return '$first${t.substring(1)}';
}

String _cleanSentence(String s) {
  var t = s.trim();
  if (t.isEmpty) return t;
  t = t[0].toUpperCase() + t.substring(1);
  if (!RegExp(r'[.!?]$').hasMatch(t)) t = '$t.';
  return t;
}

void _require(dynamic v, String name, List<String> errors) {
  if (v == null) errors.add('Champ manquant: $name.');
  if (v is String && v.trim().isEmpty) errors.add('Champ vide: $name.');
}

void _requireListNonEmpty(dynamic v, String name, List<String> errors) {
  if (v == null || v is! List || v.isEmpty) {
    errors.add('Liste requise non vide: $name.');
  }
}

String _formatQty(double v) {
  // 1.50 -> "1.5", 1.00 -> "1"
  final s = v.toStringAsFixed(v.truncateToDouble() == v ? 0 : 1);
  return s.replaceAll('.', ',');
}

```
